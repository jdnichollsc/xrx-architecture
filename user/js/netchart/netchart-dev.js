// DVSL Network Chart library. Development Version.
// (c) 2013 - 2014 Data Visualization Software Lab
//
// http://datavisualizationsoftwarelab.com http://dvsl.co

(function(){
    var base = {'Bar':{}};
    var network = {};
    
    // Generated by CoffeeScript 1.6.3
var Netchart_Selection;

Netchart_Selection = (function() {
  Netchart_Selection.prototype.scene = null;

  Netchart_Selection.prototype.events = null;

  Netchart_Selection.prototype.currentObject = null;

  function Netchart_Selection(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
    this.navigator = chart.navigator;
    this.dragPointers = {};
  }

  Netchart_Selection.prototype.onPointerMove = function(event) {
    var n;
    if (!this.scene.xyInChart(event.x, event.y)) {
      return;
    }
    n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    return this.switchCurrentObject(n, event);
  };

  Netchart_Selection.prototype.onPointerOut = function(event) {
    return this.switchCurrentObject(null, event);
  };

  Netchart_Selection.prototype.onPointerDown = function(event) {
    var n;
    if (!this.scene.xyInChart(event.x, event.y)) {
      return;
    }
    n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    this.switchCurrentObject(n, event);
    if (n instanceof Netchart_Node) {
      this.updateSelection(event, n, true);
      this.setPointerNode(event, n);
      return event.consumed = true;
    }
  };

  Netchart_Selection.prototype.onPointerUp = function(event) {
    if (this.dragPointers[event.identifier]) {
      this.setPointerNode(event, null);
      return event.consumed = true;
    }
  };

  Netchart_Selection.prototype.onPointerCancel = function(event) {
    return this.onPointerUp(event);
  };

  Netchart_Selection.prototype.onPointerDrag = function(event) {
    var newX, newY, p, _ref;
    p = this.dragPointers[event.identifier];
    if (!p) {
      return;
    }
    _ref = this.scene.fromDisplay(event.x, event.y), newX = _ref[0], newY = _ref[1];
    p.mouseX = event.x;
    p.mouseY = event.y;
    this.dragNodes(p, newX, newY, this.scene.settings.interaction.selection.lockNodesOnMove);
    return event.consumed = true;
  };

  Netchart_Selection.prototype.onClick = function(event) {
    var e, n;
    if (!this.scene.xyInChart(event.x, event.y)) {
      return;
    }
    n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    this.updateSelection(event, n, false);
    if (n instanceof Netchart_Node) {
      event.clickNode = n;
    } else {
      event.clickLink = n;
    }
    e = this.chart.notifyClick(event);
    if (e.defaultPrevented) {
      return event.consumed = true;
    }
  };

  Netchart_Selection.prototype.onRightClick = function(event) {
    var e, n;
    if (!this.scene.xyInChart(event.x, event.y)) {
      return;
    }
    n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    this.updateSelection(event, n, false);
    if (n instanceof Netchart_Node) {
      event.clickNode = n;
    } else {
      event.clickLink = n;
    }
    e = this.chart.notifyRightClick(event);
    if (e.defaultPrevented) {
      return event.consumed = true;
    }
  };

  Netchart_Selection.prototype.onDoubleClick = function(event) {
    var e, n;
    n = this.scene.findLinkOrNodeAt(event.x, event.y, this.scene.settings.interaction.selection.tolerance);
    if (n instanceof Netchart_Node) {
      event.clickNode = n;
    } else {
      event.clickLink = n;
    }
    e = this.chart.notifyDoubleClick(event);
    if (e.defaultPrevented) {
      return event.consumed = true;
    }
  };

  Netchart_Selection.prototype.doAnimations = function(event) {
    var id, newX, newY, p, _ref, _ref1, _results;
    _ref = this.dragPointers;
    _results = [];
    for (id in _ref) {
      p = _ref[id];
      _ref1 = this.scene.fromDisplay(p.mouseX, p.mouseY), newX = _ref1[0], newY = _ref1[1];
      this.dragNodes(p, newX, newY, false);
      _results.push(event.changes.coordinates = true);
    }
    return _results;
  };

  Netchart_Selection.prototype.updateSelection = function(event, target, softDeselect) {
    if (!this.scene.settings.interaction.selection.enabled) {
      return;
    }
    if (!event.shiftKey && (!target || (!this.scene.settings.interaction.selection.nodesSelectable && target.isNode) || (!this.scene.settings.interaction.selection.linksSelectable && target.isLink))) {
      return this.chart.setSelection([]);
    } else if (target && event.shiftKey || (softDeselect && Base_Helpers.arrayContains(this.scene.selection, target))) {
      if (!Base_Helpers.arrayContains(this.scene.selection, target)) {
        this.scene.selection.push(target);
        return this.chart.setSelection(this.scene.selection, true);
      }
    } else if (target) {
      return this.chart.setSelection([target]);
    }
  };

  Netchart_Selection.prototype.dragNodes = function(p, newX, newY, lock) {
    var dx, dy, n, _i, _len, _ref;
    dx = newX + p.x - p.node.x;
    dy = newY + p.y - p.node.y;
    if (Base_Helpers.countProperties(this.dragPointers) === 1 && this.scene.selection.length > 0) {
      _ref = this.scene.selection;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        n = _ref[_i];
        if (n.isNode) {
          n.x += dx;
          n.y += dy;
          if (lock) {
            n.userLock = true;
          }
        }
      }
    } else {
      p.node.x += dx;
      p.node.y += dy;
      if (lock) {
        p.node.userLock = true;
      }
    }
    return this.events.notifySceneChanges({
      coordinates: true
    });
  };

  Netchart_Selection.prototype.setPointerNode = function(event, node) {
    var id, oldP, x, y, _ref;
    id = event.identifier;
    oldP = this.dragPointers[id];
    if (oldP) {
      oldP.node.locks -= 1;
      delete this.dragPointers[id];
    }
    if (node) {
      _ref = this.scene.fromDisplay(event.x, event.y), x = _ref[0], y = _ref[1];
      this.dragPointers[event.identifier] = {
        x: node.x - x,
        y: node.y - y,
        node: node,
        mouseX: event.x,
        mouseY: event.y
      };
      return node.locks += 1;
    }
  };

  Netchart_Selection.prototype.switchCurrentObject = function(obj, event) {
    if (obj === this.currentSlice) {
      return;
    }
    event.changes.current = true;
    this.scene.setActiveObject(obj);
    if (this.currentSlice instanceof Netchart_Node) {
      this.currentSlice.locks -= 1;
    }
    this.currentSlice = obj;
    if (this.currentSlice instanceof Netchart_Node) {
      this.currentSlice.locks += 1;
    }
    if (this.currentSlice) {
      if (this.currentSlice.isNode) {
        event.hoverNode = this.currentSlice;
      }
      if (this.currentSlice.isLink) {
        event.hoverLink = this.currentSlice;
      }
    }
    return this.chart.notifyHoverChanged(event);
  };

  return Netchart_Selection;

})();

/*
//@ sourceMappingURL=Selection.map
*/

// Generated by CoffeeScript 1.6.3
/*
  retrieving and caching raw data
*/

var Netchart_Data,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Netchart_Data = (function() {
  Netchart_Data.prototype.settings = null;

  Netchart_Data.prototype.removed = false;

  Netchart_Data.prototype.nodes = {};

  Netchart_Data.prototype.links = {};

  Netchart_Data.prototype.nodeToLinks = {};

  Netchart_Data.prototype.pendingNodes = {};

  Netchart_Data.prototype.requestedNodes = {};

  Netchart_Data.prototype.requests = [];

  Netchart_Data.prototype.requestScheduled = false;

  Netchart_Data.prototype.cleanupScheduled = false;

  Netchart_Data.prototype.dataFunc = null;

  function Netchart_Data(chart) {
    var r;
    this.chart = chart;
    this.runRequests = __bind(this.runRequests, this);
    this.settings = chart.settings;
    this.nodes = {};
    this.links = {};
    this.nodeToLinks = {};
    this.pendingNodes = {};
    this.requestedNodes = {};
    this.dataFunc = this.getDataFunction();
    if (this.settings.data.randomNodes > 0) {
      r = this.genRandomGraph(this.settings.data);
      this.updateGraph(r);
    } else if (this.settings.data.preloaded) {
      this.dataArrived(null, this.settings.data.preloaded);
    }
  }

  Netchart_Data.otherEnd = function(linkData, nodeId) {
    if (nodeId === linkData.from) {
      return linkData.to;
    }
    if (nodeId === linkData.to) {
      return linkData.from;
    }
    return null;
  };

  Netchart_Data.multiLinkId = function(linkData) {
    if (linkData.from < linkData.to) {
      return linkData.from + "#" + linkData.to;
    } else {
      return linkData.to + "#" + linkData.from;
    }
  };

  Netchart_Data.prototype.remove = function() {
    return this.removed = true;
  };

  Netchart_Data.prototype.getQueueLength = function() {
    return Base_Helpers.countProperties(this.pendingNodes) + Base_Helpers.countProperties(this.requestedNodes);
  };

  Netchart_Data.prototype.getNodeData = function(id) {
    if (this.nodes.hasOwnProperty(id)) {
      return this.nodes[id];
    } else if (this.dataFunc != null) {
      this.requestNodeData(id);
    }
    return null;
  };

  Netchart_Data.prototype.nodeRemoved = function(id) {
    delete this.pendingNodes[id];
    return delete this.requestedNodes[id];
  };

  Netchart_Data.prototype.getLinkData = function(id) {
    return this.links[id];
  };

  Netchart_Data.prototype.getNodeLinks = function(id) {
    if (this.nodes.hasOwnProperty(id) && this.nodes[id].loaded) {
      return this.applyLinkFilter(id);
    } else if (this.dataFunc != null) {
      this.requestNodeData(id);
    }
    return null;
  };

  Netchart_Data.prototype.getNodeCollectedLinks = function(id) {
    return this.applyLinkFilter(id);
  };

  Netchart_Data.prototype.isLoaded = function(id) {
    return this.nodes.hasOwnProperty(id) && this.nodes[id].loaded;
  };

  Netchart_Data.prototype.isFilteredNode = function(id) {
    var nodeData, nodeFilter;
    nodeFilter = this.settings.filters.nodeFilter;
    nodeData = this.nodes[id];
    if (!nodeFilter || !nodeData) {
      return false;
    }
    return !nodeFilter(nodeData, this.isLoaded(id) ? this.nodeToLinks[id] : null);
  };

  Netchart_Data.prototype.getNodes = function() {
    var id, nodeData, nodeFilter, result, _ref;
    nodeFilter = this.settings.filters.nodeFilter;
    if (!nodeFilter) {
      return this.nodes;
    }
    result = {};
    _ref = this.nodes;
    for (id in _ref) {
      nodeData = _ref[id];
      if (nodeFilter(nodeData, this.isLoaded(id) ? this.nodeToLinks[id] : null)) {
        result[id] = nodeData;
      }
    }
    return result;
  };

  Netchart_Data.prototype.applyLinkFilter = function(nodeId) {
    var d1, d2, filtered, id, l, link, linkFilter, links, multiId, multiIds, multiLinkProcessor, multiLists, nodeData, nodeFilter, nodeLinksProcessor, otherNodeData, otherNodeId, otherNodes, processedLinks, _i, _j, _k, _l, _len, _len1, _len2, _len3;
    nodeData = this.nodes[nodeId];
    links = this.nodeToLinks[nodeId];
    if (!(links && links.length > 0)) {
      return [];
    }
    linkFilter = this.settings.filters.linkFilter;
    nodeFilter = this.settings.filters.nodeFilter;
    nodeLinksProcessor = this.settings.filters.nodeLinksProcessor;
    multiLinkProcessor = this.settings.filters.multilinkProcessor;
    if (nodeFilter && !nodeFilter(nodeData, nodeData.loaded ? links : null)) {
      return [];
    }
    if (nodeFilter || linkFilter) {
      filtered = [];
      for (_i = 0, _len = links.length; _i < _len; _i++) {
        link = links[_i];
        otherNodeId = Netchart_Data.otherEnd(link, nodeId);
        otherNodeData = this.nodes[otherNodeId];
        if (linkFilter) {
          if (link.from === nodeId) {
            d1 = nodeData;
            d2 = otherNodeData;
          } else {
            d1 = otherNodeData;
            d2 = nodeData;
          }
          if (!linkFilter(link, d1, d2)) {
            continue;
          }
        }
        if (nodeFilter && !nodeFilter(otherNodeData, otherNodeData.loaded ? this.nodeToLinks[otherNodeId] : null)) {
          continue;
        }
        filtered.push(link);
      }
      links = filtered;
    }
    if (nodeLinksProcessor) {
      links = nodeLinksProcessor(nodeData, links);
    }
    if (multiLinkProcessor) {
      otherNodes = {};
      for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
        link = links[_j];
        otherNodes[Netchart_Data.otherEnd(link, nodeId)] = true;
      }
      if (Base_Helpers.countProperties(otherNodes) < links.length) {
        filtered = [];
        multiIds = {};
        multiLists = {};
        for (_k = 0, _len2 = links.length; _k < _len2; _k++) {
          l = links[_k];
          multiId = Netchart_Data.multiLinkId(l);
          if (multiIds.hasOwnProperty(multiId)) {
            if (!multiLists.hasOwnProperty(multiId)) {
              multiLists[multiId] = [multiIds[multiId], l];
            } else {
              multiLists[multiId].push(l);
            }
          } else {
            multiIds[multiId] = l;
          }
        }
        for (_l = 0, _len3 = links.length; _l < _len3; _l++) {
          l = links[_l];
          multiId = Netchart_Data.multiLinkId(l);
          if (!multiLists.hasOwnProperty(multiId)) {
            filtered.push(l);
          }
        }
        for (id in multiLists) {
          links = multiLists[id];
          l = links[0];
          processedLinks = multiLinkProcessor(links, this.nodes[l.from], this.nodes[l.to]);
          if (Base_Helpers.isArray(processedLinks)) {
            filtered.concat(processedLinks);
          } else if (processedLinks) {
            filtered.push(processedLinks);
          }
        }
        links = filtered;
      }
    }
    return links;
  };

  Netchart_Data.prototype.getAllNodes = function(callback) {
    var id, n, nodes, res,
      _this = this;
    if (!this.dataFunc) {
      nodes = (function() {
        var _ref, _results;
        _ref = this.nodes;
        _results = [];
        for (id in _ref) {
          n = _ref[id];
          _results.push(id);
        }
        return _results;
      }).call(this);
      return callback(nodes);
    } else {
      res = function(data) {
        _this.dataArrived(null, data);
        nodes = (function() {
          var _ref, _results;
          _ref = this.nodes;
          _results = [];
          for (id in _ref) {
            n = _ref[id];
            _results.push(id);
          }
          return _results;
        }).call(_this);
        return callback(nodes);
      };
      return this.dataFunc(null, res, this.dataError);
    }
  };

  Netchart_Data.prototype.requestNodeData = function(nodeId) {
    if (this.pendingNodes.hasOwnProperty(nodeId) || this.requestedNodes.hasOwnProperty(nodeId)) {
      return;
    }
    this.pendingNodes[nodeId] = true;
    if ((this.dataFunc != null) && !this.requestScheduled) {
      this.requestScheduled = true;
      return setTimeout(this.runRequests, 0);
    }
  };

  Netchart_Data.prototype.runRequests = function() {
    var id, r, remainingRequests, time, timeout, _i, _j, _len, _len1, _ref, _ref1,
      _this = this;
    if (this.removed) {
      return;
    }
    this.requestScheduled = false;
    time = new Date().getTime();
    timeout = this.settings.data.requestTimeout;
    if (this.cleanupScheduled) {
      this.cleanupScheduled = false;
      remainingRequests = [];
      _ref = this.requests;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        r = _ref[_i];
        if (r.time + timeout > time) {
          remainingRequests.push(r);
        } else {
          _ref1 = r.nodes;
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            id = _ref1[_j];
            if (this.requestedNodes[id]) {
              delete this.requestedNodes[id];
              this.pendingNodes[id] = true;
            }
          }
          if (r.time !== 0) {
            this.chart.error("Data request timed out, timeout " + timeout + " ms");
          }
        }
      }
      this.requests = remainingRequests;
    }
    while (Base_Helpers.hasProperties(this.pendingNodes) && this.requests.length < this.settings.data.numberOfParralelRequests) {
      (function() {
        var failFunc, nodes, okFunc, request, _, _ref2;
        nodes = [];
        _ref2 = _this.pendingNodes;
        for (id in _ref2) {
          _ = _ref2[id];
          nodes.push(id);
          delete _this.pendingNodes[id];
          _this.requestedNodes[id] = true;
          if (nodes.length > _this.settings.data.requestMaxUnits) {
            break;
          }
        }
        _this.chart.log("Requesting data on " + nodes);
        request = {
          time: time,
          nodes: nodes
        };
        okFunc = function(data) {
          return _this.dataArrived(request, data);
        };
        failFunc = function() {
          return _this.dataError(request);
        };
        _this.dataFunc(nodes, okFunc, failFunc);
        return _this.requests.push(request);
      })();
    }
    if (this.requests.length > 0 && !this.cleanupScheduled) {
      this.cleanupScheduled = true;
      return setTimeout(this.runRequests, timeout);
    }
  };

  Netchart_Data.prototype.dataError = function(request) {
    if (this.removed) {
      return;
    }
    this.chart.error("Data request failed for nodes: " + request.nodes);
    request.time = 0;
    this.cleanupScheduled = true;
    return this.runRequests();
  };

  Netchart_Data.prototype.dataArrived = function(request, rawData) {
    var allOk, data, hasLoadedRequestedNodes, hasResultsOnRequestedNodes, id, ids, key, loaded, n, nodes, obj, required, updatedNodes, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _len7, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
    if (this.removed) {
      return;
    }
    allOk = false;
    if (rawData) {
      data = Base_Helpers.parseData(rawData, this.settings.data.format, this.chart);
      if (data.error != null) {
        this.chart.error(data.error);
      }
      allOk = true;
      _ref = ["links", "nodes"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        required = _ref[_i];
        if (!data.hasOwnProperty(required)) {
          allOk = false;
          this.chart.error("Field " + required + " not set in data");
        }
      }
      if (allOk) {
        if (!Base_Helpers.isArray(data.nodes)) {
          obj = data.nodes;
          data.nodes = [];
          for (key in obj) {
            value = obj[key];
            value.id = key;
            data.nodes.push(value);
          }
        }
        if (!Base_Helpers.isArray(data.links)) {
          obj = data.links;
          data.links = [];
          for (key in obj) {
            value = obj[key];
            value.id = key;
            data.links.push(value);
          }
        }
        if (request) {
          this.chart.log("Got " + data.nodes.length + " data on  " + request.nodes);
        } else {
          this.chart.log("Got " + data.nodes.length + " data on all nodes");
        }
        hasResultsOnRequestedNodes = !(request && data.nodes.length > 0);
        hasLoadedRequestedNodes = !(request && data.nodes.length > 0);
        ids = {};
        _ref1 = data.nodes;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          n = _ref1[_j];
          if (ids.hasOwnProperty(n.id)) {
            this.chart.error("Data response: Multiple nodes with the same ID: " + n.id);
          }
          ids[n.id] = true;
          if (request && Base_Helpers.arrayContains(request.nodes, n.id)) {
            hasResultsOnRequestedNodes = true;
            hasLoadedRequestedNodes || (hasLoadedRequestedNodes = n.loaded);
          }
          ids = {};
        }
        _ref2 = data.links;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          n = _ref2[_k];
          if (ids.hasOwnProperty(n.id)) {
            this.chart.error("Data response: Multiple links with the same ID: " + n.id);
          }
          ids[n.id] = true;
        }
        if (!hasResultsOnRequestedNodes) {
          this.chart.error("Data response: Results set did not contain requested nodes");
        } else if (!hasLoadedRequestedNodes) {
          this.chart.error("Data response: loaded field was not set on any of the requested nodes, adding manually");
          _ref3 = data.nodes;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            n = _ref3[_l];
            if (Base_Helpers.arrayContains(request.nodes, n.id)) {
              n.loaded = true;
            }
          }
        }
      }
    } else {
      this.chart.error("Got empty response");
    }
    loaded = {};
    if (!allOk) {
      nodes = [];
      _ref4 = request.nodes;
      for (_m = 0, _len4 = _ref4.length; _m < _len4; _m++) {
        id = _ref4[_m];
        nodes.push({
          id: id,
          error: "Bad response",
          loaded: true
        });
      }
      data = {
        nodes: nodes,
        links: []
      };
    }
    this.updateGraph(data);
    _ref5 = data.nodes;
    for (_n = 0, _len5 = _ref5.length; _n < _len5; _n++) {
      n = _ref5[_n];
      if (n.loaded) {
        loaded[n.id] = true;
        delete this.pendingNodes[n.id];
      }
      if (n.error) {
        delete this.pendingNodes[n.id];
        loaded[n.id] = true;
      }
    }
    updatedNodes = {};
    _ref6 = data.nodes;
    for (_o = 0, _len6 = _ref6.length; _o < _len6; _o++) {
      n = _ref6[_o];
      updatedNodes[n.id] = true;
    }
    this.chart.events.notifySceneChanges({
      dataArrived: true,
      dataLoadedNodesIds: loaded,
      dataNodesIds: updatedNodes
    });
    if (request) {
      Base_Helpers.removeFromArray(this.requests, request);
      _ref7 = request.nodes;
      for (_p = 0, _len7 = _ref7.length; _p < _len7; _p++) {
        n = _ref7[_p];
        delete this.requestedNodes[n];
      }
      return this.runRequests();
    }
  };

  Netchart_Data.prototype.updateGraph = function(data) {
    var n, orig, _i, _j, _len, _len1, _ref, _ref1, _results;
    _ref = data.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (this.nodes.hasOwnProperty(n.id)) {
        if (!n.error && n.loaded) {
          delete this.nodes[n.id]["_noData"];
          Base_Helpers.extend(this.nodes[n.id], n);
        }
      } else {
        this.nodes[n.id] = n;
        this.nodeToLinks[n.id] = [];
      }
    }
    _ref1 = data.links;
    _results = [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      n = _ref1[_j];
      if (this.links.hasOwnProperty(n.id)) {
        orig = this.links[n.id];
        if (orig.from !== n.from || orig.to !== n.to) {
          _results.push(this.chart.error("Changing link from,to not supported"));
        } else {
          _results.push(Base_Helpers.extend(this.links[n.id], n));
        }
      } else {
        if (!this.nodes.hasOwnProperty(n.from)) {
          this.nodes[n.from] = {
            id: n.from,
            _noData: true
          };
          this.nodeToLinks[n.from] = [];
        }
        if (!this.nodes.hasOwnProperty(n.to)) {
          this.nodes[n.to] = {
            id: n.to,
            _noData: true
          };
          this.nodeToLinks[n.to] = [];
        }
        this.links[n.id] = n;
        this.nodeToLinks[n.from].push(n);
        _results.push(this.nodeToLinks[n.to].push(n));
      }
    }
    return _results;
  };

  Netchart_Data.prototype.genRandomGraph = function(settings) {
    var data, link, node, numLinks, numNodes, _i, _j, _len, _len1, _ref, _ref1;
    numNodes = settings.randomNodes;
    numLinks = settings.randomLinks;
    if (settings.random === "grid") {
      data = this.genRandomGrid(numNodes, settings.randomGridLinkProbability);
    } else {
      data = this.genRandomUniform(numNodes, numLinks);
    }
    _ref = data.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      node.name = "Node " + node.id;
      node.value = 10 + Math.random() * 40;
    }
    _ref1 = data.links;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      link = _ref1[_j];
      link.name = "Link " + link.id;
      link.value = 1 + Math.random() * 5;
    }
    return data;
  };

  Netchart_Data.prototype.genRandomGrid = function(numNodes, linkProbability) {
    var gridSize, i, ind, l, links, n, nodes, x, y, _i, _j, _k, _l, _len, _ref, _ref1, _ref2;
    nodes = [];
    links = [];
    for (i = _i = 0, _ref = numNodes - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = {
        id: "n" + i,
        loaded: true
      };
      nodes.push(n);
    }
    gridSize = Math.ceil(Math.sqrt(numNodes));
    for (y = _j = 0, _ref1 = gridSize - 1; _j <= _ref1; y = _j += 1) {
      for (x = _k = 0, _ref2 = gridSize - 1; _k <= _ref2; x = _k += 1) {
        ind = x + y * gridSize;
        if (ind >= numNodes) {
          continue;
        }
        if (x > 0 && Math.random() <= linkProbability) {
          links.push({
            from: "n" + ind,
            to: "n" + (ind - 1)
          });
        }
        if (y > 0 && Math.random() <= linkProbability) {
          links.push({
            from: "n" + ind,
            to: "n" + (ind - gridSize)
          });
        }
      }
    }
    for (ind = _l = 0, _len = links.length; _l < _len; ind = ++_l) {
      l = links[ind];
      l.id = "" + ind;
    }
    return {
      nodes: nodes,
      links: links
    };
  };

  Netchart_Data.prototype.genRandomUniform = function(numNodes, numLinks) {
    var i, l, links, n, nodes, _i, _j, _ref, _ref1, _ref2;
    nodes = [];
    links = [];
    for (i = _i = 0, _ref = numNodes - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      n = {
        id: "n" + i,
        loaded: true
      };
      if (nodes.length > 0) {
        l = {
          id: "l" + i,
          from: n.id,
          to: nodes[Math.random() * nodes.length | 0].id
        };
        links.push(l);
      }
      nodes.push(n);
    }
    for (i = _j = _ref1 = links.length, _ref2 = numLinks - 1; _j <= _ref2; i = _j += 1) {
      l = {
        id: "l" + (i + 1),
        from: nodes[Math.random() * nodes.length | 0].id,
        to: nodes[Math.random() * nodes.length | 0].id
      };
      links.push(l);
    }
    return {
      nodes: nodes,
      links: links
    };
  };

  Netchart_Data.prototype.getDataFunction = function() {
    var config;
    config = this.settings.data;
    if (config.dataFunction) {
      return config.dataFunction;
    } else if (config.url) {
      return function(nodes, success, fail) {
        var params;
        params = [];
        if (nodes != null) {
          params.push(["nodes", nodes.toString()]);
        }
        return Base_Helpers.doRequest(config.url, params, success, fail);
      };
    } else {
      return null;
    }
  };

  Netchart_Data.prototype.isFilteredLink = function(id) {
    var linkData, linkFilter;
    linkFilter = this.settings.filters.linkFilter;
    linkData = this.links[id];
    if (!linkFilter || !linkData) {
      return false;
    }
    return !linkFilter(linkData, this.nodes[linkData.from], this.nodes[linkData.to]);
  };

  Netchart_Data.prototype.dumpData = function(shuffleIds) {
    var id, l, link, linkIds, n, newId, nextLinkId, nextNodeId, nn, node, nodeIds, result, _ref, _ref1;
    nodeIds = {};
    linkIds = {};
    nextNodeId = 0;
    nextLinkId = 0;
    nn = {};
    n = [];
    l = [];
    _ref = this.nodes;
    for (id in _ref) {
      node = _ref[id];
      if (!this.isFilteredNode(id)) {
        n.push(node);
        if (shuffleIds) {
          newId = "" + nextNodeId;
          nextNodeId += 1;
          nodeIds[newId] = id;
          node.id = newId;
        }
        nn[id] = true;
      }
    }
    _ref1 = this.links;
    for (id in _ref1) {
      link = _ref1[id];
      if (!this.isFilteredLink(id) && nn[link.from] && nn[link.to]) {
        l.push(link);
        if (shuffleIds) {
          newId = "" + nextLinkId;
          nextLinkId += 1;
          linkIds[newId] = id;
          link.id = newId;
          link.from = this.nodes[link.from].id;
          link.to = this.nodes[link.to].id;
        }
      }
    }
    result = JSON.stringify({
      nodes: n,
      links: l
    }, ["nodes", "links", "id", "from", "to", "type", "state", "loaded", "Employees", "position_title", "start", "end", "shares_perc", "terminated", "status", "finanses", "Turnover_prev", "Employees_prev"], "  ");
    for (newId in nodeIds) {
      id = nodeIds[newId];
      this.nodes[id].id = id;
    }
    for (newId in linkIds) {
      id = linkIds[newId];
      l = this.links[id];
      l.id = id;
      l.from = nodeIds[l.from];
      l.to = nodeIds[l.to];
    }
    return result;
  };

  return Netchart_Data;

})();

/*
//@ sourceMappingURL=Data.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Graph;

Netchart_Graph = (function() {
  function Netchart_Graph(chart) {
    this.chart = chart;
    this.settings = this.chart.settings;
    this.scene = this.chart.scene;
    this.idToNode = {};
    this.idToLink = {};
    this.linksQueue = {};
    this.nodeQueue = {};
    this.state = {};
  }

  Netchart_Graph.prototype.save = function() {
    var id, node, state, _ref;
    state = {};
    _ref = this.idToNode;
    for (id in _ref) {
      node = _ref[id];
      state[node.id] = {
        x: node.x,
        y: node.y,
        r: node.currentRadius
      };
    }
    return state;
  };

  Netchart_Graph.prototype.restore = function(state) {
    var id, n, s, _results;
    this.state = {};
    _results = [];
    for (id in state) {
      s = state[id];
      if (this.idToNode.hasOwnProperty(id)) {
        n = this.idToNode[id];
        n.x = s.x;
        n.y = s.y;
        _results.push(n.currentRadius = s.r);
      } else {
        _results.push(this.state[id] = s);
      }
    }
    return _results;
  };

  Netchart_Graph.prototype.removeAll = function() {
    var id, id1, link, node, _ref, _ref1, _results;
    _ref = this.idToLink;
    for (id in _ref) {
      link = _ref[id];
      this.removeLink(id);
    }
    _ref1 = this.idToNode;
    _results = [];
    for (id1 in _ref1) {
      node = _ref1[id1];
      _results.push(this.removeNode(id1));
    }
    return _results;
  };

  Netchart_Graph.prototype.lockNode = function(nodeId, x, y) {
    var n;
    if (!this.idToNode.hasOwnProperty(nodeId)) {
      return this.chart.error("Locking nonexistant node: " + nodeId);
    } else {
      n = this.idToNode[nodeId];
      n.userLock = true;
      if (x !== void 0 && y !== void 0) {
        n.x = x;
        n.y = y;
      }
      return this.scene.touchNode(n);
    }
  };

  Netchart_Graph.prototype.unlockNode = function(nodeId) {
    var n;
    if (!this.idToNode.hasOwnProperty(nodeId)) {
      return this.chart.error("Locking nonexistant node: " + nodeId);
    } else {
      n = this.idToNode[nodeId];
      n.userLock = false;
      return this.scene.touchNode(n);
    }
  };

  Netchart_Graph.prototype.addNode = function(nodeId) {
    var data, n, s;
    if (this.idToNode.hasOwnProperty(nodeId)) {
      return this.idToNode[nodeId];
    }
    n = this.scene.addNode(nodeId);
    n.dataLinks = [];
    this.idToNode[nodeId] = n;
    if (this.state.hasOwnProperty(nodeId)) {
      s = this.state[nodeId];
      delete this.state[nodeId];
      n.x = s.x;
      n.y = s.y;
      n.currentRadius = s.r;
    }
    data = this.scene.data.getNodeData(nodeId);
    if (data != null) {
      this.addNodeImpl(nodeId, data);
    } else {
      this.nodeQueue[nodeId] = true;
      n.loading = true;
      this.toggleLoading();
    }
    return n;
  };

  Netchart_Graph.prototype.addNodeWithLinks = function(nodeId) {
    var n;
    n = this.addNode(nodeId);
    if (!n.data || !n.data.loaded) {
      this.scene.data.getNodeLinks(nodeId);
      this.linksQueue[nodeId] = true;
      n.loading = true;
      this.toggleLoading();
    }
    return n;
  };

  Netchart_Graph.prototype.addNodeImpl = function(nodeId, data) {
    var expand, links, n;
    expand = this.linksQueue.hasOwnProperty(nodeId);
    n = this.idToNode[nodeId];
    n.data = data;
    n.loading = false;
    this.scene.touchNode(n);
    if (this.scene.settings.data.preloadNodeLinks || expand) {
      links = this.scene.data.getNodeLinks(nodeId);
    } else {
      links = this.scene.data.getNodeCollectedLinks(nodeId);
    }
    if (links != null) {
      delete this.linksQueue[nodeId];
      this.updateNodeLinks(n, links);
    } else {
      n.loading = true;
      this.linksQueue[nodeId] = true;
      this.updateNodeLinks(n, this.scene.data.getNodeCollectedLinks(nodeId));
      this.toggleLoading();
    }
    return n;
  };

  Netchart_Graph.prototype.expandNode = function(nodeId) {
    var n;
    n = this.addNodeWithLinks(nodeId);
    if (!n.expanded) {
      n.expanded = true;
      this.expandImpl(n);
      return this.scene.touchNode(n);
    }
  };

  Netchart_Graph.prototype.expandImpl = function(node) {
    var link, n1, _i, _len, _ref, _results;
    if (!node.dataLinks) {
      return;
    }
    _ref = node.dataLinks;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      n1 = Netchart_Data.otherEnd(link, node.id);
      _results.push(this.addNode(n1));
    }
    return _results;
  };

  Netchart_Graph.prototype.collapseNode = function(nodeId) {
    var hideN1, link, link2, links, n, n1, n2, _i, _j, _len, _len1, _ref, _results;
    n = this.idToNode[nodeId];
    if (!n) {
      return;
    }
    n.expanded = false;
    this.scene.touchNode(n);
    links = n.links.slice(0);
    _results = [];
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      link = links[_i];
      n1 = link.otherEnd(n);
      if (n1 === n) {
        continue;
      }
      hideN1 = true;
      _ref = n1.links;
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        link2 = _ref[_j];
        n2 = link2.otherEnd(n1);
        if (n2 !== n1 && n2 !== n) {
          hideN1 = false;
          break;
        }
      }
      if (hideN1) {
        _results.push(this.removeNode(n1.id));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Graph.prototype.updateNodeLinks = function(node, links) {
    var link, linkData, pos, visibleLinks, _i, _len, _results;
    node.dataLinks = links;
    visibleLinks = {};
    for (_i = 0, _len = links.length; _i < _len; _i++) {
      linkData = links[_i];
      link = this.tryAddLink(linkData);
      if (link) {
        visibleLinks[linkData.id] = true;
      }
    }
    pos = 0;
    _results = [];
    while (pos < node.links.length) {
      link = node.links[pos];
      if (!visibleLinks.hasOwnProperty(link.id) && this.idToLink.hasOwnProperty(link.id)) {
        _results.push(this.removeLink(link.id));
      } else {
        _results.push(pos++);
      }
    }
    return _results;
  };

  Netchart_Graph.prototype.tryAddLink = function(linkData) {
    var link;
    if (this.idToLink.hasOwnProperty(linkData.id)) {
      return this.idToLink[linkData.id];
    }
    if (this.idToNode.hasOwnProperty(linkData.from) && this.idToNode.hasOwnProperty(linkData.to)) {
      link = this.scene.addLink(linkData.id, linkData.from, linkData.to);
      link.data = linkData;
      this.idToLink[linkData.id] = link;
      link.from = this.idToNode[linkData.from];
      link.from.links.push(link);
      this.scene.touchNode(link.from);
      link.to = this.idToNode[linkData.to];
      link.to.links.push(link);
      this.scene.touchNode(link.to);
      return link;
    } else {
      return null;
    }
  };

  Netchart_Graph.prototype.removeNode = function(nodeId) {
    var link, node, other, _i, _len, _ref;
    if (!this.idToNode.hasOwnProperty(nodeId)) {
      return;
    }
    node = this.idToNode[nodeId];
    _ref = node.links;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      delete this.idToLink[link.id];
      other = link.otherEnd(node);
      if (other !== node) {
        Base_Helpers.removeFromArray(other.links, link);
        this.scene.touchNode(other);
      }
      this.scene.removeLink(link);
    }
    node.links = [];
    delete this.idToNode[nodeId];
    delete this.nodeQueue[nodeId];
    delete this.linksQueue[nodeId];
    this.scene.removeNode(node);
    this.scene.data.nodeRemoved(nodeId);
    return this.toggleLoading();
  };

  Netchart_Graph.prototype.removeLink = function(linkId) {
    var link;
    if (this.idToLink.hasOwnProperty(linkId)) {
      link = this.idToLink[linkId];
      delete this.idToLink[linkId];
      Base_Helpers.removeFromArray(link.from.links, link);
      Base_Helpers.removeFromArray(link.to.links, link);
      this.scene.touchNode(link.from);
      this.scene.touchNode(link.to);
      return this.scene.removeLink(link);
    }
  };

  Netchart_Graph.prototype.onSceneChange = function(event) {
    var dataNodesSorted, graphChanges, id, links, node, _, _i, _j, _len, _len1, _ref, _ref1;
    if (!event.changes.dataArrived) {
      return;
    }
    graphChanges = false;
    dataNodesSorted = [];
    _ref = event.changes.dataNodesIds;
    for (id in _ref) {
      _ = _ref[id];
      dataNodesSorted.push(id);
    }
    dataNodesSorted.sort();
    for (_i = 0, _len = dataNodesSorted.length; _i < _len; _i++) {
      id = dataNodesSorted[_i];
      if (this.nodeQueue.hasOwnProperty(id)) {
        delete this.nodeQueue[id];
        this.addNodeImpl(id, this.scene.data.getNodeData(id));
        graphChanges = true;
      } else if (this.idToNode.hasOwnProperty(id)) {
        this.scene.touchNode(this.idToNode[id]);
      }
    }
    dataNodesSorted = [];
    _ref1 = event.changes.dataLoadedNodesIds;
    for (id in _ref1) {
      _ = _ref1[id];
      dataNodesSorted.push(id);
    }
    dataNodesSorted.sort();
    for (_j = 0, _len1 = dataNodesSorted.length; _j < _len1; _j++) {
      id = dataNodesSorted[_j];
      delete this.linksQueue[id];
      if (this.idToNode.hasOwnProperty(id)) {
        links = this.scene.data.getNodeLinks(id);
        if (links === null) {
          this.chart.error("Internal error - no links for exapnded node");
          continue;
        }
        node = this.idToNode[id];
        node.loading = false;
        this.updateNodeLinks(node, links);
        if (node.expanded) {
          this.expandImpl(node);
        }
        graphChanges = true;
      }
    }
    return this.toggleLoading();
  };

  Netchart_Graph.prototype.updateFilter = function() {
    var data, goodLinks, id, link, linkData, node, nodeFilter, nodeLinks, _i, _len, _ref, _ref1, _ref2, _results;
    nodeFilter = this.settings.filters.nodeFilter;
    goodLinks = {};
    data = this.scene.data;
    _ref = this.idToNode;
    for (id in _ref) {
      node = _ref[id];
      nodeLinks = data.nodeToLinks[id];
      if (nodeFilter && node.data && !nodeFilter(node.data, nodeLinks)) {
        this.removeNode(node.id);
      } else {
        node.dataLinks = data.getNodeCollectedLinks(id);
        _ref1 = node.dataLinks;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          linkData = _ref1[_i];
          goodLinks[linkData.id] = true;
          this.tryAddLink(linkData);
        }
      }
    }
    _ref2 = this.idToLink;
    _results = [];
    for (id in _ref2) {
      link = _ref2[id];
      if (!goodLinks.hasOwnProperty(id)) {
        _results.push(this.removeLink(id));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Graph.prototype.toggleLoading = function() {
    if (Base_Helpers.hasProperties(this.nodeQueue) || Base_Helpers.hasProperties(this.linksQueue)) {
      if (!this.scene.loading) {
        return this.scene.loading = true;
      }
    } else {
      if (this.scene.loading) {
        return this.scene.loading = false;
      }
    }
  };

  return Netchart_Graph;

})();

/*
//@ sourceMappingURL=Graph.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Navigator;

Netchart_Navigator = (function() {
  Netchart_Navigator.prototype.FocusNode = (function() {
    function _Class() {}

    _Class.prototype.id = null;

    _Class.prototype.relevance = -1;

    _Class.prototype.initial = false;

    _Class.prototype.stopped = false;

    _Class.prototype.hidden = false;

    _Class.prototype.expanded = false;

    _Class.prototype.collapsed = false;

    _Class.prototype.actionId = 0;

    return _Class;

  })();

  Netchart_Navigator.prototype.lastExpandTime = 0;

  Netchart_Navigator.prototype.nextId = 0;

  Netchart_Navigator.prototype.animationPriority = 1005;

  Netchart_Navigator.prototype.otherEnd = Netchart_Data.otherEnd;

  function Netchart_Navigator(chart) {
    this.chart = chart;
    this.graph = this.chart.graph;
    this.scene = this.chart.scene;
    this.nodes = {};
  }

  Netchart_Navigator.prototype.clear = function() {
    this.chart.events.notifySceneChanges({
      navigation: true
    });
    return this.nodes = {};
  };

  Netchart_Navigator.prototype.addAction = function(nodeId, params) {
    var a;
    this.chart.events.notifySceneChanges({
      navigation: true
    });
    a = new this.FocusNode();
    a.id = nodeId;
    a.actionId = this.nextId;
    this.nextId += 1;
    Base_Helpers.extend(a, params);
    this.nodes[nodeId] = a;
    return a;
  };

  Netchart_Navigator.prototype.updateAction = function(nodeId, params) {
    var a;
    this.chart.events.notifySceneChanges({
      navigation: true
    });
    a = this.nodes[nodeId];
    a.actionId = this.nextId;
    this.nextId += 1;
    Base_Helpers.extend(a, params);
    return a;
  };

  Netchart_Navigator.prototype.hideNode = function(nodeId) {
    return this.addAction(nodeId, {
      hidden: true
    });
  };

  Netchart_Navigator.prototype.collapseNode = function(nodeId) {
    return this.addAction(nodeId, {
      collapsed: true
    });
  };

  Netchart_Navigator.prototype.addFocusNode = function(nodeId, relevance) {
    if (relevance == null) {
      relevance = -1;
    }
    return this.addAction(nodeId, {
      relevance: relevance,
      initial: true
    });
  };

  Netchart_Navigator.prototype.expandNode = function(nodeId) {
    if (this.nodes[nodeId] && this.nodes[nodeId].initial) {
      return this.updateAction(nodeId, {
        expanded: true
      });
    } else {
      return this.addAction(nodeId, {
        expanded: true
      });
    }
  };

  Netchart_Navigator.prototype.unexpandNode = function(nodeId) {
    if (this.nodes[nodeId]) {
      return this.updateAction(nodeId, {
        initial: false
      });
    }
  };

  Netchart_Navigator.prototype.save = function() {
    return this.nodes;
  };

  Netchart_Navigator.prototype.restore = function(state) {
    var a, nodeId, _ref;
    this.nodes = state;
    this.nextId = 0;
    _ref = this.nodes;
    for (nodeId in _ref) {
      a = _ref[nodeId];
      this.nextId = Math.max(a.actionId, this.nextId);
    }
    this.nextId++;
    return this.chart.events.notifySceneChanges({
      navigation: true
    });
  };

  Netchart_Navigator.prototype.showInitialNodes = function() {
    var addNodes, id, settings, _i, _j, _len, _len1, _ref, _ref1, _results, _results1,
      _this = this;
    this.clear();
    this.graph.removeAll();
    settings = this.scene.settings.navigation;
    if (settings.mode === "focusnodes") {
      if (settings.initialNodes && settings.initialNodes.length) {
        _ref = settings.initialNodes;
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          id = _ref[_i];
          this.scene.userNodeIds[id] = true;
          _results.push(this.addFocusNode(id, -1));
        }
        return _results;
      }
    } else if (settings.mode === "manual") {
      if (settings.initialNodes && settings.initialNodes.length) {
        _ref1 = settings.initialNodes;
        _results1 = [];
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          id = _ref1[_j];
          this.scene.userNodeIds[id] = true;
          _results1.push(this.addFocusNode(id, 1));
        }
        return _results1;
      }
    } else if (settings.mode === "showall" || true) {
      addNodes = function(nodes) {
        var _k, _len2, _results2;
        _results2 = [];
        for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
          id = nodes[_k];
          _results2.push(_this.graph.expandNode(id));
        }
        return _results2;
      };
      return this.scene.data.getAllNodes(addNodes);
    }
  };

  Netchart_Navigator.prototype.doAnimations = function(event) {
    if (!(event.changes.navigation || event.changes.dataArrived || this.scene.hasTopologyChanges() || event.changes.settings || event.changes.data)) {
      return;
    }
    return this.updateGraph();
  };

  Netchart_Navigator.prototype.updateGraph = function() {
    var e, r, time, _ref;
    time = new Date().getTime();
    if (this.scene.settings.navigation.expandDelay && this.lastExpandTime > time - this.scene.settings.navigation.expandDelay) {
      this.chart.events.notifySceneChanges({
        navigation: true
      });
      return;
    }
    this.lastExpandTime = time;
    this.resolveConflicts();
    _ref = this.computeRelevances(), r = _ref[0], e = _ref[1];
    return this.applyRelevances(r, e);
  };

  Netchart_Navigator.prototype.resolveConflicts = function() {
    var a, focusNodes, i, id, link, links, maxFocusNodes, nodeId, otherFocus, otherNodeId, _i, _len, _ref, _ref1, _results;
    _ref = this.nodes;
    _results = [];
    for (nodeId in _ref) {
      a = _ref[nodeId];
      if (this.scene.settings.navigation.mode !== "focusnodes" && this.scene.data.isFilteredNode(nodeId)) {
        delete this.nodes[nodeId];
        continue;
      }
      if (!a.initial && !a.hidden && !this.graph.idToNode.hasOwnProperty(nodeId)) {
        delete this.nodes[nodeId];
        continue;
      }
      if (a.expanded) {
        links = this.scene.data.getNodeCollectedLinks(nodeId);
        for (_i = 0, _len = links.length; _i < _len; _i++) {
          link = links[_i];
          otherNodeId = this.otherEnd(link, nodeId);
          otherFocus = this.nodes[otherNodeId];
          if (otherFocus && otherFocus.actionId < a.actionId && otherFocus.hidden) {
            delete this.nodes[otherNodeId];
          }
        }
      }
      if (this.scene.settings.navigation.mode === "focusnodes") {
        maxFocusNodes = this.scene.settings.navigation.numberOfFocusNodes;
        focusNodes = [];
        _ref1 = this.nodes;
        for (id in _ref1) {
          a = _ref1[id];
          if (a.initial) {
            focusNodes.push(a);
          }
        }
        focusNodes.sort(function(a, b) {
          return a.actionId - b.actionId;
        });
        i = 0;
        _results.push((function() {
          var _results1;
          _results1 = [];
          while (focusNodes.length - i > maxFocusNodes) {
            focusNodes[i].initial = false;
            _results1.push(i++);
          }
          return _results1;
        })());
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Navigator.prototype.computeRelevances = function() {
    var a, autoExpandFilterFunc, cold, cooldown, data, expand, expandIncremental, expandUnfished, expandedNodes, expandedRelevances, focusNodes, id, linkData, links, mode, n1, n1rel, q1, queue, r, rel, _, _i, _j, _len, _len1, _ref, _ref1, _ref2;
    this.changes = false;
    expandedRelevances = {};
    expandedNodes = {};
    queue = {};
    expandIncremental = !!this.scene.settings.navigation.expandDelay;
    expandUnfished = false;
    autoExpandFilterFunc = this.scene.settings.navigation.nodeAutoExpandFilter;
    mode = this.scene.settings.navigation.mode;
    if (mode === "focusnodes") {
      focusNodes = [];
      _ref = this.nodes;
      for (id in _ref) {
        a = _ref[id];
        if (a.initial) {
          focusNodes.push(a);
        }
      }
      focusNodes.sort(function(a, b) {
        return b.actionId - a.actionId;
      });
      cooldown = this.scene.settings.navigation.focusHistoryRelevanceCooldown;
      cold = 0;
      for (_i = 0, _len = focusNodes.length; _i < _len; _i++) {
        a = focusNodes[_i];
        id = a.id;
        r = a.relevance;
        if (r < 0) {
          r = 1 + parseFloat(this.scene.settings.navigation.focusNodeExpansionRadius);
        }
        r = Math.max(0, r - cold);
        cold += cooldown;
        expandedRelevances[id] = r;
        queue[id] = true;
      }
    } else if (mode === "manual") {
      _ref1 = this.nodes;
      for (id in _ref1) {
        a = _ref1[id];
        queue[id] = true;
        expandedRelevances[id] = 1.0;
      }
    } else {
      _ref2 = this.scene.data.getNodes();
      for (id in _ref2) {
        data = _ref2[id];
        queue[id] = true;
        expandedRelevances[id] = 1.01;
      }
    }
    while (Base_Helpers.hasProperties(queue)) {
      q1 = {};
      for (id in queue) {
        _ = queue[id];
        rel = expandedRelevances[id];
        a = this.nodes[id];
        if (a) {
          if (a.hidden) {
            delete expandedRelevances[id];
            continue;
          }
          if (a.expanded) {
            rel = 2;
          }
          expand = a.expanded || (rel > 1 && !a.collapsed) && !expandedNodes.hasOwnProperty(id);
        } else {
          expand = rel > 1;
        }
        if (!expand && autoExpandFilterFunc) {
          1;
        }
        if (expand && expandIncremental && !this.graph.idToNode.hasOwnProperty(id)) {
          expandUnfished = true;
          expand = false;
        }
        if (expand && !expandedNodes.hasOwnProperty(id)) {
          expandedNodes[id] = true;
          links = this.scene.data.getNodeLinks(id);
          if (links == null) {
            links = this.scene.data.getNodeCollectedLinks(id);
          }
          n1rel = rel - 1;
          for (_j = 0, _len1 = links.length; _j < _len1; _j++) {
            linkData = links[_j];
            n1 = this.otherEnd(linkData, id);
            if (!expandedRelevances.hasOwnProperty(n1) || n1rel > expandedRelevances[n1]) {
              expandedRelevances[n1] = n1rel;
              q1[n1] = true;
            }
          }
        }
      }
      queue = q1;
    }
    if (expandUnfished) {
      this.chart.events.notifySceneChanges({
        navigation: true
      });
    }
    return [expandedRelevances, expandedNodes];
  };

  Netchart_Navigator.prototype.applyRelevances = function(relevances, expanded) {
    var e, f, link, linkId, lr, maxRelevance, node, nodeId, nodeId1, rel, _ref, _ref1, _results;
    maxRelevance = 1;
    for (nodeId in relevances) {
      rel = relevances[nodeId];
      maxRelevance = Math.max(maxRelevance, rel);
      e = expanded.hasOwnProperty(nodeId);
      node = this.graph.addNode(nodeId);
      if (e) {
        this.graph.addNodeWithLinks(nodeId);
      }
      f = this.nodes[nodeId] && this.nodes[nodeId].initial;
      if (e !== node.expanded || f !== node.focused || node.relevance !== rel) {
        node.expanded = e;
        node.focused = f;
        node.relevance = rel;
        this.scene.touchNode(node);
      }
    }
    _ref = this.graph.idToNode;
    for (nodeId1 in _ref) {
      node = _ref[nodeId1];
      if (!relevances.hasOwnProperty(nodeId1)) {
        node.relevance = 0;
        this.graph.removeNode(nodeId1);
      }
    }
    _ref1 = this.graph.idToLink;
    _results = [];
    for (linkId in _ref1) {
      link = _ref1[linkId];
      _results.push(link.relevance = lr = Math.min(link.from.relevance, link.to.relevance));
    }
    return _results;
  };

  return Netchart_Navigator;

})();

/*
//@ sourceMappingURL=Navigator.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Export;

Base_Export = (function() {
  function Base_Export() {}

  Base_Export["export"] = function(api, v) {
    var a4, dh, doc, dpi, dw, h, mime, mime_map, o, out, p, pdf, ph, pw, s, scale, w;
    if (v.type === void 0) {
      v.type = "png";
    }
    if (v.transparent === void 0) {
      v.transparent = v.type === "png";
    }
    if (v.dimensions === void 0) {
      v.dimensions = {};
    }
    if (v.type === "png" || v.type === "jpeg") {
      mime_map = {
        "png": "image/png",
        "jpeg": "image/jpeg"
      };
      mime = mime_map[v.type];
      out = api.saveAsImage(v.type, v.dimensions, v.transparent);
      return this.proxyExport(api, mime, out, "base64", v.dimensions);
    } else if (v.type === "pdf") {
      s = [api._impl.scene.chartWidth, api._impl.scene.chartHeight];
      p = [10, 10, 10, 10];
      a4 = [];
      pw = ph = 0;
      dw = dh = 0;
      dpi = 72;
      scale = 1;
      w = h = 0;
      if (s[0] >= s[1]) {
        a4 = [297, 210];
        o = "l";
      } else {
        a4 = [210, 297];
        o = "p";
      }
      pw = a4[0] / 25.4 * dpi;
      ph = a4[1] / 25.4 * dpi;
      scale = Math.min(ph / s[1], pw / s[0]);
      if (o === "l") {
        w = s[0] * scale / pw * a4[0] - p[1] - p[3];
        dw = (a4[0] - w - p[1] - p[3]) / 2;
        h = s[1] / s[0] * w;
        dh = (a4[1] - p[0] - p[2] - h) / 2;
      } else {
        h = s[1] * scale / ph * a4[1] - p[0] - p[2];
        dh = (a4[1] - h - p[0] - p[2]) / 2;
        w = s[0] / s[1] * h;
        dw = (a4[0] - p[1] - p[3] - w) / 2;
      }
      out = api.saveAsImage("jpeg", {
        scaling: scale * 3
      }, v.transparent);
      out = out.slice('data:image/jpeg;base64,'.length);
      out = atob(out);
      doc = new jsPDF(o, "mm", "a4");
      doc.addImage(out, 'JPEG', p[3] + dw, p[0] + dh, w, h);
      pdf = doc.output('datauristring');
      return this.proxyExport(api, "application/pdf", pdf, "base64", {});
    } else {
      return api._impl.error("Unrecognized export type: " + v.type);
    }
  };

  Base_Export.proxyExport = function(api, type, data, encoding, dimensions) {
    var b, f, f1, f2, f3, f4;
    f = Base_Helpers.createDom("form");
    f.setAttribute("action", api._impl.settings.advanced.exportProxyURL);
    f.setAttribute("method", "POST");
    f.setAttribute("style", "display:none");
    f1 = Base_Helpers.createDom("input", null, null, f);
    f1.setAttribute("type", "hidden");
    f1.setAttribute("name", "type");
    f1.setAttribute("value", type);
    f2 = Base_Helpers.createDom("input", null, null, f);
    f2.setAttribute("type", "hidden");
    f2.setAttribute("name", "encoding");
    f2.setAttribute("value", encoding);
    f3 = Base_Helpers.createDom("input", null, null, f);
    f3.setAttribute("type", "hidden");
    f3.setAttribute("name", "data");
    f3.setAttribute("value", data);
    if (dimensions.dpi != null) {
      f4 = Base_Helpers.createDom("input", null, null, f);
      f4.setAttribute("type", "hidden");
      f4.setAttribute("name", "setdpi");
      f4.setAttribute("value", parseInt(dimensions.dpi));
    }
    b = document.getElementsByTagName("body")[0];
    b.appendChild(f);
    f.submit();
    return b.removeChild(f);
  };

  return Base_Export;

})();

/*
//@ sourceMappingURL=Export.map
*/

var Base_images_logo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHMAAAA0CAYAAAC5HgcyAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAACMBJREFUeNrsXGtsFFUUPrOzfdPC8rQkQFwiJKhEUxKIr/CjVRMTX0kJJBqUaIH6gOCPbTD6C0MbTAyS1LQhFDUqodEIGsBsxVp5CoWgxQJNl6UNbcFC6XvZ7e547uyZ9nY6uzuzXUp3nJOczs6dM2fu3O+ec8+5c3sFqRj0UxBZ0ryShuxAvjEsEQI4OsMBmxcuhBRJAmFEdjnybuSnkLtZgYDCQUiHRtgKPpiPJQFe99vIXmT3mKfaRICUVDBC0tolYFayH7+uT1BENFbMwR8p6raW6Wnkz5GXIQ8oYD7g94M4VtUV5C3I/SNFIVQ5FYFcgMgG1R3m4bA2dYXsAIOooumcwVc2L5iCEeGVcwFKHgN4bt4YC81GRiTgonwFm74pKwOKFy2CmykpsmXGsBesiATXpDXwr/gC1moIvYA/cvXs2KNutgLsfA+g46oxy4xZl+QlmxHh2jaA5w8BnOxgDTrqUi9yg4wKtlUgzQZblzwEralpkDrSeMx/voGco9WnhBQbzGqpAPh0HUBPJ1peSpQuiNUe7DMMpNnJFs9N/mAUm0a/+ssNO9Se6oNpmQhS6vAjXkSuQn6UztHOYRYPkCQggJdPAxzZC5CRNcoWST78VAEPaZkWeokAs21gFJgvI+9CDrcu4jF4yw+dVR5oLm+GgZYBEDNExErYh1efRT6LvAb5b+QLyAVyRRD0QPdQWOMtNP3QqGFyNfI15CfAZguPl3XfW+glAswNfwBcvzPsap9BXkfjpkz7vOFj5/FOaNzWCJ7dHvlUsAssIr2LXII8HTkXeZOYKUL3xW7wVtGNF2oBLiHmmTnK4PyPbNU2W6tskd+Vofl/aaGXCDB7MJrdUIeoBGW3+iH+dcppCSYo5ecBDni5ODUQgs66TmiubCZvKpt07bBXThd/723shaadTTDUT5Y5hA8ox4D3KhpvRjaLWs7hjUWQltUC+3YAHK4aFdCYOai5Z9EsjXFTkduxAfujKhYElpU8yIZY5BZWNvPJmeAsckLQF2R56Wpbim3Q1+GrbvykUUIgZ1NwZET3XZRtpbL/fTSr6+W53n+d/N4xvlyLkcpJdiCWLMm3k3ydDtlKku03apl66pKsbBRMZjEbw8UxFbPZnR0Oh0PSWRGW3hTr1I15CWxnRwvMERaMuCV0ZTfxfDYeWYMLMVzhHZSZlpubK7W3t8d8Dsoz95qrU3cvymQr91huNr4AyMgYKxlsPMO64w3gLDAtssC0yALTIgtMC0yLLDDv+2yURRMNpt78D7TWL1hkiOwT9aAV367wDvUNLVDbIgP7zFtnGOJ+C44kcbNSSOqJcKnHcrNWAGSRScC0rDhJwAzpkAla0GkHQGz5BlspUA+RljhPLMnrboWqi0EI+EZfyZgC0uuLRW6c1Uts7S37fOc1u2X+iHwGeROdq/m+RL/Yr2w66mNT/dbildRRT0F4dYKpLXMe/f4M+aMoeSJbLnJyktV/D/v+icfbUWSm05Gtx88yNZiSJCVtb8W6u/DgskZLKzUxn2UamG5TrMFqtUk8ZiYt8R3R6mSWm7UsM4ktuQgPbO1nmZZ1J4hYzl5I6VDNBASBE2KZk3HKjTVy6T1+hpOekZcsbnZIh4zPcnzJ4WbDH5KLMWFXz5KyLQZ2yYuYB63mTQ4whQTJ3Osx0sG5O08CVefTsYvGxkQQq6eDfkcaa9Xv4zF9NMtARGb/C8qm+dzEzRwIihz7x19JXc5RM11XGrlIpfMsyRSOs2M0ky5FL3umSwViqcb7uPEdnKaNZska3dSD2X+LVXM938UBA3S9gsCo0bAUJ8l0cQ3KaBWVKZGrZxzW6CZdJZyV56l0KnWspvooncBFgC7DqLbLjKlJETVGCZ+CMLDwpfN5K8TrlVhWSveUUKPyeoBrPMUNlnAdhL8eDymdo0DlrmtUlqsAuUol00U6WF3LzOhm8wmoMp3yZSrwFLem5Ir13PiopDeOBNTTQXWtiTHu5kfpNLyVglnBNJKsV2uAqQDGN6ACbB6NV6XkZscT8ICOukaT66Jy04JplDwEmpMLZIqoodTWUEBlDhqvmidgEuKeTxqYYz5orHUWEqh5nPtVW8J6CH/wXk/nk+abqm2iAArdDQkR5COUxl21+iipRqSxThm3Crl7q6M8Q7HaZapxzWg9QUdaUxNDLl/RFW+LiToSm1F7IPpv+W8L4ljcsKxXJR/WmpamW7dWI9GkOp+y5EH0+dJKLsKs1pludBkMePJU9ypjcL4O0Is0rrn4jhcvmOGN7YJwfowGcXi3SrYVDHR0dFTaRNuFwbbBg2L6aAzYrlz+2/6f6VQBNYxiIPCXvBMXb8D21D46maUHFATQxdIRAnZ/jKiRzye1Ikcn5YQuLl2o0LBiPurlU6GzxDwoJXTcz+nNpw5VyllmNZW7Ob0uklHG/LjBbMIGOre3AbYEBTghN3+aDHHLMS+sm54uVA4DDvCrFJKWth1o6/a1+z62Z9p72PZr9ix7IDgQ/KbtYNsPqIstr6xVZl3w/E/4bf9mdLWnISsHIDMb9ad74fzRN4WsnD3RLBNTknouHyulBqjg8zSy0khpiidC5OiEkS8ibgKgkO6JFPUqszXRXKi6rm4NK1xPz8mn57pJnt1fwCYM4gpL5C1KBOE1/Pk18qHls2H7/ByYAhKIfQHoOtwCr2L5B8hfoGwxyrI99dgyx8Vome/mPJJzBWWz0b36+jx96f5OP9svaAZ7eZS/hPJr8fde5J9g4dIymDE3G0IhEXx9XdBwgjXeZgjv1fe+ul4as0GKVdQrL6who3aFjhgu1smlJPVRXK0yyVDPWbwzindQ5KPN946Zmx3XCgvu5m00h8j4BFlWD50z15nNybJFyE10zUs9q4HO2deVV1S6t3O6j5PuXjo/ABpLJs28v0/CNnWKAiajl5h1IrNtEQfIAt9RghiV7BxyDZch/O97bLevr5Afj/AoBvARCG8OxXSzNbsbI4VdFpgS/CfAAOjmUutlIPngAAAAAElFTkSuQmCC";


// Generated by CoffeeScript 1.6.3
var Base_Geometry;

Base_Geometry = (function() {
  function Base_Geometry() {}

  Base_Geometry.closestPointToLine = function(x0, y0, x1, y1, x, y) {
    var dx, dy, lengthSqr, t;
    dx = x1 - x0;
    dy = y1 - y0;
    lengthSqr = dx * dx + dy * dy;
    if (lengthSqr > 0) {
      t = (((x - x0) * dx) + (y - y0) * dy) / lengthSqr;
      t = Math.min(Math.max(t, 0), 1);
    } else {
      t = 0;
    }
    return [x0 + dx * t, y0 + dy * t];
  };

  Base_Geometry.rayIntersectsLine = function(rx, ry, rdx, rdy, lx, ly, lx1, ly1) {
    var coef, div, ldx, ldy, tl, tr;
    coef = Infinity;
    ldx = lx1 - lx;
    ldy = ly1 - ly;
    div = rdx * ldy - rdy * ldx;
    if (div !== 0) {
      tr = (ry * ldx - rx * ldy + lx * ldy - ly * ldx) / div;
      if (Math.abs(ldx) > Math.abs(ldy)) {
        tl = (rx + rdx * tr - lx) / ldx;
      } else {
        tl = (ry + rdy * tr - ly) / ldy;
      }
      if (tl >= 0 && tl <= 1 && tr >= 0) {
        coef = tr;
      }
    }
    return coef;
  };

  Base_Geometry.rayIntersectsCircle = function(rx, ry, rdx, rdy, r) {
    var a, b, c, coef, d, t0, t1;
    a = rdx * rdx + rdy * rdy;
    b = rx * rdx + ry * rdy;
    c = rx * rx + ry * ry - r * r;
    d = b * b - a * c;
    coef = Infinity;
    if (d > 0) {
      d = Math.sqrt(d);
      t0 = (-b - d) / a;
      t1 = (-b + d) / a;
      if (t0 >= 0) {
        coef = t0;
      }
      if (t1 >= 0) {
        coef = Math.min(coef, t1);
      }
    }
    return coef;
  };

  Base_Geometry.rayIntersectsCircleOuter = function(rx, ry, rdx, rdy, r) {
    var a, b, c, d;
    a = rdx * rdx + rdy * rdy;
    b = rx * rdx + ry * rdy;
    c = rx * rx + ry * ry - r * r;
    d = b * b - a * c;
    d = Math.sqrt(d);
    return Math.max((-b + d) / a, (-b - d) / a);
  };

  Base_Geometry.lineTouchingCircle = function(rx, ry, xt, yt, r) {
    var a, angle, b, dx, dy, h, xx;
    a = Math.sqrt(rx * rx + ry * ry);
    if (!(a > r)) {
      return null;
    }
    b = Math.sqrt(a * a - r * r);
    h = r * b / a;
    xx = r * r / a;
    dx = rx / a;
    dy = ry / a;
    angle = rx * yt - ry * xt;
    if (angle < 0) {
      h = -h;
    }
    return [dx * xx - dy * h, dy * xx + dx * h];
  };

  return Base_Geometry;

})();

/*
//@ sourceMappingURL=Geometry.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Random;

Base_Random = (function() {
  function Base_Random(seed) {
    this.seed = seed;
    this.A = 48271;
    this.M = 2147483647;
    this.Q = this.M / this.A;
    this.R = this.M % this.A;
    this.oneOverM = 1.0 / this.M;
  }

  Base_Random.prototype.get = function() {
    var hi, lo, test;
    hi = this.seed / this.Q;
    lo = this.seed % this.Q;
    test = this.A * lo - this.R * hi;
    if (test > 0) {
      this.seed = test;
    } else {
      this.seed = test + this.M;
    }
    return this.seed * this.oneOverM;
  };

  return Base_Random;

})();

/*
//@ sourceMappingURL=Random.map
*/

// Generated by CoffeeScript 1.6.3
var Base_CssColorParser;

Base_CssColorParser = (function() {
  function Base_CssColorParser() {}

  Base_CssColorParser.clamp_css_byte = function(i) {
    i = Math.round(i);
    if (i < 0) {
      return 0;
    } else {
      if (i > 255) {
        return 255;
      } else {
        return i;
      }
    }
  };

  Base_CssColorParser.clamp_css_float = function(f) {
    if (f < 0) {
      return 0;
    } else {
      if (f > 1) {
        return 1;
      } else {
        return f;
      }
    }
  };

  Base_CssColorParser.parse_css_int = function(str) {
    if (str[str.length - 1] === "%") {
      return Base_CssColorParser.clamp_css_byte(parseFloat(str) / 100 * 255);
    }
    return Base_CssColorParser.clamp_css_byte(parseInt(str));
  };

  Base_CssColorParser.parse_css_float = function(str) {
    if (str[str.length - 1] === "%") {
      return Base_CssColorParser.clamp_css_float(parseFloat(str) / 100);
    }
    return Base_CssColorParser.clamp_css_float(parseFloat(str));
  };

  Base_CssColorParser.css_hue_to_rgb = function(m1, m2, h) {
    if (h < 0) {
      h += 1;
    } else {
      if (h > 1) {
        h -= 1;
      }
    }
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6;
    }
    if (h * 2 < 1) {
      return m2;
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6;
    }
    return m1;
  };

  Base_CssColorParser.parseCSSColor = function(css_str) {
    var alpha, ep, fname, h, iv, l, m1, m2, op, params, s, str;
    str = css_str.replace(RegExp(" ", "g"), "").toLowerCase();
    if (str in Base_CssColorParser.kCSSColorTable) {
      return Base_CssColorParser.kCSSColorTable[str].slice();
    }
    if (str[0] === "#") {
      if (str.length === 4) {
        iv = parseInt(str.substr(1), 16);
        if (!(iv >= 0 && iv <= 0xfff)) {
          return null;
        }
        return [((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), 1];
      } else if (str.length === 7) {
        iv = parseInt(str.substr(1), 16);
        if (!(iv >= 0 && iv < 0xffffff)) {
          return null;
        }
        return [(iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, 1];
      }
      return null;
    }
    op = str.indexOf("(");
    ep = str.indexOf(")");
    if (op !== -1 && ep + 1 === str.length) {
      fname = str.substr(0, op);
      params = str.substr(op + 1, ep - (op + 1)).split(",");
      alpha = 1;
      if (fname === "rgba") {
        if (params.length !== 4) {
          return null;
        }
        alpha = Base_CssColorParser.parse_css_float(params.pop());
      }
      if (fname === "rgba" || fname === "rgb") {
        if (params.length !== 3) {
          return null;
        }
        return [Base_CssColorParser.parse_css_int(params[0]), Base_CssColorParser.parse_css_int(params[1]), Base_CssColorParser.parse_css_int(params[2]), alpha];
      }
      if (fname === "hsla") {
        if (params.length !== 4) {
          return null;
        }
        alpha = Base_CssColorParser.parse_css_float(params.pop());
      }
      if (fname === "hsla" || fname === "hsl") {
        if (params.length !== 3) {
          return null;
        }
        h = (((parseFloat(params[0]) % 360) + 360) % 360) / 360;
        s = parse_css_float(params[1]);
        l = parse_css_float(params[2]);
        m2 = (l <= 0.5 ? l * (s + 1) : l + s - l * s);
        m1 = l * 2 - m2;
        return [Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h + 1 / 3) * 255), Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h) * 255), Base_CssColorParser.clamp_css_byte(Base_CssColorParser.css_hue_to_rgb(m1, m2, h - 1 / 3) * 255), alpha];
      }
    }
    return null;
  };

  Base_CssColorParser.kCSSColorTable = {
    transparent: [0, 0, 0, 0],
    aliceblue: [240, 248, 255, 1],
    antiquewhite: [250, 235, 215, 1],
    aqua: [0, 255, 255, 1],
    aquamarine: [127, 255, 212, 1],
    azure: [240, 255, 255, 1],
    beige: [245, 245, 220, 1],
    bisque: [255, 228, 196, 1],
    black: [0, 0, 0, 1],
    blanchedalmond: [255, 235, 205, 1],
    blue: [0, 0, 255, 1],
    blueviolet: [138, 43, 226, 1],
    brown: [165, 42, 42, 1],
    burlywood: [222, 184, 135, 1],
    cadetblue: [95, 158, 160, 1],
    chartreuse: [127, 255, 0, 1],
    chocolate: [210, 105, 30, 1],
    coral: [255, 127, 80, 1],
    cornflowerblue: [100, 149, 237, 1],
    cornsilk: [255, 248, 220, 1],
    crimson: [220, 20, 60, 1],
    cyan: [0, 255, 255, 1],
    darkblue: [0, 0, 139, 1],
    darkcyan: [0, 139, 139, 1],
    darkgoldenrod: [184, 134, 11, 1],
    darkgray: [169, 169, 169, 1],
    darkgreen: [0, 100, 0, 1],
    darkgrey: [169, 169, 169, 1],
    darkkhaki: [189, 183, 107, 1],
    darkmagenta: [139, 0, 139, 1],
    darkolivegreen: [85, 107, 47, 1],
    darkorange: [255, 140, 0, 1],
    darkorchid: [153, 50, 204, 1],
    darkred: [139, 0, 0, 1],
    darksalmon: [233, 150, 122, 1],
    darkseagreen: [143, 188, 143, 1],
    darkslateblue: [72, 61, 139, 1],
    darkslategray: [47, 79, 79, 1],
    darkslategrey: [47, 79, 79, 1],
    darkturquoise: [0, 206, 209, 1],
    darkviolet: [148, 0, 211, 1],
    deeppink: [255, 20, 147, 1],
    deepskyblue: [0, 191, 255, 1],
    dimgray: [105, 105, 105, 1],
    dimgrey: [105, 105, 105, 1],
    dodgerblue: [30, 144, 255, 1],
    firebrick: [178, 34, 34, 1],
    floralwhite: [255, 250, 240, 1],
    forestgreen: [34, 139, 34, 1],
    fuchsia: [255, 0, 255, 1],
    gainsboro: [220, 220, 220, 1],
    ghostwhite: [248, 248, 255, 1],
    gold: [255, 215, 0, 1],
    goldenrod: [218, 165, 32, 1],
    gray: [128, 128, 128, 1],
    green: [0, 128, 0, 1],
    greenyellow: [173, 255, 47, 1],
    grey: [128, 128, 128, 1],
    honeydew: [240, 255, 240, 1],
    hotpink: [255, 105, 180, 1],
    indianred: [205, 92, 92, 1],
    indigo: [75, 0, 130, 1],
    ivory: [255, 255, 240, 1],
    khaki: [240, 230, 140, 1],
    lavender: [230, 230, 250, 1],
    lavenderblush: [255, 240, 245, 1],
    lawngreen: [124, 252, 0, 1],
    lemonchiffon: [255, 250, 205, 1],
    lightblue: [173, 216, 230, 1],
    lightcoral: [240, 128, 128, 1],
    lightcyan: [224, 255, 255, 1],
    lightgoldenrodyellow: [250, 250, 210, 1],
    lightgray: [211, 211, 211, 1],
    lightgreen: [144, 238, 144, 1],
    lightgrey: [211, 211, 211, 1],
    lightpink: [255, 182, 193, 1],
    lightsalmon: [255, 160, 122, 1],
    lightseagreen: [32, 178, 170, 1],
    lightskyblue: [135, 206, 250, 1],
    lightslategray: [119, 136, 153, 1],
    lightslategrey: [119, 136, 153, 1],
    lightsteelblue: [176, 196, 222, 1],
    lightyellow: [255, 255, 224, 1],
    lime: [0, 255, 0, 1],
    limegreen: [50, 205, 50, 1],
    linen: [250, 240, 230, 1],
    magenta: [255, 0, 255, 1],
    maroon: [128, 0, 0, 1],
    mediumaquamarine: [102, 205, 170, 1],
    mediumblue: [0, 0, 205, 1],
    mediumorchid: [186, 85, 211, 1],
    mediumpurple: [147, 112, 219, 1],
    mediumseagreen: [60, 179, 113, 1],
    mediumslateblue: [123, 104, 238, 1],
    mediumspringgreen: [0, 250, 154, 1],
    mediumturquoise: [72, 209, 204, 1],
    mediumvioletred: [199, 21, 133, 1],
    midnightblue: [25, 25, 112, 1],
    mintcream: [245, 255, 250, 1],
    mistyrose: [255, 228, 225, 1],
    moccasin: [255, 228, 181, 1],
    navajowhite: [255, 222, 173, 1],
    navy: [0, 0, 128, 1],
    oldlace: [253, 245, 230, 1],
    olive: [128, 128, 0, 1],
    olivedrab: [107, 142, 35, 1],
    orange: [255, 165, 0, 1],
    orangered: [255, 69, 0, 1],
    orchid: [218, 112, 214, 1],
    palegoldenrod: [238, 232, 170, 1],
    palegreen: [152, 251, 152, 1],
    paleturquoise: [175, 238, 238, 1],
    palevioletred: [219, 112, 147, 1],
    papayawhip: [255, 239, 213, 1],
    peachpuff: [255, 218, 185, 1],
    peru: [205, 133, 63, 1],
    pink: [255, 192, 203, 1],
    plum: [221, 160, 221, 1],
    powderblue: [176, 224, 230, 1],
    purple: [128, 0, 128, 1],
    red: [255, 0, 0, 1],
    rosybrown: [188, 143, 143, 1],
    royalblue: [65, 105, 225, 1],
    saddlebrown: [139, 69, 19, 1],
    salmon: [250, 128, 114, 1],
    sandybrown: [244, 164, 96, 1],
    seagreen: [46, 139, 87, 1],
    seashell: [255, 245, 238, 1],
    sienna: [160, 82, 45, 1],
    silver: [192, 192, 192, 1],
    skyblue: [135, 206, 235, 1],
    slateblue: [106, 90, 205, 1],
    slategray: [112, 128, 144, 1],
    slategrey: [112, 128, 144, 1],
    snow: [255, 250, 250, 1],
    springgreen: [0, 255, 127, 1],
    steelblue: [70, 130, 180, 1],
    tan: [210, 180, 140, 1],
    teal: [0, 128, 128, 1],
    thistle: [216, 191, 216, 1],
    tomato: [255, 99, 71, 1],
    turquoise: [64, 224, 208, 1],
    violet: [238, 130, 238, 1],
    wheat: [245, 222, 179, 1],
    white: [255, 255, 255, 1],
    whitesmoke: [245, 245, 245, 1],
    yellow: [255, 255, 0, 1],
    yellowgreen: [154, 205, 50, 1]
  };

  return Base_CssColorParser;

})();

/*
//@ sourceMappingURL=CssColorParser.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Layout_BHTree;

Netchart_Layout_BHTree = (function() {
  var RepulsiveTreeNode, swap;

  RepulsiveTreeNode = (function() {
    function RepulsiveTreeNode() {}

    RepulsiveTreeNode.prototype.forceLinkList = null;

    RepulsiveTreeNode.prototype.x = 0;

    RepulsiveTreeNode.prototype.y = 0;

    RepulsiveTreeNode.prototype.r = 0;

    RepulsiveTreeNode.prototype.fx = 0;

    RepulsiveTreeNode.prototype.fy = 0;

    RepulsiveTreeNode.prototype.sizeEstimate = 0;

    RepulsiveTreeNode.prototype.left = null;

    RepulsiveTreeNode.prototype.right = null;

    RepulsiveTreeNode.prototype.nodes = null;

    return RepulsiveTreeNode;

  })();

  Netchart_Layout_BHTree.prototype.maxLeafCount = 5;

  Netchart_Layout_BHTree.test = function() {
    var base, nodes, t;
    t = new Netchart_Layout_BHTree();
    t.maxLeafCount = 2;
    t.temperature = 1;
    nodes = [];
    base = {
      z: 0,
      dx: 0,
      dy: 0,
      dz: 0,
      repulsiveForceX: 0,
      repulsiveForceY: 0,
      repulsiveForceZ: 0,
      fsum: 0
    };
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 10,
      y: 10
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 0,
      y: 0
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 0,
      y: 10
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 10,
      y: 0
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 10,
      y: 10
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 20,
      y: 0
    }, base));
    nodes.push(Base_Helpers.extend({
      r: 5,
      x: 25,
      y: 0
    }, base));
    return t.buildTree(nodes, nodes.length);
  };

  function Netchart_Layout_BHTree() {
    this.root = null;
    this.freeNodeRoot = null;
    this.temperature = 0;
    this.nodeCount = 0;
  }

  Netchart_Layout_BHTree.prototype.buildTree = function(nodeArray) {
    var count, i, _i, _ref;
    this.iters = 0;
    count = nodeArray.length;
    if (this.root != null) {
      this.freeNode(this.root);
    }
    this.root = this.newNode();
    if (count > 0) {
      this.buildTreeRecursive(nodeArray, 0, count, this.root);
    }
    for (i = _i = 0, _ref = count - 1; _i <= _ref; i = _i += 1) {
      nodeArray[i].repulsiveForceX = 0;
      nodeArray[i].repulsiveForceY = 0;
      nodeArray[i].repulsiveForceZ = 0;
    }
    return this.calculateForces();
  };

  Netchart_Layout_BHTree.prototype.freeNode = function(node) {
    if (node.left != null) {
      this.freeNode(node.left);
    }
    if (node.right != null) {
      this.freeNode(node.right);
    }
    node.left = this.freeNodeRoot;
    return this.freeNodeRoot = node;
  };

  Netchart_Layout_BHTree.prototype.newNode = function() {
    var node;
    if (this.freeNodeRoot != null) {
      node = this.freeNodeRoot;
      this.freeNodeRoot = node.left;
      node.left = null;
      node.right = null;
      node.leafCount = 0;
      node.sizeEstimate = 0;
      node.forceLinkList.length = 0;
    } else {
      node = new RepulsiveTreeNode();
      node.forceLinkList = [];
      node.leaves = new Array(this.maxLeafCount);
    }
    node.repulsiveForceX = 0;
    node.repulsiveForceY = 0;
    node.repulsiveForceZ = 0;
    return node;
  };

  swap = function(arr, a, b) {
    var p;
    p = arr[a];
    arr[a] = arr[b];
    return arr[b] = p;
  };

  Netchart_Layout_BHTree.prototype.addForceLink = function(source, target) {
    return source.forceLinkList.push(target);
  };

  Netchart_Layout_BHTree.prototype.getMedianX = function(arr, low, high) {
    var hh, ll, median, middle, tmp;
    high -= 1;
    median = ((low + high) / 2) | 0;
    while (true) {
      if (high <= low) {
        return median;
      }
      if (high === low + 1) {
        if (arr[low].x > arr[high].x) {
          swap(arr, low, high);
          return median;
        }
      }
      middle = ((low + high) / 2) | 0;
      if (arr[middle].x > arr[high].x) {
        swap(arr, middle, high);
      }
      if (arr[low].x > arr[high].x) {
        swap(arr, low, high);
      }
      if (arr[middle].x > arr[low].x) {
        swap(arr, middle, low);
      }
      swap(arr, middle, low + 1);
      ll = low + 1;
      hh = high;
      while (true) {
        while (true) {
          ll += 1;
          if (!(arr[low].x > arr[ll].x)) {
            break;
          }
        }
        while (true) {
          hh -= 1;
          if (!(arr[hh].x > arr[low].x)) {
            break;
          }
        }
        if (hh < ll) {
          break;
        }
        tmp = arr[ll];
        arr[ll] = arr[hh];
        arr[hh] = tmp;
      }
      swap(arr, low, hh);
      if (hh <= median) {
        low = ll;
      }
      if (hh >= median) {
        high = hh - 1;
      }
    }
  };

  Netchart_Layout_BHTree.prototype.getMedianY = function(arr, low, high) {
    var hh, ll, median, middle, tmp;
    high -= 1;
    median = ((low + high) / 2) | 0;
    while (true) {
      if (high <= low) {
        return median;
      }
      if (high === low + 1) {
        if (arr[low].y > arr[high].y) {
          swap(arr, low, high);
        }
        return median;
      }
      middle = ((low + high) / 2) | 0;
      if (arr[middle].y > arr[high].y) {
        swap(arr, middle, high);
      }
      if (arr[low].y > arr[high].y) {
        swap(arr, low, high);
      }
      if (arr[middle].y > arr[low].y) {
        swap(arr, middle, low);
      }
      swap(arr, middle, low + 1);
      ll = low + 1;
      hh = high;
      while (true) {
        while (true) {
          ll += 1;
          if (!(arr[low].y > arr[ll].y)) {
            break;
          }
        }
        while (true) {
          hh -= 1;
          if (!(arr[hh].y > arr[low].y)) {
            break;
          }
        }
        if (hh < ll) {
          break;
        }
        tmp = arr[ll];
        arr[ll] = arr[hh];
        arr[hh] = tmp;
      }
      swap(arr, low, hh);
      if (hh <= median) {
        low = ll;
      }
      if (hh >= median) {
        high = hh - 1;
      }
    }
  };

  Netchart_Layout_BHTree.prototype.buildTreeRecursive = function(nodeArray, start, end, subtree) {
    var child, count, i, invcnt, median, node, p, r, x, x1, x2, y, y1, y2, z, _i, _j, _ref, _ref1, _ref2;
    x1 = x2 = nodeArray[start].x;
    y1 = y2 = nodeArray[start].y;
    for (i = _i = _ref = start + 1, _ref1 = end - 1; _i <= _ref1; i = _i += 1) {
      p = nodeArray[i];
      x = p.x;
      y = p.y;
      if (x < x1) {
        x1 = x;
      }
      if (x > x2) {
        x2 = x;
      }
      if (y < y1) {
        y1 = y;
      }
      if (y > y2) {
        y2 = y;
      }
    }
    subtree.sizeEstimate = Math.max(x2 - x1, y2 - y1);
    subtree.sizeEstimate = subtree.sizeEstimate * subtree.sizeEstimate + 0.1;
    subtree.sizeEstimate *= 2;
    count = end - start;
    if (count <= this.maxLeafCount) {
      subtree.leafCount = count;
      x = 0;
      y = 0;
      z = 0;
      r = 0;
      for (i = _j = 0, _ref2 = count - 1; _j <= _ref2; i = _j += 1) {
        node = nodeArray[i + start];
        x += node.x;
        y += node.y;
        z += node.z;
        r += node.r;
        subtree.leaves[i] = node;
      }
      invcnt = 1.0 / count;
      subtree.r = r;
      subtree.x = x * invcnt;
      subtree.y = y * invcnt;
      subtree.z = z * invcnt;
      return;
    }
    if (x2 - x1 > y2 - y1) {
      median = this.getMedianX(nodeArray, start, end);
    } else {
      median = this.getMedianY(nodeArray, start, end);
    }
    median++;
    child = this.newNode();
    subtree.left = child;
    this.buildTreeRecursive(nodeArray, start, median, child);
    child = this.newNode();
    subtree.right = child;
    this.buildTreeRecursive(nodeArray, median, end, child);
    invcnt = 1.0 / count;
    subtree.r = subtree.right.r + subtree.left.r;
    subtree.x = (subtree.left.x * (median - start) + subtree.right.x * (end - median)) * invcnt;
    subtree.y = (subtree.left.y * (median - start) + subtree.right.y * (end - median)) * invcnt;
    return subtree.z = (subtree.left.z * (median - start) + subtree.right.z * (end - median)) * invcnt;
  };

  Netchart_Layout_BHTree.prototype.calculateForces = function() {
    var factor, forceX, forceY, i, invr, k, node, node1, node2, queue, queueEnd, queueStart, _i, _j, _ref, _ref1, _ref2, _results;
    queue = new Array(this.nodeCount);
    queueStart = 0;
    queueEnd = 0;
    if (this.root.left !== null) {
      queue[queueEnd] = this.root.left;
      queueEnd++;
      queue[queueEnd] = this.root.right;
      queueEnd++;
      this.addForceLink(this.root.left, this.root.right);
    } else {
      queue[queueEnd] = this.root;
      queueEnd++;
    }
    _results = [];
    while (queueStart < queueEnd) {
      node = queue[queueStart];
      queueStart++;
      invr = 1.0 / node.r;
      if (node.left !== null) {
        this.processTreeNode(node, node.left);
        this.processTreeNode(node, node.right);
        queue[queueEnd] = node.left;
        queueEnd++;
        queue[queueEnd] = node.right;
        queueEnd++;
        factor = node.left.r * invr;
        forceX = node.repulsiveForceX * factor;
        forceY = node.repulsiveForceY * factor;
        node.left.repulsiveForceX += forceX;
        node.left.repulsiveForceY += forceY;
        node.right.repulsiveForceX += node.repulsiveForceX - forceX;
        node.right.repulsiveForceY += node.repulsiveForceY - forceY;
        this.addForceLink(node.left, node.right);
      } else {
        for (i = _i = 0, _ref = node.leafCount - 1; _i <= _ref; i = _i += 1) {
          node1 = node.leaves[i];
          this.processLeafNode(node, node1);
          factor = node1.r * invr;
          node1.repulsiveForceX += node.repulsiveForceX * factor;
          node1.repulsiveForceY += node.repulsiveForceY * factor;
          for (k = _j = _ref1 = i + 1, _ref2 = node.leafCount - 1; _j <= _ref2; k = _j += 1) {
            node2 = node.leaves[k];
            this.forceBetweenParticles(node1, node2);
          }
        }
      }
      _results.push(node.forceLinkList.length = 0);
    }
    return _results;
  };

  Netchart_Layout_BHTree.prototype.processTreeNode = function(node, subtree) {
    var fx, fy, i, len, length, otherNode, threshold, vx, vy, w, _i, _ref, _results;
    length = node.forceLinkList.length;
    _results = [];
    for (i = _i = 0, _ref = length - 1; _i <= _ref; i = _i += 1) {
      otherNode = node.forceLinkList[i];
      vx = subtree.x - otherNode.x;
      vy = subtree.y - otherNode.y;
      len = vx * vx + vy * vy;
      threshold = subtree.sizeEstimate;
      if (otherNode instanceof RepulsiveTreeNode) {
        threshold += otherNode.sizeEstimate;
      }
      if (threshold < len) {
        w = subtree.r * otherNode.r / (len * Math.sqrt(len));
        fx = vx * w;
        subtree.repulsiveForceX += fx;
        otherNode.repulsiveForceX -= fx;
        fy = vy * w;
        subtree.repulsiveForceY += fy;
        _results.push(otherNode.repulsiveForceY -= fy);
      } else {
        if (otherNode instanceof RepulsiveTreeNode) {
          _results.push(this.addForceLink(otherNode, subtree));
        } else {
          _results.push(this.addForceLink(subtree, otherNode));
        }
      }
    }
    return _results;
  };

  Netchart_Layout_BHTree.prototype.processLeafNode = function(node, subtree) {
    var fx, fy, len, otherNode, threshold, vx, vy, w, _i, _len, _ref, _results;
    _ref = node.forceLinkList;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      otherNode = _ref[_i];
      if (!(otherNode instanceof RepulsiveTreeNode)) {
        _results.push(this.forceBetweenParticles(subtree, otherNode));
      } else {
        vx = subtree.x - otherNode.x;
        vy = subtree.y - otherNode.y;
        len = vx * vx + vy * vy;
        threshold = otherNode.sizeEstimate;
        if (threshold < len) {
          w = subtree.r * otherNode.r / (len * Math.sqrt(len));
          fx = vx * w;
          subtree.repulsiveForceX += fx;
          otherNode.repulsiveForceX -= fx;
          fy = vy * w;
          subtree.repulsiveForceY += fy;
          _results.push(otherNode.repulsiveForceY -= fy);
        } else {
          _results.push(this.addForceLink(otherNode, subtree));
        }
      }
    }
    return _results;
  };

  Netchart_Layout_BHTree.prototype.forceBetweenParticles = function(node1, node2) {
    var len1, r, vx1, vy1, vz1, w;
    vx1 = node1.x - node2.x;
    vy1 = node1.y - node2.y;
    vz1 = node1.z - node2.z;
    len1 = vx1 * vx1 + vy1 * vy1 + vz1 * vz1;
    r = node1.r + node2.r;
    if (len1 * this.temperature < r) {
      w = 0.25 * this.temperature * Math.sqrt(this.temperature * r);
    } else {
      w = 0.25 * r * r / (len1 * Math.sqrt(len1));
    }
    node1.repulsiveForceX += vx1 * w;
    node2.repulsiveForceX -= vx1 * w;
    node1.repulsiveForceY += vy1 * w;
    node2.repulsiveForceY -= vy1 * w;
    node1.repulsiveForceZ += vz1 * w;
    return node2.repulsiveForceZ -= vz1 * w;
  };

  return Netchart_Layout_BHTree;

})();

/*
//@ sourceMappingURL=BHTree.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Layout_GraphAdjacency;

Netchart_Layout_GraphAdjacency = (function() {
  function Netchart_Layout_GraphAdjacency(nodes, edges) {
    var i, _i, _ref;
    this.edgecnt = 0;
    this.nodecnt = nodes;
    this.maxedges = edges;
    this.increment = edges + 1;
    this.nodestart = new Array(nodes);
    this.enodes = new Array(edges);
    this.next = new Array(edges);
    for (i = _i = 0, _ref = this.nodecnt - 1; _i <= _ref; i = _i += 1) {
      this.nodestart[i] = -1;
    }
  }

  Netchart_Layout_GraphAdjacency.prototype.addEdge = function(snode, enode) {
    if (this.edgecnt >= this.maxedges) {
      this.maxedges += this.increment;
      this.increment *= 2;
      this.next.length = this.maxedges;
      this.enodes.length = this.maxedges;
    }
    this.enodes[this.edgecnt] = enode;
    this.next[this.edgecnt] = this.nodestart[snode];
    this.nodestart[snode] = this.edgecnt;
    return this.edgecnt++;
  };

  Netchart_Layout_GraphAdjacency.prototype.addUndirectEdge = function(snode, enode) {
    this.addEdge(snode, enode);
    return this.addEdge(enode, snode);
  };

  return Netchart_Layout_GraphAdjacency;

})();

/*
//@ sourceMappingURL=GraphAdjacency.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Api;

Base_Api = (function() {
  function Base_Api() {}

  Base_Api.themes = {};

  Base_Api.prototype.customize = function(name) {
    /*
      Applies one of predefined customizations from @themes
    */

    if (!this.themes.hasOwnProperty(name)) {
      throw "No customization named " + name;
    }
    return this.updateSettings(this.themes[name]);
  };

  Base_Api.prototype.saveState = function() {
    return this._impl.save();
  };

  Base_Api.prototype.restoreState = function(state, animate) {
    if (animate == null) {
      animate = false;
    }
    return this._impl.restore(state, animate);
  };

  Base_Api.prototype.updateSettings = function(changes) {
    if (changes == null) {
      changes = {};
    }
    /*
      Change settings, can pass the same settings as in constructor.
      Only pass the settings you need changed.
    */

    this._impl.updateSettings(changes, "api");
    return this;
  };

  Base_Api.prototype.on = function(name, listener) {
    /*
     Adds event listener.
     Supported event types: "timeChange", "selectionChange, "click", "doubleClick".
     Consult doc for event types in specific SDK
    */

    return this._impl.on(name, listener);
  };

  Base_Api.prototype.off = function(name, listener) {
    return this._impl.off(name, listener);
  };

  Base_Api.prototype.updateSize = function() {
    /*
      Call when the container size has been changed to update the chart.
    */

    this._impl.updateSize(true);
    return this;
  };

  Base_Api.prototype.reloadData = function() {
    /*
      Clears data cache and loads new data. The time range is preserved.
    */

    return this._impl.reloadData();
  };

  Base_Api.prototype.remove = function() {
    /*
      Removes chart from DOM. Is automatically called when you create a new Chart with the same container.
    */

    return this._impl.remove();
  };

  Base_Api.prototype.saveAsImage = function(type, dimensions, transparent) {
    /*
    # returns data uri string
    # supported types:
    #   png|jpeg
    # dimensions is object, that supports:
    #   dpi: int
    #   unit: mm|px
    #   width:
    #   height:
    #   scaling
    */

    return this._impl.events.exportToImage(type, dimensions, transparent);
  };

  Base_Api.prototype["export"] = function(type, dimensions, transparent) {
    return Base_Export["export"](this, {
      type: type,
      dimensions: dimensions,
      transparent: transparent
    });
  };

  Base_Api.prototype.exportGetDimensions = function(dimensions) {
    return this._impl.events.exportGetDimensions(dimensions);
  };

  return Base_Api;

})();

// Generated by CoffeeScript 1.6.3
var Base_Graphics;

Base_Graphics = (function() {
  "use strict";
  function Base_Graphics() {}

  Base_Graphics.stroke = function(g, st) {
    if (st.lineWidth) {
      g.lineWidth = st.lineWidth;
    }
    g.strokeStyle = st.lineColor;
    g.stroke();
    if (st.lineWidth) {
      return g.lineWidth = 1;
    }
  };

  Base_Graphics.fill = function(g, st) {
    if (!st.fillColor) {
      return;
    }
    g.fillStyle = st.fillColor;
    if (st["shadowColor"]) {
      g.shadowOffsetX = st.shadowOffsetX;
      g.shadowOffsetY = st.shadowOffsetY;
      g.shadowBlur = st.shadowBlur;
      g.shadowColor = st.shadowColor;
    }
    g.fill();
    if (st["shadowColor"]) {
      g.shadowBlur = 0;
      return g.shadowColor = null;
    }
  };

  Base_Graphics.paint = function(g, st) {
    if (st.shadowColor) {
      g.shadowOffsetX = st.shadowOffsetX;
      g.shadowOffsetY = st.shadowOffsetY;
      g.shadowBlur = st.shadowBlur;
      g.shadowColor = st.shadowColor;
    }
    if (st.lineColor) {
      g.lineWidth = st.lineWidth ? st.lineWidth : 1;
      g.strokeStyle = st.lineColor;
      g.stroke();
    }
    if (st.fillColor) {
      g.fillStyle = st.fillColor;
      g.fill();
    }
    if (st.shadowColor) {
      g.shadowOffsetX = 0;
      g.shadowOffsetY = 0;
      g.shadowBlur = 0;
      return g.shadowColor = null;
    }
  };

  Base_Graphics.textStyle = function(g, st) {
    if (st.fillColor) {
      g.fillStyle = st.fillColor;
    }
    if (st.font) {
      g.font = st.font;
    }
    if (st["shadowColor"]) {
      g.shadowOffsetX = st.shadowOffsetX;
      g.shadowOffsetY = st.shadowOffsetY;
      g.shadowBlur = st.shadowBlur;
      return g.shadowColor = st.shadowColor;
    }
  };

  Base_Graphics.rectStyle = function(g, st) {
    if (st.hasOwnProperty("lineColor")) {
      g.strokeStyle = st.lineColor;
    }
    if (st.hasOwnProperty("fillColor")) {
      return g.fillStyle = st.fillColor;
    }
  };

  Base_Graphics.pushClip = function(g, x, y, w, h) {
    g.save();
    g.beginPath();
    g.rect(x, y, w, h);
    return g.clip();
  };

  Base_Graphics.popClip = function(g) {
    return g.restore();
  };

  Base_Graphics.arcBetweenTwoPoints = function(g, x, y, r, x0, y0, x1, y1) {
    var a1, a2, counterclockwise, d, d1, d2, len, lenSq, mx, my, px, py, xa, xb, ya, yb;
    mx = (x0 + x1) / 2;
    my = (y0 + y1) / 2;
    px = y1 - y0;
    py = x0 - x1;
    lenSq = px * px + py * py;
    if (lenSq === 0) {
      return;
    }
    len = Math.sqrt(lenSq);
    r = Math.min(Math.max(r, len / 2), len * 3);
    d = Math.sqrt(r * r / lenSq - 0.25);
    xa = mx + px * d;
    ya = my + py * d;
    xb = mx - px * d;
    yb = my - py * d;
    d1 = (xa - x) * (xa - x) + (ya - y) * (ya - y);
    d2 = (xb - x) * (xb - x) + (yb - y) * (yb - y);
    if (d1 > d2) {
      x = xb;
      y = yb;
    } else {
      x = xa;
      y = ya;
    }
    a1 = Math.atan2(y0 - y, x0 - x);
    a2 = Math.atan2(y1 - y, x1 - x);
    if (a2 < a1) {
      a2 += Math.PI * 2;
    }
    counterclockwise = Math.abs(a1 - a2) > Math.PI;
    return g.arc(x, y, r, a1, a2, counterclockwise);
  };

  Base_Graphics.strokeMarker = function(g, shape, x, y, r) {
    var d2;
    d2 = r * 1.41421356237;
    if (shape === "rect") {
      g.moveTo(x - r, y - r);
      g.lineTo(x + r, y - r);
      g.lineTo(x + r, y + r);
      g.lineTo(x - r, y + r);
      return g.closePath();
    } else if (shape === "romb") {
      g.moveTo(x - d2, y);
      g.lineTo(x, y - d2);
      g.lineTo(x + d2, y);
      g.lineTo(x, y + d2);
      g.closePath();
      return g.fill();
    } else if (shape === "triangle") {
      g.beginPath();
      g.moveTo(x - d2, y + d2);
      g.lineTo(x + d2, y + d2);
      g.lineTo(x, y - d2);
      g.closePath();
      return g.fill();
    } else if (shape === "triangle2") {
      g.beginPath();
      g.moveTo(x - d2, y - d2);
      g.lineTo(x + d2, y - d2);
      g.lineTo(x, y + d2);
      g.closePath();
      return g.fill();
    } else if (shape === "circle") {
      g.beginPath();
      g.arc(x, y, r, 0, Math.PI * 2, true);
      return g.closePath();
    } else {
      throw "unknown marker shape " + shape;
    }
  };

  Base_Graphics.strokeBalloon = function(g, x0, y0, w, h) {
    var m, r, s, x, y;
    w = Math.max(w, h * 2);
    m = 5;
    s = 4;
    r = (h + s * 2) / 2;
    x = x0;
    y = y0;
    g.moveTo(x, y);
    x += m;
    y += m;
    g.lineTo(x, y);
    x += w / 2 - s - m;
    g.lineTo(x, y);
    g.arc(x, y + r, r, -Math.PI / 2, Math.PI / 2);
    y += r * 2;
    x -= w - 2 * s;
    g.lineTo(x, y);
    g.arc(x, y - r, r, Math.PI * 0.5, Math.PI * 1.5);
    y -= r * 2;
    x += w / 2 - s - m;
    g.lineTo(x, y);
    x += m;
    y -= m;
    g.closePath();
    return y0 + m + r;
  };

  Base_Graphics.strokeBalloon2 = function(g, x0, y0, w, h) {
    var r, s, x, y;
    s = 4;
    r = (h + s * 2) / 2;
    w = Math.max(w, h * 2) / 2 - s;
    x = x0 + w;
    y = y0 - r;
    g.moveTo(x, y);
    g.arc(x, y + r, r, -Math.PI / 2, Math.PI / 2, false);
    y += r * 2;
    x -= w * 2;
    g.lineTo(x, y);
    g.arc(x, y - r, r, Math.PI * 0.5, Math.PI * 1.5, false);
    return g.closePath();
  };

  Base_Graphics.applyColorToImage = function(image, color, ignoreTransparent) {
    var a, b, c, cData, data, g, gr, h, i, r, result, w, _i, _j, _ref, _ref1, _ref2;
    if (ignoreTransparent == null) {
      ignoreTransparent = true;
    }
    _ref = Base_Graphics.parseColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
    c = document.createElement("canvas");
    w = c.width = image.width;
    h = c.height = image.height;
    gr = c.getContext("2d");
    gr.drawImage(image, 0, 0);
    cData = gr.getImageData(0, 0, w, h);
    data = cData.data;
    if (ignoreTransparent) {
      for (i = _i = 0, _ref1 = data.length; _i <= _ref1; i = _i += 4) {
        if (data[i + 3] !== 255) {
          continue;
        }
        data[i] = (data[i] * r) >> 8;
        data[i + 1] = (data[i + 1] * g) >> 8;
        data[i + 2] = (data[i + 2] * b) >> 8;
      }
    } else {
      for (i = _j = 0, _ref2 = data.length; _j <= _ref2; i = _j += 4) {
        data[i] = (data[i] * r) >> 8;
        data[i + 1] = (data[i + 1] * g) >> 8;
        data[i + 2] = (data[i + 2] * b) >> 8;
      }
    }
    gr.putImageData(cData, 0, 0);
    result = new Image();
    result.src = c.toDataURL("image/png");
    return result;
  };

  Base_Graphics.parseColor = function(color) {
    return Base_CssColorParser.parseCSSColor(color);
  };

  Base_Graphics.normalizeColor = function(color) {
    var a, b, g, r, _ref;
    _ref = Base_CssColorParser.parseCSSColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.deriveColor = function(color, lighten, opacity) {
    var a, b, g, r, _ref;
    _ref = Base_Graphics.parseColor(color), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
    return this.deriveColorRGBA(r, g, b, a, lighten, opacity);
  };

  Base_Graphics.deriveColorRGBA = function(r, g, b, a, lighten, opacity) {
    var light;
    light = (lighten - 1) * 255;
    r = Math.round(Math.min(255, Math.max(0, r + light)));
    g = Math.round(Math.min(255, Math.max(0, g + light)));
    b = Math.round(Math.min(255, Math.max(0, b + light)));
    a = Math.min(1, a * opacity);
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.blendColors = function(c0, c1, proportion) {
    var a, a0, a1, b, b0, b1, g, g0, g1, r, r0, r1, _ref, _ref1;
    _ref = Base_Graphics.parseColor(c0), r0 = _ref[0], g0 = _ref[1], b0 = _ref[2], a0 = _ref[3];
    _ref1 = Base_Graphics.parseColor(c1), r1 = _ref1[0], g1 = _ref1[1], b1 = _ref1[2], a1 = _ref1[3];
    r = Math.round(r1 * proportion + r0 * (1 - proportion));
    g = Math.round(g1 * proportion + g0 * (1 - proportion));
    b = Math.round(b1 * proportion + b0 * (1 - proportion));
    a = a1 * proportion + a0 * (1 - proportion);
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.copyHue = function(hue, brightness) {
    var a, a0, a1, b, b0, b1, br0, br1, g, g0, g1, r, r0, r1, _ref, _ref1;
    _ref = Base_Graphics.parseColor(hue), r0 = _ref[0], g0 = _ref[1], b0 = _ref[2], a0 = _ref[3];
    _ref1 = Base_Graphics.parseColor(brightness), r1 = _ref1[0], g1 = _ref1[1], b1 = _ref1[2], a1 = _ref1[3];
    br0 = (r0 + g0 + b0) / 765;
    br1 = (r1 + g1 + b1) / 765;
    r = Math.round(r0 / br0 * br1);
    g = Math.round(g0 / br0 * br1);
    b = Math.round(b0 / br0 * br1);
    a = a1;
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.inverseColor = function(c0) {
    var a, b, g, r, _ref;
    _ref = Base_Graphics.parseColor(c0), r = _ref[0], g = _ref[1], b = _ref[2], a = _ref[3];
    r = 255 - r;
    g = 255 - g;
    b = 255 - b;
    return "rgba(" + r + "," + g + "," + b + "," + (a.toFixed(3)) + ")";
  };

  Base_Graphics.applyShadow = function(g, style) {
    if (style.shadowColor) {
      g.shadowOffsetX = style.shadowOffsetX;
      g.shadowOffsetY = style.shadowOffsetY;
      g.shadowBlur = style.shadowBlur;
      return g.shadowColor = style.shadowColor;
    }
  };

  Base_Graphics.clearShadow = function(g) {
    g.shadowOffsetX = 0;
    g.shadowOffsetY = 0;
    g.shadowBlur = 0;
    return g.shadowColor = "";
  };

  return Base_Graphics;

})();

/*
//@ sourceMappingURL=Graphics.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Layout_TimedSpringEmbedder;

Netchart_Layout_TimedSpringEmbedder = (function() {
  var SpringEdge, SpringNode;

  SpringEdge = (function() {
    function SpringEdge() {}

    SpringEdge.prototype.to = null;

    SpringEdge.prototype.K = 0;

    SpringEdge.prototype.len = 0;

    SpringEdge.prototype.strength = 0;

    return SpringEdge;

  })();

  SpringNode = (function() {
    function SpringNode() {}

    SpringNode.prototype.x = 0;

    SpringNode.prototype.y = 0;

    SpringNode.prototype.z = 0;

    SpringNode.prototype.r = 1;

    SpringNode.prototype.zattr = 1;

    SpringNode.prototype.repulsiveForceX = 0;

    SpringNode.prototype.repulsiveForceY = 0;

    SpringNode.prototype.repulsiveForceZ = 0;

    SpringNode.prototype.fsum = 0;

    SpringNode.prototype.edges = [];

    return SpringNode;

  })();

  Netchart_Layout_TimedSpringEmbedder.prototype.temperature = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.unitTemperature = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.randomLayoutRadius = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.repulsiveForceTree = null;

  Netchart_Layout_TimedSpringEmbedder.prototype.randomGenerator = null;

  Netchart_Layout_TimedSpringEmbedder.prototype.nodePermutation = null;

  Netchart_Layout_TimedSpringEmbedder.prototype.nodeRepulsionFactor = 15;

  Netchart_Layout_TimedSpringEmbedder.prototype.componentCenterFactor = 0.005;

  Netchart_Layout_TimedSpringEmbedder.prototype.linkForceFactor = 0.2;

  Netchart_Layout_TimedSpringEmbedder.prototype.zAxisAttraction = 1;

  Netchart_Layout_TimedSpringEmbedder.prototype.nodeDegreeModifier = 1.2;

  Netchart_Layout_TimedSpringEmbedder.prototype.forceReductionFactor = 1;

  Netchart_Layout_TimedSpringEmbedder.prototype.globalForceX = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.globalForceY = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.centerX = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.centerY = 0;

  Netchart_Layout_TimedSpringEmbedder.prototype.aspectRatio = null;

  function Netchart_Layout_TimedSpringEmbedder(random) {
    this.random = random;
    this.nodeCount = 0;
    this.nodes = [];
    this.forceX = [];
    this.forceY = [];
    this.forceZ = [];
    this.forceSum = [];
    this.oldForceX = [];
    this.oldForceY = [];
    this.oldForceZ = [];
    this.componentX = [];
    this.componentY = [];
    this.componentSum = [];
    this.componentNodeCount = [];
    this.nodePermutation = [];
    this.idToIndex = {};
    this.repulsiveForceTree = new Netchart_Layout_BHTree();
  }

  Netchart_Layout_TimedSpringEmbedder.prototype.updateParams = function(spacing, nodeDegreeModifier, aspectRatio) {
    this.spacing = spacing;
    this.nodeDegreeModifier = nodeDegreeModifier;
    this.aspectRatio = aspectRatio;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.updateGraph = function(nodes, links, topologyChanges) {
    var desiredLen, desiredStrength, e, from, fsum, id, idx, lenSum, length, lengthProp, link, n, nn, node, oldIdToIndex, oldIdx, oldNode, oldNodes, oldOldForceX, oldOldForceY, oldOldForceZ, relevantEdgeCount, spacing, strength, sum, to, ton, vis, w, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _len6, _m, _n, _o, _ref, _ref1, _ref2, _ref3;
    topologyChanges |= nodes.length !== this.nodeCount;
    if (topologyChanges) {
      oldNodes = this.nodes;
      oldOldForceX = this.oldForceX;
      oldOldForceY = this.oldForceY;
      oldOldForceZ = this.oldForceZ;
      oldIdToIndex = this.idToIndex;
      this.nodeCount = nodes.length;
      this.oldForceX = new Array(this.nodeCount);
      this.oldForceY = new Array(this.nodeCount);
      this.oldForceZ = new Array(this.nodeCount);
      this.forceX = new Array(this.nodeCount);
      this.forceY = new Array(this.nodeCount);
      this.forceZ = new Array(this.nodeCount);
      this.forceSum = new Array(this.nodeCount);
      this.nodes = new Array(this.nodeCount);
      this.idToIndex = {};
      for (idx = _i = 0, _len = nodes.length; _i < _len; idx = ++_i) {
        n = nodes[idx];
        id = n.id;
        node = new SpringNode();
        node.edges = [];
        this.idToIndex[id] = idx;
        this.nodes[idx] = node;
        if (oldIdToIndex.hasOwnProperty(id)) {
          oldIdx = oldIdToIndex[id];
          oldNode = oldNodes[oldIdx];
          node.z = oldNode.z;
          this.oldForceX[idx] = oldOldForceX[oldIdx];
          this.oldForceY[idx] = oldOldForceY[oldIdx];
          this.oldForceZ[idx] = oldOldForceZ[oldIdx];
        } else {
          this.oldForceX[idx] = 0;
          this.oldForceY[idx] = 0;
          this.oldForceZ[idx] = 0;
        }
      }
      this.nodePermutation = this.nodes.slice(0);
    }
    for (idx = _j = 0, _len1 = nodes.length; _j < _len1; idx = ++_j) {
      n = nodes[idx];
      nn = this.nodes[idx];
      nn.x = n.x;
      nn.y = n.y;
      nn.r = Math.max(1, n.currentRadius);
      nn.zattr = n.visibility;
      nn.edges.length = 0;
      nn.locked = n.locked;
      this.forceX[idx] = 0;
      this.forceY[idx] = 0;
      this.forceZ[idx] = 0;
      this.forceSum[idx] = 0;
    }
    for (_k = 0, _len2 = links.length; _k < _len2; _k++) {
      link = links[_k];
      strength = link.strength;
      length = link.length;
      vis = link.visibility;
      from = this.nodes[this.idToIndex[link.from.id]];
      to = this.nodes[this.idToIndex[link.to.id]];
      if (!from || !to) {
        console.log("Layout: missing node for link: " + link.from.id + " " + link.to.id + ", topology = " + topologyChanges);
        continue;
      }
      if (from === to) {
        continue;
      }
      from.edges.push({
        to: to,
        strength: strength,
        len: length,
        vis: vis
      });
      to.edges.push({
        to: from,
        strength: strength,
        len: length,
        vis: vis
      });
    }
    if (topologyChanges) {
      this.computeComponents();
    }
    spacing = this.spacing / 2;
    _ref = this.nodes;
    for (_l = 0, _len3 = _ref.length; _l < _len3; _l++) {
      n = _ref[_l];
      sum = 0;
      _ref1 = n.edges;
      for (_m = 0, _len4 = _ref1.length; _m < _len4; _m++) {
        e = _ref1[_m];
        sum += e.to.edges.length * e.vis;
      }
      w = Math.sqrt(sum);
      n.r += spacing;
      if (w > 4) {
        n.r += (w - 4) * n.r / 4 * this.nodeDegreeModifier;
      }
    }
    lenSum = 0;
    relevantEdgeCount = 0;
    _ref2 = this.nodes;
    for (_n = 0, _len5 = _ref2.length; _n < _len5; _n++) {
      n = _ref2[_n];
      fsum = 0;
      _ref3 = n.edges;
      for (_o = 0, _len6 = _ref3.length; _o < _len6; _o++) {
        e = _ref3[_o];
        ton = e.to;
        if (n.locked && ton.locked || (n === ton)) {
          continue;
        }
        relevantEdgeCount++;
        desiredLen = n.r + ton.r;
        lengthProp = e.len;
        desiredStrength = Math.min(20, e.strength);
        e.len = Math.max(1, desiredLen * lengthProp);
        e.K = desiredStrength * 30 / e.len;
        fsum += e.K;
        lenSum += e.len;
      }
      n.fsum = fsum;
    }
    this.randomLayoutRadius = Math.max(1, lenSum / 10);
    return this.unitTemperature = lenSum / relevantEdgeCount / 50;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.computeComponents = function() {
    var component, componentNodes, e, end, n2, node, queue, start, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    this.componentX = [];
    this.componentY = [];
    this.componentSum = [];
    this.componentNodeCount = [];
    queue = new Array(this.nodeCount);
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      node.component = -1;
    }
    component = 0;
    _ref1 = this.nodes;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      node = _ref1[_j];
      if (node.component >= 0) {
        continue;
      }
      node.component = component;
      componentNodes = 0;
      start = 0;
      end = 0;
      queue[end] = node;
      end += 1;
      while (start < end) {
        node = queue[start];
        start += 1;
        componentNodes += 1;
        _ref2 = node.edges;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          e = _ref2[_k];
          n2 = e.to;
          if (n2.component === -1) {
            n2.component = component;
            queue[end] = n2;
            end += 1;
          }
        }
      }
      this.componentNodeCount.push(componentNodes);
      this.componentX.push(0);
      this.componentY.push(0);
      this.componentSum.push(0);
      component += 1;
    }
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.updateComponents = function() {
    var i, node, _i, _j, _k, _len, _ref, _ref1, _ref2, _results;
    for (i = _i = 0, _ref = this.componentNodeCount.length - 1; _i <= _ref; i = _i += 1) {
      this.componentX[i] = 0;
      this.componentY[i] = 0;
      this.componentSum[i] = 0;
    }
    _ref1 = this.nodes;
    for (_j = 0, _len = _ref1.length; _j < _len; _j++) {
      node = _ref1[_j];
      i = node.component;
      this.componentX[i] += node.x * node.r;
      this.componentY[i] += node.y * node.r;
      this.componentSum[i] += node.r;
    }
    _results = [];
    for (i = _k = 0, _ref2 = this.componentNodeCount.length - 1; _k <= _ref2; i = _k += 1) {
      this.componentX[i] /= this.componentSum[i];
      _results.push(this.componentY[i] /= this.componentSum[i]);
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.globalLayout = function(nodes, timeout, resetPositions) {
    var i1, iter, node, numberOfMovingNodes, step, t0, _i, _len, _ref;
    if (this.nodeCount <= 0) {
      return;
    }
    if (resetPositions) {
      if (this.nodeCount === 1) {
        nodes[0].x = nodes[0].y = 0;
        return;
      } else {
        this.initialRandomLayout();
      }
    }
    numberOfMovingNodes = 0;
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (!node.locked) {
        numberOfMovingNodes++;
      }
    }
    step = Math.floor(Math.sqrt(numberOfMovingNodes) + 10);
    iter = step * 2;
    this.forceReductionFactor = 1;
    this.temperature = (Math.sqrt(numberOfMovingNodes) * 2 + 20) * this.unitTemperature;
    this.zAxisAttraction = 0.1;
    t0 = new Date().getTime();
    i1 = 3;
    while (this.temperature > this.unitTemperature) {
      if ((iter--) <= 0) {
        iter = step * 3 / (i1++);
        this.temperature = this.temperature / 1.5 - 0.5;
        if (this.temperature < 20 * this.unitTemperature) {
          this.zAxisAttraction = this.zAxisAttraction * 1.5 + 0.1;
        }
      }
      this.randomNodePermutation();
      this.repulsiveForceTree.temperature = this.zAxisAttraction / 4;
      this.repulsiveForceTree.buildTree(this.nodePermutation);
      this.moveNodesGlobal();
      if (this.aspectRatio) {
        this.updateAspectRatio(this.forceReductionFactor * 0.001);
      }
      if (new Date().getTime() > t0 + timeout) {
        break;
      }
    }
    if (resetPositions) {
      this.centerNodes();
    }
    return this.storeNodes(nodes);
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.initialRandomLayout = function() {
    var R, coef, i, i1, n, perm, r, tmp, _i, _j, _k, _len, _ref, _ref1, _results;
    n = this.nodeCount;
    perm = new Array(n);
    for (i = _i = 0, _ref = n - 1; _i <= _ref; i = _i += 1) {
      perm[i] = i;
    }
    for (i = _j = 0; _j <= n; i = _j += 1) {
      i1 = Math.floor(this.random.get() * (n - i)) + i;
      tmp = perm[i];
      perm[i] = perm[i1];
      perm[i1] = tmp;
    }
    R = this.randomLayoutRadius;
    coef = 2 * Math.PI / this.nodeCount;
    _ref1 = this.nodes;
    _results = [];
    for (i = _k = 0, _len = _ref1.length; _k < _len; i = ++_k) {
      n = _ref1[i];
      this.oldForceX[i] = 0;
      this.oldForceY[i] = 0;
      this.oldForceZ[i] = 0;
      n.z = this.random.get() - 0.5;
      if (!n.locked) {
        r = R + n.r;
        n.x = r * Math.cos(perm[i] * coef);
        _results.push(n.y = r * Math.sin(perm[i] * coef));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.timedLayout = function(nodes, time) {
    var iter, x, _i, _ref;
    if (this.nodeCount <= 0) {
      return;
    }
    if (this.nodeCount === 1) {
      nodes[0].x = 0;
      nodes[0].y = 0;
      this.temperature = 0;
      this.unitTemperature = 0;
      return;
    }
    iter = 0;
    if (time < 0.1) {
      iter = 2;
      this.forceReductionFactor = Math.min(this.forceReductionFactor, time * 10);
    } else {
      iter = Math.min(6, Math.round(2 + time * 10));
    }
    this.zAxisAttraction = this.nodeRepulsionFactor / 10;
    this.temperature = this.unitTemperature;
    for (x = _i = 0, _ref = iter - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
      this.randomNodePermutation();
      this.repulsiveForceTree.temperature = this.zAxisAttraction / 4;
      this.repulsiveForceTree.buildTree(this.nodePermutation);
      this.moveNodesIncremental();
      if (this.aspectRatio) {
        this.updateAspectRatio(this.forceReductionFactor);
      }
    }
    return this.storeNodes(nodes);
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.moveNodesGlobal = function() {
    var forceFactor, fsum, fx, fy, fz, i, len, n1, randomness, _i, _ref, _results;
    this.initIteration();
    randomness = this.temperature * 0.5;
    forceFactor = this.forceReductionFactor;
    _results = [];
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      n1 = this.nodes[i];
      if (n1.locked) {
        continue;
      }
      this.calculateForce(i, 0.5);
      this.oldForceX[i] = fx = this.forceX[i];
      this.oldForceY[i] = fy = this.forceY[i];
      this.oldForceZ[i] = fz = this.forceZ[i];
      fsum = this.forceSum[i];
      fx *= fsum;
      fy *= fsum;
      fz *= fsum;
      len = fx * fx + fy * fy + fz * fz;
      if (len < this.temperature * this.temperature && len > 0.001) {
        len = this.temperature / Math.sqrt(len);
        fx *= len;
        fy *= len;
        fz *= len;
      }
      n1.x += fx * forceFactor + (this.random.get() - 0.5) * randomness;
      n1.y += fy * forceFactor + (this.random.get() - 0.5) * randomness;
      _results.push(n1.z += fz * forceFactor + (this.random.get() - 0.5) * randomness);
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.moveNodesIncremental = function() {
    var cfx, cfy, curLen, dx, dy, dz, freezedNodes, fsum, i, len, n1, scal, _i, _j, _k, _l, _ref, _ref1, _ref2, _ref3;
    this.initIteration();
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      if (!this.nodes[i].locked) {
        this.calculateForce(i, 0);
      }
    }
    scal = 0;
    len = 0;
    freezedNodes = new Array(this.nodeCount);
    for (i = _j = 0, _ref1 = this.nodeCount - 1; _j <= _ref1; i = _j += 1) {
      if (this.nodes[i].locked) {
        continue;
      }
      dx = this.forceX[i];
      dy = this.forceY[i];
      dz = this.forceZ[i];
      fsum = this.forceSum[i];
      curLen = dx * dx + dy * dy + dx * dx;
      if (curLen * fsum * fsum > this.unitTemperature * this.unitTemperature * 0.05 * 0.05) {
        len += curLen;
        scal += this.oldForceX[i] * dx + this.oldForceY[i] * dy + this.oldForceZ[i] * dz;
      } else {
        freezedNodes[i] = true;
      }
    }
    if (scal > 1e-7) {
      this.forceReductionFactor *= 1 + 0.4 / 1.618033989;
    } else if (scal < -1e-7) {
      this.forceReductionFactor /= 1.4;
    }
    cfx = this.globalForceX / this.nodeCount;
    cfy = this.globalForceY / this.nodeCount;
    for (i = _k = 0, _ref2 = this.nodeCount - 1; _k <= _ref2; i = _k += 1) {
      this.forceX[i] += cfx;
      this.forceY[i] += cfy;
    }
    this.forceReductionFactor = Math.min(1, this.forceReductionFactor);
    this.forceReductionFactor = Math.max(0.002, this.forceReductionFactor);
    for (i = _l = 0, _ref3 = this.nodeCount - 1; _l <= _ref3; i = _l += 1) {
      n1 = this.nodes[i];
      if (!n1.locked && !freezedNodes[i]) {
        fsum = this.forceSum[i] * this.forceReductionFactor;
        n1.x += this.forceX[i] * fsum;
        n1.y += this.forceY[i] * fsum;
        n1.z += this.forceZ[i] * fsum;
      }
      this.oldForceX[i] = this.forceX[i];
      this.oldForceY[i] = this.forceY[i];
      this.oldForceZ[i] = this.forceZ[i];
    }
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.initIteration = function() {
    var cx, cy, node, sum, _i, _len, _ref;
    cx = 0;
    cy = 0;
    sum = 0;
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      sum += node.r;
      cx += node.x * node.r;
      cy += node.y * node.r;
    }
    this.centerX = cx / sum;
    this.centerY = cy / sum;
    this.updateComponents();
    this.globalForceX = 0;
    return this.globalForceY = 0;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.calculateForce = function(nnum, fractionOfOld) {
    var cdx, cdy, cfx, cfy, component, csize, dx, dy, dz, e, f, kz, len, n1, n2, vx, vy, vz, _i, _len, _ref;
    n1 = this.nodes[nnum];
    dx = this.oldForceX[nnum] * fractionOfOld;
    dy = this.oldForceY[nnum] * fractionOfOld;
    dz = this.oldForceZ[nnum] * fractionOfOld;
    _ref = n1.edges;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      e = _ref[_i];
      n2 = e.to;
      vx = n1.x - n2.x;
      vy = n1.y - n2.y;
      vz = n1.z - n2.z;
      len = Math.sqrt(vx * vx + vy * vy + vz * vz);
      if (len < 0.01) {
        len = 0.01;
      }
      f = (e.len - len) * e.K / len * this.linkForceFactor;
      dx += f * vx;
      dy += f * vy;
      dz += f * vz;
    }
    dx += n1.repulsiveForceX * this.nodeRepulsionFactor;
    dy += n1.repulsiveForceY * this.nodeRepulsionFactor;
    dz += n1.repulsiveForceZ * this.nodeRepulsionFactor;
    kz = n1.zattr * this.zAxisAttraction / 7;
    dz -= n1.z * kz;
    component = n1.component;
    cdx = this.componentX[component] - this.centerX;
    cdy = this.componentY[component] - this.centerY;
    csize = Math.min(10, Math.sqrt(this.componentNodeCount[component]));
    cfx = cdx * csize * this.componentCenterFactor;
    cfy = cdy * csize * this.componentCenterFactor;
    dx -= cfx;
    dy -= cfy;
    this.globalForceX += cfx;
    this.globalForceY += cfy;
    if (isNaN(dx)) {
      throw "Nan in layout";
    }
    this.forceX[nnum] = dx;
    this.forceY[nnum] = dy;
    this.forceZ[nnum] = dz;
    return this.forceSum[nnum] = 1.0 / (n1.fsum + kz);
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.storeNodes = function(nodes) {
    var i, _i, _ref;
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      if (!this.nodes[i].locked) {
        nodes[i].x = this.nodes[i].x;
        nodes[i].y = this.nodes[i].y;
      }
    }
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.updateAspectRatio = function(fraction) {
    var curX, curY, cx, cy, i, incX, incY, invForce, n, newX, newY, node, ratio, scaleX, scaleY, side, sx, sy, x0, x1, y0, y1, _i, _j, _ref, _ref1, _results;
    n = this.nodes;
    x0 = x1 = n[0].x;
    y0 = y1 = n[0].y;
    for (i = _i = 1, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      x0 = Math.min(x0, n[i].x);
      x1 = Math.max(x1, n[i].x);
      y0 = Math.min(y0, n[i].y);
      y1 = Math.max(y1, n[i].y);
    }
    cx = (x0 + x1) / 2;
    cy = (y0 + y1) / 2;
    sx = x1 - x0;
    sy = y1 - y0;
    ratio = Math.sqrt(this.aspectRatio);
    side = Math.sqrt(sx * sy);
    scaleX = side * ratio / sx;
    scaleY = side / ratio / sy;
    scaleX = fraction * scaleX + (1 - fraction);
    scaleY = fraction * scaleY + (1 - fraction);
    incX = cx - cx * scaleX;
    incY = cy - cy * scaleY;
    invForce = 1 / this.forceReductionFactor;
    _results = [];
    for (i = _j = 0, _ref1 = this.nodeCount - 1; _j <= _ref1; i = _j += 1) {
      node = n[i];
      curX = node.x;
      curY = node.y;
      node.x = newX = curX * scaleX + incX;
      node.y = newY = curY * scaleY + incY;
      this.forceX[i] += (newX - curX) * invForce;
      _results.push(this.forceY[i] += (newY - curY) * invForce);
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.centerNodes = function() {
    var cx, cy, i, n, x0, x1, y0, y1, _i, _j, _ref, _ref1, _results;
    n = this.nodes;
    x0 = x1 = n[0].x;
    y0 = y1 = n[0].y;
    for (i = _i = 1, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      x0 = Math.min(x0, n[i].x);
      x1 = Math.max(x1, n[i].x);
      y0 = Math.min(y0, n[i].y);
      y1 = Math.max(y1, n[i].y);
    }
    cx = (x0 + x1) / 2;
    cy = (y0 + y1) / 2;
    _results = [];
    for (i = _j = 0, _ref1 = this.nodeCount - 1; _j <= _ref1; i = _j += 1) {
      n[i].x -= cx;
      _results.push(n[i].y -= cy);
    }
    return _results;
  };

  Netchart_Layout_TimedSpringEmbedder.prototype.randomNodePermutation = function() {
    var i, i1, tmp, _i, _ref;
    for (i = _i = 0, _ref = this.nodeCount - 1; _i <= _ref; i = _i += 1) {
      i1 = Math.floor(this.random.get() * (this.nodeCount - i)) + i;
      tmp = this.nodePermutation[i];
      this.nodePermutation[i] = this.nodePermutation[i1];
      this.nodePermutation[i1] = tmp;
    }
  };

  return Netchart_Layout_TimedSpringEmbedder;

})();

/*
//@ sourceMappingURL=TimedSpringEmbedder.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Animator;

Base_Animator = (function() {
  "use strict";
  Base_Animator.prototype.formula = null;

  Base_Animator.prototype.startTime = null;

  Base_Animator.prototype.from = 0;

  Base_Animator.prototype.to = 0;

  Base_Animator.prototype.fromColor = null;

  Base_Animator.prototype.toColor = null;

  Base_Animator.prototype.t = 0;

  Base_Animator.prototype.startSpeed = 0;

  Base_Animator.prototype.easing_formulas = {
    "=": function(t) {
      return t;
    },
    "<>": function(t) {
      if (t < 0.5) {
        return 2 * t * t;
      } else {
        return -0.5 * ((t * 2 - 1) * (t * 2 - 3) - 1);
      }
    },
    "scroll": function(t) {
      return 1 - (1 - t) * (1 - t);
    }
  };

  function Base_Animator(from, to, duration, easing, startTime) {
    this.from = from;
    this.to = to;
    this.duration = duration;
    if (easing == null) {
      easing = "<>";
    }
    if (this.from === void 0 || this.from === null) {
      this.from = this.to;
    }
    this.startTime = startTime === void 0 ? new Date().getTime() : startTime;
    this.x = this.from;
    this.t = this.startTime;
    if (!this.easing_formulas[easing]) {
      throw "Easing formula not defined: " + easing;
    } else {
      this.formula = this.easing_formulas[easing];
    }
  }

  Base_Animator.prototype.jump = function(to) {
    this.to = to;
    this.from = to;
    this.x = to;
    return this.t = this.startTime = 0;
  };

  Base_Animator.prototype.retarget = function(newTo, startTime) {
    startTime = startTime === void 0 ? new Date().getTime() : startTime;
    if (this.finished(this.t)) {
      this.startSpeed = 0;
    } else {
      this.startSpeed = this._getSpeed();
    }
    this.from = this.get(startTime);
    this.to = newTo;
    this.startTime = startTime;
    return this;
  };

  Base_Animator.prototype.retargetColor = function(newTo, startTime) {
    if (startTime === void 0) {
      startTime = this.t ? this.t : new Date().getTime();
    }
    this.startSpeed = 0;
    this.from = this.x;
    this.to = newTo;
    this.fromColor = null;
    this.toColor = null;
    this.startTime = startTime;
    return this;
  };

  Base_Animator.prototype.switchCoordinates = function(trAdd, trMul) {
    this.from = this.from * trMul + trAdd;
    this.x = this.x * trMul + trAdd;
    this.to = this.to * trMul + trAdd;
    return this.startSpeed = this.startSpeed * trMul;
  };

  Base_Animator.prototype.updateAndGet = function(targetValue, time) {
    var changes;
    changes = this.x !== targetValue;
    if (targetValue !== this.to) {
      this.retarget(targetValue, time);
    }
    return [this.get(time), changes];
  };

  Base_Animator.prototype.updateAndGetFixed = function(targetValue, time) {
    var changes;
    changes = this.x !== targetValue;
    if (targetValue !== this.to) {
      this.startSpeed = 0;
      this.startTime = time;
      this.from = this.x;
      this.to = targetValue;
      this.fromColor = null;
      this.toColor = null;
    }
    return [this.get(time), changes];
  };

  Base_Animator.prototype.updateColorAndGet = function(targetValue, time) {
    var changes;
    changes = this.x !== targetValue;
    if (targetValue !== this.to) {
      this.retargetColor(targetValue, time);
    }
    return [this.getColor(time), changes];
  };

  Base_Animator.prototype.get = function(time) {
    var easingPerc, percentage, spx, xx;
    if (this.duration <= 0) {
      this.t = time;
      this.x = this.to;
      return this.to;
    }
    percentage = Math.min(1, Math.max(time - this.startTime, 0) / this.duration);
    if (percentage >= 1) {
      this.t = time;
      this.x = this.to;
      return this.to;
    }
    easingPerc = this.formula(percentage);
    xx = easingPerc * (this.to - this.from);
    if (this.startSpeed && percentage < 1) {
      spx = this.startSpeed * percentage * this.duration;
      xx = xx * easingPerc + spx * (1 - easingPerc);
    }
    xx = this.from + xx;
    this.t = time;
    this.x = xx;
    return xx;
  };

  Base_Animator.prototype.getColor = function(time) {
    var fa, fb, fg, fr, p0, p1, percentage, ta, tb, tg, tr, xx, _ref, _ref1;
    this.t = time;
    if (this.duration <= 0 || this.from === this.to) {
      return this.to;
    }
    if (this.fromColor == null) {
      this.fromColor = Base_CssColorParser.parseCSSColor(this.from);
    }
    if (this.toColor == null) {
      this.toColor = Base_CssColorParser.parseCSSColor(this.to);
    }
    percentage = Math.min(1, Math.max(time - this.startTime, 0) / this.duration);
    p1 = this.formula(percentage);
    p0 = 1 - p1;
    _ref = this.fromColor, fr = _ref[0], fg = _ref[1], fb = _ref[2], fa = _ref[3];
    _ref1 = this.toColor, tr = _ref1[0], tg = _ref1[1], tb = _ref1[2], ta = _ref1[3];
    xx = "rgba(" + (Math.round(fr * p0 + tr * p1)) + "," + (Math.round(fg * p0 + tg * p1)) + "," + (Math.round(fb * p0 + tb * p1)) + "," + ((fa * p0 + ta * p1).toFixed(3)) + ")";
    this.t = time;
    this.x = xx;
    return xx;
  };

  Base_Animator.prototype.finished = function(time) {
    return time >= this.startTime + this.duration;
  };

  Base_Animator.prototype._getSpeed = function() {
    var d, p0, p1, time;
    time = this.t;
    d = this.duration / 1000;
    p0 = this.get(time - d / 2);
    p1 = this.get(time + d / 2);
    this.t = time;
    return (p1 - p0) / d;
  };

  return Base_Animator;

})();

/*
//@ sourceMappingURL=Animator.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Scrolling;

Netchart_Scrolling = (function() {
  function Netchart_Scrolling(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
    this.pointer1 = null;
    this.pointer2 = null;
    this.x1 = 0;
    this.y1 = 0;
    this.x2 = 0;
    this.y2 = 0;
    this.centerX = 0;
    this.centerY = 0;
    this.centerDistance = 1;
    this.resetZoom = false;
    this.animatorX = new Base_Animator(0, 0, this.scene.settings.interaction.zooming.autoZoomDuration, "=");
    this.animatorY = new Base_Animator(0, 0, this.scene.settings.interaction.zooming.autoZoomDuration, "=");
    this.animatorZ = new Base_Animator(0, 0, this.scene.settings.interaction.zooming.autoZoomDuration, "=");
  }

  Netchart_Scrolling.prototype.onWheel = function(event) {
    var zoomChange;
    if (!(this.scene.xyInChart(event.x, event.y) && this.scene.settings.interaction.zooming.wheel)) {
      return;
    }
    zoomChange = Math.pow(1 + this.scene.settings.interaction.zooming.sensitivity, event.wheely * 0.004);
    this.zoom(zoomChange, event.x, event.y);
    event.consumed = true;
    return event.changes.position = true;
  };

  Netchart_Scrolling.prototype.onPointerDown = function(event) {
    var dx, dy, len, _ref, _ref1, _ref2;
    if (this.pointer1 === null) {
      this.pointer1 = event.identifier;
      _ref = [event.x, event.y], this.x1 = _ref[0], this.y1 = _ref[1];
      return event.consumed = true;
    } else if (this.pointer2 === null) {
      this.pointer2 = event.identifier;
      _ref1 = [event.x, event.y], this.x2 = _ref1[0], this.y2 = _ref1[1];
      _ref2 = this.scene.fromDisplay((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2), this.centerX = _ref2[0], this.centerY = _ref2[1];
      dx = this.x1 - this.x2;
      dy = this.y1 - this.y2;
      len = Math.sqrt(dx * dx + dy * dy);
      this.centerDistance = len / this.scene.zoom;
      return event.consumed = true;
    }
  };

  Netchart_Scrolling.prototype.onPointerDrag = function(event) {
    if (event.identifier === this.pointer1 && this.pointer2 === null) {
      this.scene.centerX -= event.dx / this.scene.zoom;
      this.scene.centerY -= event.dy / this.scene.zoom;
      this.scene.settings.interaction.zooming.autoZoom = false;
      event.changes.position = true;
      return event.consumed = true;
    } else if (event.identifier === this.pointer1 && this.scene.settings.interaction.zooming.fingers) {
      this.twoFingerDrag(event.x, event.y, this.x2, this.y2);
      event.changes.position = true;
      return event.consumed = true;
    } else if (event.identifier === this.pointer2 && this.scene.settings.interaction.zooming.fingers) {
      this.twoFingerDrag(this.x1, this.y1, event.x, event.y);
      event.changes.position = true;
      return event.consumed = true;
    }
  };

  Netchart_Scrolling.prototype.onPointerUp = function(event) {
    if (this.pointer2 === event.identifier) {
      this.pointer2 = null;
    } else if (this.pointer1 === event.identifier) {
      if (this.pointer2 !== null) {
        this.pointer1 = this.pointer2;
        this.pointer2 = null;
        this.x1 = this.x2;
        this.y1 = this.y2;
      } else {
        this.pointer1 = null;
      }
    }
    return {
      onPointerCancel: function(event) {
        return this.onPointerUp(event);
      }
    };
  };

  Netchart_Scrolling.prototype.onDoubleClick = function(event) {
    var z;
    z = this.scene.settings.interaction.zooming.doubleClickZoom;
    if (z) {
      this.zoom(z, event.x, event.y);
      event.changes.position = true;
      return event.consumed = true;
    }
  };

  Netchart_Scrolling.prototype.twoFingerDrag = function(x1, y1, x2, y2) {
    var cx, cy, dz, newLen, sceneX, sceneY, sx1, sy1, _ref;
    sx1 = x2 - x1;
    sy1 = y2 - y1;
    newLen = Math.sqrt(sx1 * sx1 + sy1 * sy1) / this.scene.zoom;
    cx = (x2 + x1) / 2;
    cy = (y2 + y1) / 2;
    _ref = this.scene.fromDisplay(cx, cy), sceneX = _ref[0], sceneY = _ref[1];
    this.scene.centerX += this.centerX - sceneX;
    this.scene.centerY += this.centerY - sceneY;
    dz = newLen / this.centerDistance;
    this.zoom(dz, cx, cy);
    this.x1 = x1;
    this.y1 = y1;
    this.x2 = x2;
    return this.y2 = y2;
  };

  Netchart_Scrolling.prototype.zoom = function(zoomChange, displayX, displayY) {
    var dx, dy, extents, n, newZoom, o, scx, scy, vax0, vax1, vay0, vay1, vx0, vx1, vy0, vy1, x0, x1, xx, y0, y1, yy, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4;
    _ref = this.scene.getVisibleBounds(), vax0 = _ref[0], vay0 = _ref[1], vax1 = _ref[2], vay1 = _ref[3];
    extents = this.scene.settings.interaction.zooming.zoomExtent;
    newZoom = Math.max(extents[0], Math.min(extents[1], this.scene.zoom * zoomChange));
    zoomChange = newZoom / this.scene.zoom;
    if (displayX !== void 0 && displayY !== void 0) {
      _ref1 = this.scene.fromDisplay(displayX, displayY), scx = _ref1[0], scy = _ref1[1];
    } else if (this.scene.selection.length > 0) {
      xx = 0;
      yy = 0;
      n = 0;
      _ref2 = this.scene.selection;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        o = _ref2[_i];
        if (o.isNode) {
          xx += o.x;
          yy += o.y;
          n += 1;
        }
      }
      if (n > 0) {
        scx = xx / n;
        scy = yy / n;
      }
    }
    if (scx && scy) {
      this.scene.centerX = (this.scene.centerX - scx) / zoomChange + scx;
      this.scene.centerY = (this.scene.centerY - scy) / zoomChange + scy;
    } else {
      scx = this.scene.centerX;
      scy = this.scene.centerY;
    }
    this.scene.zoom *= zoomChange;
    _ref3 = this.scene.getGraphBounds(), x0 = _ref3[0], y0 = _ref3[1], x1 = _ref3[2], y1 = _ref3[3];
    _ref4 = this.scene.getVisibleBounds(), vx0 = _ref4[0], vy0 = _ref4[1], vx1 = _ref4[2], vy1 = _ref4[3];
    if (scx < x0 || scx > x1) {
      if (vx0 > x0 && vx1 > x1) {
        dx = Math.max(x1 - vx1, x0 - vx0);
      } else if (vx1 < x1 && vx0 < x0) {
        dx = Math.min(x1 - vx1, x0 - vx0);
      } else {
        dx = 0;
      }
      this.scene.centerX += dx;
    }
    if (scy < y0 || scy > y1) {
      if (vy0 > y0 && vy1 > y1) {
        dy = Math.max(y1 - vy1, y0 - vy0);
      } else if (vy1 < y1 && vy0 < x0) {
        dy = Math.min(y1 - vy1, y0 - vy0);
      } else {
        dy = 0;
      }
      this.scene.centerY += dy;
    }
    this.animatorX.jump(this.scene.centerX);
    this.animatorY.jump(this.scene.centerY);
    this.animatorZ.jump(this.scene.zoom);
    return this.scene.settings.interaction.zooming.autoZoom = false;
  };

  Netchart_Scrolling.prototype.doAnimations = function(event) {
    var autoZoomLowerTreshold, autoZoomTreshold, autoZoomUpperTreshold, cx, cy, height, time, width, xDiff, yDiff, z, zoomDiff, _ref;
    if (this.resetZoom) {
      this.resetZoom = false;
      return this.zoomToFit();
    } else if (this.scene.settings.interaction.zooming.autoZoom) {
      time = event.time;
      _ref = this.computeFitParams(), cx = _ref[0], cy = _ref[1], z = _ref[2];
      autoZoomTreshold = 0.01;
      autoZoomUpperTreshold = 1 + autoZoomTreshold;
      autoZoomLowerTreshold = 1 - autoZoomTreshold;
      zoomDiff = this.animatorZ.to / z;
      if (zoomDiff > autoZoomUpperTreshold || zoomDiff < autoZoomLowerTreshold) {
        this.animatorZ.retargetColor(z);
      }
      width = this.scene.width;
      xDiff = (this.animatorX.to - cx) * z / width;
      if (xDiff > autoZoomTreshold || xDiff < -autoZoomTreshold) {
        this.animatorX.retargetColor(cx);
      }
      height = this.scene.height;
      yDiff = (this.animatorY.to - cy) * z / height;
      if (yDiff > autoZoomTreshold || yDiff < -autoZoomTreshold) {
        this.animatorY.retargetColor(cy);
      }
      this.scene.centerX = this.animatorX.get(time);
      this.scene.centerY = this.animatorY.get(time);
      this.scene.zoom = this.animatorZ.get(time);
      if (!(this.animatorX.finished(time)) || !(this.animatorY.finished(time)) || !(this.animatorZ.finished(time))) {
        return event.animating = true;
      }
    }
  };

  Netchart_Scrolling.prototype.zoomToFit = function() {
    var _ref;
    _ref = this.computeFitParams(), this.scene.centerX = _ref[0], this.scene.centerY = _ref[1], this.scene.zoom = _ref[2];
    this.animatorX.jump(this.scene.centerX);
    this.animatorY.jump(this.scene.centerY);
    this.animatorZ.jump(this.scene.zoom);
    return false;
  };

  Netchart_Scrolling.prototype.computeFitParams = function() {
    var cx, cy, extents, h, w, x0, x1, y0, y1, zoom, _ref;
    _ref = this.scene.getGraphBounds(), x0 = _ref[0], y0 = _ref[1], x1 = _ref[2], y1 = _ref[3];
    if (x0 === x1 && y0 === y1) {
      return [0, 0, 1];
    } else {
      w = this.scene.width;
      h = this.scene.height;
      cx = (x0 + x1) / 2;
      cy = (y0 + y1) / 2;
      zoom = Math.min(w / (x1 - x0), h / (y1 - y0)) * 0.9;
      extents = this.scene.settings.interaction.zooming.zoomExtent;
      zoom = Math.max(extents[0], Math.min(extents[1], zoom));
      return [cx, cy, zoom];
    }
  };

  return Netchart_Scrolling;

})();

/*
//@ sourceMappingURL=Scrolling.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Helpers, lastTime, requestAnimationFrame,
  __hasProp = {}.hasOwnProperty,
  __slice = [].slice;

if (typeof String.prototype.trim === "undefined") {
  String.prototype.trim = function() {
    return this.replace(/^\s\s*/, '').replace(/\s\s*$/, '');
  };
}

requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame;

if (!requestAnimationFrame) {
  lastTime = 0;
  requestAnimationFrame = function(callback) {
    var currTime, id, timeToCall;
    currTime = new Date().getTime();
    timeToCall = Math.max(0, 16 - (currTime - lastTime));
    id = window.setTimeout(function() {
      return callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  };
}

window.requestAnimationFrame = requestAnimationFrame;

Base_Helpers = (function() {
  "use strict";
  function Base_Helpers() {}

  Base_Helpers.prototype.baseCSSClass = "DWSL";

  Base_Helpers.extend = function(object, other) {
    var key, val;
    if (object == null) {
      return {};
    }
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      val = other[key];
      object[key] = val;
    }
    return object;
  };

  Base_Helpers.extendDeep = function(object, other) {
    var key, val, valBefore;
    if (object == null) {
      return other;
    }
    for (key in other) {
      if (!__hasProp.call(other, key)) continue;
      val = other[key];
      valBefore = object[key];
      if (Base_Helpers.isObject(valBefore) && Base_Helpers.isObject(val)) {
        this.extendDeep(valBefore, val);
      } else {
        object[key] = val;
      }
    }
    return object;
  };

  Base_Helpers.configure = function(object, defaults) {
    var v;
    for (v in defaults) {
      if (typeof object[v] === "undefined" && defaults[v]) {
        object[v] = defaults[v];
      }
    }
    return object;
  };

  Base_Helpers.clone = function(obj) {
    var key, r, val;
    r = {};
    for (key in obj) {
      if (!__hasProp.call(obj, key)) continue;
      val = obj[key];
      r[key] = val;
    }
    return r;
  };

  Base_Helpers.isArray = function(source) {
    return source instanceof Array;
  };

  Base_Helpers.isObject = function(source) {
    return source !== null && typeof source === "object";
  };

  Base_Helpers.isFunction = function(source) {
    return typeof source === "function";
  };

  Base_Helpers.isNumber = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  Base_Helpers.isString = function(source) {
    return Object.prototype.toString.call(source) === '[object String]';
  };

  Base_Helpers.hasProperties = function(o) {
    var k, v;
    if (!o) {
      return false;
    }
    for (k in o) {
      if (!__hasProp.call(o, k)) continue;
      v = o[k];
      return true;
    }
    return false;
  };

  Base_Helpers.removeProperty = function(o) {
    var k, v;
    for (k in o) {
      if (!__hasProp.call(o, k)) continue;
      v = o[k];
      delete o[k];
      return k;
    }
    return null;
  };

  Base_Helpers.removePropertyValue = function(o) {
    var k, v;
    for (k in o) {
      if (!__hasProp.call(o, k)) continue;
      v = o[k];
      delete o[k];
      return [k, v];
    }
    return null;
  };

  Base_Helpers.countProperties = function(o) {
    var c, k, v;
    c = 0;
    for (k in o) {
      if (!__hasProp.call(o, k)) continue;
      v = o[k];
      c += 1;
    }
    return c;
  };

  Base_Helpers.realClone = function(source) {
    var a, d, k, o, v, _i, _len;
    o = this.isObject(source);
    a = this.isArray(source);
    if (a) {
      d = [];
      for (k = _i = 0, _len = source.length; _i < _len; k = ++_i) {
        v = source[k];
        if (typeof v !== "function") {
          d[k] = this.realClone(v);
        } else {
          d[k] = v;
        }
      }
    } else if (o) {
      d = {};
      for (k in source) {
        v = source[k];
        if (typeof v !== "function") {
          d[k] = this.realClone(v);
        } else {
          d[k] = v;
        }
      }
    } else {
      d = source;
    }
    return d;
  };

  Base_Helpers.arrayContains = function(arr, item) {
    var i, _i, _len;
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      i = arr[_i];
      if (i === item) {
        return true;
      }
    }
    return false;
  };

  Base_Helpers.removeFromArray = function(arr, item) {
    var i, removed, v;
    removed = false;
    for (i in arr) {
      v = arr[i];
      if (v === item) {
        arr.splice(i, 1);
        removed = true;
      }
    }
    return removed;
  };

  Base_Helpers.arraysEqual = function(arr1, arr2) {
    var i, _i, _ref;
    if (!((arr1 != null) && (arr2 != null))) {
      return false;
    }
    if (arr1.length !== arr2.length) {
      return false;
    }
    for (i = _i = 0, _ref = arr1.length - 1; _i <= _ref; i = _i += 1) {
      if (arr1[i] !== arr2[i]) {
        return false;
      }
    }
    return true;
  };

  Base_Helpers.log = function(message, arg) {
    if (typeof console !== "undefined" && console !== null) {
      if (arg != null) {
        return console.info(message, arg);
      } else {
        return console.info(message);
      }
    }
  };

  Base_Helpers.error = function(message, arg) {
    if (typeof console !== "undefined" && console !== null) {
      if (arg != null) {
        return console.error(message, arg);
      } else {
        return console.error(message);
      }
    }
  };

  Base_Helpers.getExtension = function(name) {
    var re;
    re = /(?:\.([^.]+))?$/;
    return re.exec(name)[1];
  };

  Base_Helpers.createDom = function(tagName, cl, innerHtml, container) {
    var el;
    el = document.createElement(tagName);
    if (cl != null) {
      el.className = cl;
    }
    if (innerHtml != null) {
      el.innerHTML = innerHtml;
    }
    if (container != null) {
      container.appendChild(el);
    }
    return el;
  };

  Base_Helpers.createStyledDom = function(tagName, style, innerHtml, container) {
    var el, k, v;
    el = document.createElement(tagName);
    if (style != null) {
      for (k in style) {
        if (!__hasProp.call(style, k)) continue;
        v = style[k];
        el.style[k] = v;
      }
    }
    if (innerHtml != null) {
      el.innerHTML = innerHtml;
    }
    if (container != null) {
      container.appendChild(el);
    }
    return el;
  };

  Base_Helpers.hasClass = function(el, name) {
    return (el.className.length > 0) && new RegExp("(^|\\s)" + name + "(\\s|$)").test(el.className);
  };

  Base_Helpers.addClass = function(el, name) {
    if (!Base_Helpers.hasClass(el, name)) {
      if (el.className.length === 0) {
        return el.className = name;
      } else {
        return el.className = el.className + " " + name;
      }
    }
  };

  Base_Helpers.removeClass = function(el, name) {
    var replaceFn;
    replaceFn = function(w, match) {
      if (match === name) {
        return '';
      } else {
        return w;
      }
    };
    return el.className = el.className.replace(/(\S+)\s*/g, replaceFn).replace(/(^\s+|\s+$)/, '');
  };

  Base_Helpers.setClass = function(el, name) {
    return el.className = name;
  };

  Base_Helpers.listen = function(node, event, fn) {
    if (node.addEventListener) {
      return node.addEventListener(event, fn);
    } else {
      return node.attachEvent("on" + event, fn);
    }
  };

  Base_Helpers.unlisten = function(node, event, fn) {
    if (node.removeEventListener) {
      return node.removeEventListener(event, fn);
    } else {
      return node.detachEvent("on" + event, fn);
    }
  };

  Base_Helpers.createEvent = function(type) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('Event');
      event.initEvent(type, true, true);
    } else {
      event = document.createEventObject();
    }
    return event;
  };

  Base_Helpers.canvasScaling = function() {
    var r;
    r = 1;
    if (window.devicePixelRatio) {
      r = window.devicePixelRatio;
    } else if (window.screen.systemXDPI) {
      r = window.screen.systemXDPI / window.screen.logicalXDPI;
    }
    return [r, r];
  };

  Base_Helpers.elementPos = function(obj) {
    var curLeft, curTop;
    curLeft = 0;
    curTop = 0;
    while (obj.offsetParent != null) {
      curLeft += obj.offsetLeft;
      curTop += obj.offsetTop;
      obj = obj.offsetParent;
    }
    return [curLeft, curTop];
  };

  Base_Helpers.isParentOf = function(parent, child) {
    while (child != null) {
      if (child === parent) {
        return true;
      }
      child = child.parentElement;
    }
    return false;
  };

  Base_Helpers.fadeIn = function(dom) {
    return dom.style.display = "block";
  };

  Base_Helpers.fadeOut = function(dom) {
    return dom.style.display = "none";
  };

  Base_Helpers.hide = function(dom) {
    return dom.style.display = "none";
  };

  Base_Helpers.show = function(dom) {
    return dom.style.display = "block";
  };

  Base_Helpers.wrapClass = function(base, c) {
    var o, x, y, _i, _len;
    if (!this.baseCSSClass) {
      this.baseCSSClass = "DVSL";
    }
    if (!base) {
      base = this.baseCSSClass;
    }
    if (typeof base === "object") {
      if (base.objClass) {
        base = base.objClass;
      } else {
        base = this.baseCSSClass;
      }
    }
    x = c.split(",");
    o = "";
    for (_i = 0, _len = x.length; _i < _len; _i++) {
      y = x[_i];
      if (o) {
        o += " ";
      }
      o += base + "-" + y;
    }
    return o;
  };

  Base_Helpers.getProp = function(obj, route) {
    var part, _i, _len, _ref;
    _ref = route.split("/");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      if (obj.hasOwnProperty(part)) {
        obj = obj[part];
      } else {
        return void 0;
      }
    }
    return obj;
  };

  Base_Helpers.hasProp = function(obj, route) {
    var part, _i, _len, _ref;
    _ref = route.split("/");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      part = _ref[_i];
      if (obj.hasOwnProperty(part)) {
        obj = obj[part];
      } else {
        return false;
      }
    }
    return obj !== void 0;
  };

  Base_Helpers.getScroll = function() {
    var body, doc, left, top;
    doc = document.documentElement;
    body = document.body;
    left = doc && doc.scrollLeft || body && body.scrollLeft || 0;
    top = doc && doc.scrollTop || body && body.scrollTop || 0;
    return [left, top];
  };

  Base_Helpers.isWithIn = function(dot, box) {
    if (dot[0] < box[0] || dot[0] > box[2] || dot[1] < box[1] || dot[1] > box[3]) {
      return true;
    } else {
      return false;
    }
  };

  Base_Helpers.mixIn = function(target, src) {
    var k, v, _ref, _results;
    _ref = src.prototype;
    _results = [];
    for (k in _ref) {
      v = _ref[k];
      _results.push(target[k] = v);
    }
    return _results;
  };

  Base_Helpers.sign = function(x) {
    if (!x) {
      return 0;
    }
    if (x < 0) {
      return -1;
    }
    return 1;
  };

  Base_Helpers.each = function() {
    var args, k, key, method, results, v, _i, _len, _ref, _ref1;
    key = arguments[0], method = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    results = [];
    if (Base_Helpers.isArray(this[key])) {
      _ref = this[key];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        if (v[method] != null) {
          results.push(v[method].apply(v, args));
        } else {
          console.error(v);
          throw "Object " + v + "does not have method: " + method;
        }
      }
    } else if (Base_Helpers.isObject(this[key])) {
      _ref1 = this[key];
      for (k in _ref1) {
        v = _ref1[k];
        if (v[method] != null) {
          results.push(v[method].apply(v, args));
        } else {
          console.error(v);
          throw "Object " + v + "does not have method " + method;
        }
      }
    } else {
      console.error(key, method, args);
      throw "Called iterator each on non-object/non-array";
    }
    return results;
  };

  Base_Helpers.detectBrowser = function() {
    var m, n, tem, ua;
    n = navigator.appName;
    ua = navigator.userAgent;
    m = ua.match(/(opera|chrome|safari|firefox|msie)\/?\s*(\.?\d+(\.\d+)*)/i);
    if (m && (tem = ua.match(/version\/([\.\d]+)/i)) !== null) {
      m[2] = tem[1];
    }
    if (m) {
      m = [m[1], m[2]];
    } else {
      m = [n, navigator.appVersion, '-?'];
    }
    return m[0].toLowerCase();
  };

  Base_Helpers.nextIdentifier = 0;

  Base_Helpers.getIdentifier = function() {
    return Base_Helpers.nextIdentifier++;
  };

  Base_Helpers.doRequest = function(url, params, success, fail) {
    var o, p, req, _i, _len,
      _this = this;
    o = [];
    for (_i = 0, _len = params.length; _i < _len; _i++) {
      p = params[_i];
      o.push("" + (encodeURIComponent(p[0])) + "=" + (encodeURIComponent(p[1])));
    }
    o = o.join("&");
    if (url.indexOf("?") !== -1) {
      url += "&" + o;
    } else {
      url += "?" + o;
    }
    if (window.XMLHttpRequest) {
      req = new XMLHttpRequest();
    } else if (window.ActiveXObject) {
      req = new ActiveXObject("Microsoft.XMLHTTP");
    }
    if (req) {
      req.onreadystatechange = function() {
        if (req.readyState === 4) {
          if (req.status === 200) {
            return success(req.responseText);
          } else {
            return fail();
          }
        }
      };
      req.open('GET', url, true);
      return req.send('');
    }
  };

  Base_Helpers.openUrl = function(url) {
    if (Base_Helpers.isString(url)) {
      return window.open(url);
    } else {
      return window.open(url.url, url.name, url.specs, url.replace);
    }
  };

  Base_Helpers.parseData = function(text, format, chart) {
    var data, error;
    data = null;
    if (format === "JSON") {
      if (typeof text === 'string' || text instanceof String) {
        try {
          data = JSON.parse(text);
        } catch (_error) {
          error = _error;
          chart.error("Error: failed to parse JSON response: " + error + ": " + text);
          data = {
            error: "Error: failed to parse JSON response"
          };
        }
      } else {
        data = text;
      }
    } else {
      chart.error("Unsupported data format: " + format);
    }
    return data;
  };

  Base_Helpers.numberFormat = function(n, decPlaces, decSeparator, thouSeparator) {
    var i, j, sign;
    n = parseFloat(n);
    decPlaces = isNaN(decPlaces = Math.abs(decPlaces)) ? 2 : decPlaces;
    decSeparator = decSeparator === void 0 ? "." : decSeparator;
    thouSeparator = thouSeparator === void 0 ? " " : thouSeparator;
    sign = n < 0 ? "-" : "";
    i = parseInt(n = Math.abs(+n || 0).toFixed(decPlaces)) + "";
    j = (j = i.length) > 3 ? j % 3 : 0;
    return sign + (j ? i.substr(0, j) + thouSeparator : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + thouSeparator) + (decPlaces ? decSeparator + Math.abs(n - i).toFixed(decPlaces).slice(2) : "");
  };

  return Base_Helpers;

})();

/*
//@ sourceMappingURL=Helpers.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Scene;

Base_Scene = (function() {
  "use strict";
  Base_Scene.prototype.chartWidth = 1;

  Base_Scene.prototype.chartHeight = 1;

  Base_Scene.prototype.toolbarHeight = 0;

  Base_Scene.prototype.x0 = 0;

  Base_Scene.prototype.y0 = 0;

  Base_Scene.prototype.height = 100;

  Base_Scene.prototype.width = 100;

  Base_Scene.prototype.leftMargin = 0;

  Base_Scene.prototype.rightMargin = 0;

  Base_Scene.prototype.topMargin = 0;

  Base_Scene.prototype.bottomMargin = 0;

  Base_Scene.prototype.canvasScaleX = 1;

  Base_Scene.prototype.canvasScaleY = 1;

  Base_Scene.prototype.settings = null;

  Base_Scene.prototype.loading = true;

  function Base_Scene() {
    this.messages = {};
    this.backStack = [];
  }

  Base_Scene.prototype.getChartBounds = function() {
    return {
      left: this.x0 - this.leftMargin,
      top: this.y0 - this.topMargin,
      right: this.x0 + this.width + this.rightMargin,
      bottom: this.y0 + this.height + this.bottomMargin
    };
  };

  Base_Scene.prototype.setMessage = function(origin, msg, pri) {
    var changed;
    if (msg != null) {
      changed = (this.messages[origin] == null) || this.messages[origin].msg !== msg || this.messages[origin].pri !== pri;
      this.messages[origin] = {
        msg: msg,
        pri: pri
      };
    } else {
      changed = this.messages[origin] != null;
      delete this.messages[origin];
    }
    return changed;
  };

  Base_Scene.prototype.getMessage = function() {
    var k, m, mm, pri, _ref;
    m = null;
    pri = 0;
    _ref = this.messages;
    for (k in _ref) {
      mm = _ref[k];
      if (mm.pri > pri) {
        m = mm.msg;
        pri = mm.pri;
      }
    }
    return m;
  };

  Base_Scene.prototype.pushBack = function(state) {
    this.backStack.push(state);
    if (this.backStack.length > 1000) {
      return this.backStack = this.backStack.slice(200);
    }
  };

  return Base_Scene;

})();

/*
//@ sourceMappingURL=Scene.map
*/

// Generated by CoffeeScript 1.6.3
/*
  Represents a single pointer. On multitouch, separate event for each pointer will be fired.
*/

var Base_MouseEvent, Base_MouseEvents, Base_MousePointer,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty;

Base_MouseEvent = (function() {
  Base_MouseEvent.prototype.time = 0;

  Base_MouseEvent.prototype.changes = {};

  Base_MouseEvent.prototype.consumed = false;

  Base_MouseEvent.prototype.defaultPrevented = false;

  Base_MouseEvent.prototype.preventDefault = function() {
    return this.defaultPrevented = true;
  };

  Base_MouseEvent.prototype.x = 0;

  Base_MouseEvent.prototype.y = 0;

  Base_MouseEvent.prototype.dx = 0;

  Base_MouseEvent.prototype.dy = 0;

  Base_MouseEvent.prototype.vx = 0;

  Base_MouseEvent.prototype.vy = 0;

  Base_MouseEvent.prototype.wheely = 0;

  Base_MouseEvent.prototype.wheelx = 0;

  Base_MouseEvent.prototype.identifier = 0;

  Base_MouseEvent.prototype.pressed = false;

  Base_MouseEvent.prototype.consumed = false;

  Base_MouseEvent.prototype.touch = false;

  Base_MouseEvent.prototype.swipeUp = false;

  Base_MouseEvent.prototype.swipeDown = false;

  Base_MouseEvent.prototype.swipeLeft = false;

  Base_MouseEvent.prototype.swipeRight = false;

  function Base_MouseEvent(x, y, time, identifier) {
    this.x = x;
    this.y = y;
    this.time = time;
    this.identifier = identifier;
    1;
  }

  Base_MouseEvent.prototype.distance = function(p) {
    return Math.sqrt((p.x - this.x) * (p.x - this.x) + (p.y - this.y) * (p.y - this.y));
  };

  return Base_MouseEvent;

})();

Base_MousePointer = (function() {
  function Base_MousePointer(event, settings) {
    this.settings = settings;
    this.identifier = event.identifier;
    this.x = event.x;
    this.y = event.y;
    this.pageX = event.pageX;
    this.pageY = event.pageY;
    this.time = event.time;
    this.pts = [[this.x, this.y, this.time]];
  }

  Base_MousePointer.prototype.moveTo = function(e) {
    if (e.time === this.time) {
      this.pts.pop();
    }
    this.time = e.time;
    if (e.x || e.y) {
      this.x = e.x;
      this.y = e.y;
    }
    this.pts.push([this.x, this.y, this.time]);
    if (this.pts.length > 6) {
      return this.pts.unshift();
    }
  };

  Base_MousePointer.prototype.getPosAndSpeed = function(e, isUp) {
    var dt, fraction, fromI, i, lastI, smallestDt, vx, vy, _i, _j, _k;
    e.x = this.x;
    e.y = this.y;
    lastI = this.pts.length - 2;
    if (lastI >= 0) {
      e.dx = this.pts[lastI + 1][0] - this.pts[lastI][0];
      e.dy = this.pts[lastI + 1][1] - this.pts[lastI][1];
    } else {
      e.dx = 0;
      e.dy = 0;
    }
    smallestDt = Infinity;
    for (i = _i = 0; _i <= lastI; i = _i += 1) {
      dt = this.pts[i + 1][2] - this.pts[i][2];
      smallestDt = Math.min(smallestDt, this.pts[i + 1][2] - this.pts[i][2]);
    }
    smallestDt = Math.max(smallestDt, 20);
    fromI = -1;
    for (i = _j = lastI; _j >= 0; i = _j += -1) {
      dt = this.pts[i + 1][2] - this.pts[i][2];
      if (dt > smallestDt * 2) {
        break;
      }
      fromI = i;
    }
    if (fromI === -1) {
      e.vx = 0;
      e.vy = 0;
      return;
    }
    vx = 0;
    vy = 0;
    fraction = 1;
    for (i = _k = fromI; _k <= lastI; i = _k += 1) {
      dt = this.pts[i + 1][2] - this.pts[i][2];
      vx = vx * (1 - fraction) + (this.pts[i + 1][0] - this.pts[i][0]) / dt * fraction;
      vy = vx * (1 - fraction) + (this.pts[i + 1][1] - this.pts[i][1]) / dt * fraction;
      fraction = 0.6;
    }
    e.vx = vx * 1000;
    return e.vy = vy * 1000;
  };

  return Base_MousePointer;

})();

Base_MouseEvents = (function() {
  "use strict";
  Base_MouseEvents.prototype.ID_MOUSE = "mouse";

  Base_MouseEvents.prototype.EVENT_MOVE = "move";

  Base_MouseEvents.prototype.EVENT_DOWN = "down";

  Base_MouseEvents.prototype.EVENT_DRAG = "drag";

  Base_MouseEvents.prototype.EVENT_CANCEL = "cancel";

  Base_MouseEvents.prototype.EVENT_UP = "up";

  Base_MouseEvents.prototype.EVENT_LEAVE = "leave";

  Base_MouseEvents.prototype.EVENT_CLICK = "click";

  Base_MouseEvents.prototype.EVENT_RCLICK = "rclick";

  Base_MouseEvents.prototype.EVENT_DBLCLICK = "dblclick";

  Base_MouseEvents.prototype.EVENT_WHEEL = "mwheel";

  Base_MouseEvents.prototype.scaleX = 1.0;

  Base_MouseEvents.prototype.scaleY = 1.0;

  Base_MouseEvents.prototype.hasTouch = false;

  Base_MouseEvents.prototype.mm = 1;

  Base_MouseEvents.prototype.clickEvent = null;

  Base_MouseEvents.prototype.longPressTimeout = null;

  Base_MouseEvents.prototype.cachedContainerPosition = null;

  function Base_MouseEvents(container, settings) {
    this.container = container;
    this.settings = settings;
    this.handleTouchMove = __bind(this.handleTouchMove, this);
    this.handleTouchCancel = __bind(this.handleTouchCancel, this);
    this.handleTouchEnd = __bind(this.handleTouchEnd, this);
    this.handleTouchStart = __bind(this.handleTouchStart, this);
    this.handleMouseMove = __bind(this.handleMouseMove, this);
    this.handleMouseUp = __bind(this.handleMouseUp, this);
    this.handleMouseWheel = __bind(this.handleMouseWheel, this);
    this.handleCMenu = __bind(this.handleCMenu, this);
    this.handleMouseDown = __bind(this.handleMouseDown, this);
    this.updateContainerPosition = __bind(this.updateContainerPosition, this);
    this.listeners = {};
    this.downPointers = {};
    this.inPointers = {};
    this.whiteList = [this.container];
    Base_Helpers.listen(this.container, "mousedown", this.handleMouseDown);
    Base_Helpers.listen(this.container, "contextmenu", this.handleCMenu);
    Base_Helpers.listen(this.container, "mousewheel", this.handleMouseWheel);
    Base_Helpers.listen(this.container, "DOMMouseScroll", this.handleMouseWheel);
    Base_Helpers.listen(this.container, "touchstart", this.handleTouchStart);
    Base_Helpers.listen(window, "mouseup", this.handleMouseUp);
    Base_Helpers.listen(window, "mousemove", this.handleMouseMove);
    Base_Helpers.listen(window, "touchend", this.handleTouchEnd);
    Base_Helpers.listen(window, "touchcancel", this.handleTouchCancel);
    Base_Helpers.listen(window, "touchmove", this.handleTouchMove);
    Base_Helpers.listen(window, "resize", this.updateContainerPosition);
  }

  Base_MouseEvents.prototype.addWhiteList = function(item) {
    this.whiteList.push(item);
    Base_Helpers.listen(item, "mousedown", this.handleMouseDown);
    Base_Helpers.listen(item, "mousewheel", this.handleMouseWheel);
    Base_Helpers.listen(item, "DOMMouseScroll", this.handleMouseWheel);
    return Base_Helpers.listen(item, "touchstart", this.handleTouchStart);
  };

  Base_MouseEvents.prototype.remove = function() {
    var k, v, _i, _len, _ref;
    Base_Helpers.unlisten(this.container, "mousedown", this.handleMouseDown);
    Base_Helpers.unlisten(this.container, "contextmenu", this.handleCMenu);
    Base_Helpers.unlisten(this.container, "mousewheel", this.handleMouseWheel);
    Base_Helpers.unlisten(this.container, "DOMMouseScroll", this.handleMouseWheel);
    Base_Helpers.unlisten(this.container, "touchstart", this.handleTouchStart);
    if (this.whiteList != null) {
      _ref = this.whiteList;
      for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
        v = _ref[k];
        Base_Helpers.unlisten(v, "mousedown", this.handleMouseDown);
        Base_Helpers.unlisten(v, "mousewheel", this.handleMouseWheel);
        Base_Helpers.unlisten(v, "DOMMouseScroll", this.handleMouseWheel);
        Base_Helpers.unlisten(v, "touchstart", this.handleTouchStart);
      }
    }
    Base_Helpers.unlisten(window, "mouseup", this.handleMouseUp);
    Base_Helpers.unlisten(window, "mousemove", this.handleMouseMove);
    Base_Helpers.unlisten(window, "touchend", this.handleTouchEnd);
    Base_Helpers.unlisten(window, "touchcancel", this.handleTouchCancel);
    return Base_Helpers.unlisten(window, "touchmove", this.handleTouchMove);
  };

  /*
    Simple variant - only one listener per event
  */


  Base_MouseEvents.prototype.listen = function(eventName, func) {
    return this.listeners[eventName] = func;
  };

  Base_MouseEvents.prototype.getContainerPosition = function() {
    if (this.cachedContainerPosition != null) {
      return this.cachedContainerPosition;
    } else {
      return this.updateContainerPosition();
    }
  };

  Base_MouseEvents.prototype.updateContainerPosition = function() {
    this.cachedContainerPosition = Base_Helpers.elementPos(this.container);
    return this.cachedContainerPosition;
  };

  Base_MouseEvents.prototype.handleMouseDown = function(event) {
    var e;
    if (this.hasTouch) {
      return;
    }
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
    this.downHappened(e, false);
    if (e.consumed) {
      return event.preventDefault();
    }
  };

  Base_MouseEvents.prototype.handleCMenu = function(event) {
    var e, isRightMB, k, p, _ref;
    if (event.which) {
      isRightMB = event.which === 3;
    } else {
      isRightMB = event.button === 2;
    }
    if (isRightMB) {
      e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
      _ref = this.downPointers;
      for (k in _ref) {
        if (!__hasProp.call(_ref, k)) continue;
        p = _ref[k];
        e = this.rebuildEvent(event, p, false);
        this.cancelHappened(e);
      }
      this.rclickHappened(e);
      if (e.consumed) {
        return event.preventDefault();
      }
    }
  };

  Base_MouseEvents.prototype.handleMouseWheel = function(event) {
    var e;
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, true);
    e.wheely = event.wheelDelta | (event.detail * -40);
    this.wheelHappened(e);
    if (e.consumed) {
      return event.preventDefault();
    }
  };

  Base_MouseEvents.prototype.handleMouseUp = function(event) {
    var e, removeAll;
    if (this.hasTouch) {
      return;
    }
    if (event.shiftKey && event.ctrlKey) {
      this.ID_MOUSE = "mouse" + this.mm;
      this.mm += 1;
      return;
    } else {
      removeAll = true;
    }
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
    e.isRightMB = event.witch ? event.which === 3 : event.button === 2;
    this.upHappened(e);
    if (e.consumed) {
      event.preventDefault();
    }
    if (removeAll) {
      return this.removeLostTouches(event, [], []);
    }
  };

  Base_MouseEvents.prototype.handleMouseMove = function(event) {
    var e;
    if (this.hasTouch) {
      return;
    }
    e = this.buildEvent(event, this.ID_MOUSE, event.timeStamp, false);
    this.moveHappened(e);
    if (e.consumed) {
      return event.preventDefault();
    }
  };

  Base_MouseEvents.prototype.handleTouchStart = function(event) {
    var consumed, e, list, t, _i, _len;
    if (!this.isTargetOkay(event.target)) {
      return;
    }
    this.hasTouch = true;
    this.removeLostTouches(event, event.touches, event.changedTouches);
    consumed = false;
    list = event.changedTouches || event.touches;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      t = list[_i];
      e = this.buildEvent(t, t.identifier, event.timeStamp, true);
      this.downHappened(e, true);
      consumed || (consumed = e.consumed);
    }
    if (consumed) {
      return event.preventDefault();
    }
  };

  Base_MouseEvents.prototype.handleTouchEnd = function(event) {
    var consumed, e, list, t, _i, _len;
    list = event.changedTouches || event.touches;
    consumed = false;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      t = list[_i];
      e = this.buildEvent(t, t.identifier, event.timeStamp, false);
      this.upHappened(e);
      this.pointerLeave(e);
      consumed || (consumed = e.consumed);
      this.removeLostTouches(event, event.touches);
    }
    if (consumed) {
      return event.preventDefault();
    }
  };

  Base_MouseEvents.prototype.handleTouchCancel = function(event) {
    var e, list, t, _i, _len;
    list = event.changedTouches || event.touches;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      t = list[_i];
      e = this.buildEvent(t, t.identifier, event.timeStamp, false);
      this.cancelHappened(e);
    }
    return this.removeLostTouches(event, event.touches);
  };

  Base_MouseEvents.prototype.handleTouchMove = function(event) {
    var consumed, e, list, t, _i, _len;
    consumed = false;
    this.removeLostTouches(event, event.touches);
    list = event.changedTouches || event.touches;
    for (_i = 0, _len = list.length; _i < _len; _i++) {
      t = list[_i];
      e = this.buildEvent(t, t.identifier, event.timeStamp, true);
      this.moveHappened(e);
      consumed || (consumed = e.consumed);
    }
    if (consumed) {
      return event.preventDefault();
    }
  };

  Base_MouseEvents.prototype.removeLostTouches = function(event, touches, freshTouches) {
    var e, k, p, presentTouches, t, _i, _j, _len, _len1, _ref, _results;
    presentTouches = [];
    for (_i = 0, _len = touches.length; _i < _len; _i++) {
      t = touches[_i];
      presentTouches[t.identifier] = true;
    }
    _ref = this.downPointers;
    for (k in _ref) {
      if (!__hasProp.call(_ref, k)) continue;
      p = _ref[k];
      if (!presentTouches[k]) {
        e = this.rebuildEvent(event, p, false);
        this.upHappened(e);
      }
    }
    if (freshTouches != null) {
      _results = [];
      for (_j = 0, _len1 = freshTouches.length; _j < _len1; _j++) {
        t = freshTouches[_j];
        p = this.downPointers[t.identifier];
        if (p != null) {
          console.log("Removing fresh touch " + t.identifier);
          e = this.rebuildEvent(event, p, false);
          _results.push(this.upHappened(e));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Base_MouseEvents.prototype.rebuildEvent = function(event, obj, pressed) {
    var e;
    e = new Base_MouseEvent(obj.x, obj.y, event.timeStamp, obj.identifier);
    e.pageX = obj.pageX;
    e.pageY = obj.pageY;
    e.pressed = pressed;
    e.shiftKey = event.shiftKey;
    e.altKey = event.altKey;
    e.ctrlKey = event.ctrlKey;
    e.touch = this.hasTouch;
    return e;
  };

  Base_MouseEvents.prototype.buildEvent = function(event, id, timestamp, pressed) {
    var dx, dy, e, x, y, _ref;
    _ref = this.getContainerPosition(), dx = _ref[0], dy = _ref[1];
    x = event.pageX - dx;
    y = event.pageY - dy;
    e = new Base_MouseEvent(Math.round(x * this.scaleX), Math.round(y * this.scaleY), timestamp, id);
    e.target = event.target;
    e.touch = this.hasTouch;
    e.pageX = event.pageX;
    e.pageY = event.pageY;
    e.shiftKey = event.shiftKey;
    e.altKey = event.altKey;
    e.ctrlKey = event.ctrlKey;
    e.pressed = pressed;
    return e;
  };

  Base_MouseEvents.prototype.downHappened = function(e, isTouch) {
    var p;
    if (!this.isTargetOkay(e.target)) {
      return;
    }
    e.pressed = true;
    if (this.downPointers[e.identifier] != null) {
      console.log("Unexpected down on already down pointer");
      return;
    }
    this.downPointers[e.identifier] = p = new Base_MousePointer(e, this.settings);
    p.touch = isTouch;
    this.inPointers[e.identifier] = true;
    this.fireEvent(this.EVENT_DOWN, e);
    if (isTouch) {
      return this.startLongPress(e);
    }
  };

  Base_MouseEvents.prototype.upHappened = function(e) {
    var fireClick, p,
      _this = this;
    this.cachedContainerPosition = null;
    if (this.downPointers[e.identifier] == null) {
      return false;
    }
    p = this.downPointers[e.identifier];
    this.cancelLongPress(e);
    p.moveTo(e);
    p.getPosAndSpeed(e, true);
    delete this.downPointers[e.identifier];
    if (Math.abs(e.vx) > Math.abs(e.vy) * 2) {
      e.swipeSpeed = Math.abs(e.vx);
      if (e.vx > 0) {
        e.swipeLeft = true;
      }
      if (e.vx < 0) {
        e.swipeRight = true;
      }
    } else if (Math.abs(e.vy) > Math.abs(e.vx) * 2) {
      e.swipeSpeed = Math.abs(e.vy);
      if (e.vy < 0) {
        e.swipeUp = true;
      }
      if (e.vy > 0) {
        e.swipeDown = true;
      }
    }
    this.fireEvent(this.EVENT_UP, e);
    if (!(p.scrolling || e.isRightMB || p.rightClicked)) {
      if ((this.clickEvent != null) && this.clickEvent.time + this.settings.doubleClickTimeout >= e.time && this.clickEvent.distance(e) < this.settings.doubleClickSensitivity) {
        this.clickEvent = null;
        return this.fireEvent(this.EVENT_DBLCLICK, e);
      } else if (this.settings.noClickOnDoubleClick) {
        this.clickEvent = e;
        fireClick = function() {
          if (_this.clickEvent === e) {
            _this.fireEvent(_this.EVENT_CLICK, _this.clickEvent);
            return _this.clickEvent = null;
          }
        };
        return setTimeout(fireClick, this.settings.doubleClickTimeout);
      } else {
        this.fireEvent(this.EVENT_CLICK, e);
        return this.clickEvent = e;
      }
    }
  };

  Base_MouseEvents.prototype.cancelHappened = function(e) {
    var p;
    this.cachedContainerPosition = null;
    if (this.downPointers[e.identifier] == null) {
      return;
    }
    this.cancelLongPress(e);
    p = this.downPointers[e.identifier];
    delete this.downPointers[e.identifier];
    return this.fireEvent(this.EVENT_CANCEL, e);
  };

  Base_MouseEvents.prototype.moveHappened = function(e) {
    var p;
    p = this.downPointers[e.identifier];
    e.pressed = p != null;
    if (p != null) {
      if (e.distance(p) >= this.settings.dragSensitivity || p.scrolling) {
        this.cancelLongPress(e);
        p.scrolling = true;
        p.moveTo(e);
        p.getPosAndSpeed(e, false);
        return this.fireEvent(this.EVENT_DRAG, e);
      }
    } else if (this.clickEvent && this.settings.noClickOnDoubleClick) {
      if (this.clickEvent.distance(e) > this.settings.doubleClickSensitivity) {
        this.fireEvent(this.EVENT_CLICK, this.clickEvent);
        return this.clickEvent = null;
      }
    } else if (this.isTargetOkay(e.target)) {
      this.inPointers[e.identifier] = true;
      return this.fireEvent(this.EVENT_MOVE, e);
    } else {
      return this.pointerLeave(e);
    }
  };

  Base_MouseEvents.prototype.pointerLeave = function(e) {
    if (this.inPointers.hasOwnProperty(e.identifier)) {
      delete this.inPointers[e.identifier];
      return this.fireEvent(this.EVENT_LEAVE, e);
    }
  };

  Base_MouseEvents.prototype.startLongPress = function(e) {
    var fireLongPress,
      _this = this;
    fireLongPress = function() {
      e.consumed = false;
      _this.fireEvent(_this.EVENT_RCLICK, e);
      if (e.consumed) {
        return _this.downPointers[e.identifier].rightClicked = true;
      }
    };
    this.cancelLongPress();
    return this.longPressTimeout = setTimeout(fireLongPress, this.settings.longPressTimeout);
  };

  Base_MouseEvents.prototype.cancelLongPress = function() {
    if (this.longPressTimeout !== null) {
      clearTimeout(this.longPressTimeout);
      return this.longPressTimeout = null;
    }
  };

  Base_MouseEvents.prototype.wheelHappened = function(e) {
    return this.fireEvent(this.EVENT_WHEEL, e);
  };

  Base_MouseEvents.prototype.rclickHappened = function(e) {
    return this.fireEvent(this.EVENT_RCLICK, e);
  };

  Base_MouseEvents.prototype.fireEvent = function(name, event) {
    if (this.listeners[name]) {
      return this.listeners[name].call(this, event);
    }
  };

  Base_MouseEvents.prototype.isTargetOkay = function(target) {
    var k, v, _i, _len, _ref;
    _ref = this.whiteList;
    for (k = _i = 0, _len = _ref.length; _i < _len; k = ++_i) {
      v = _ref[k];
      if ((v === target) || Base_Helpers.isParentOf(v, target)) {
        return true;
      }
    }
    return false;
  };

  return Base_MouseEvents;

})();

/*
//@ sourceMappingURL=MouseEvents.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Settings;

Base_Settings = (function() {
  Base_Settings.defaults = {
    container: null,
    width: null,
    height: null,
    minHeight: 165,
    maxHeight: 2000,
    minWidth: 100,
    maxWidth: 4000,
    theme: null,
    assetsUrlBase: "",
    area: {
      style: {
        fillColor: "transparent"
      }
    },
    advanced: {
      highDpi: {
        "default": true,
        safari: false,
        firefox: true,
        msie: true,
        chrome: false
      },
      pointer: {
        noClickOnDoubleClick: true,
        dragSensitivity: 10,
        doubleClickSensitivity: 40,
        doubleClickTimeout: 300,
        longPressTimeout: 500,
        speedAveragingPeriod: 200
      },
      trackTouches: false,
      logging: false,
      style: {
        messageTextStyle: {
          fillColor: "#000",
          font: "15px Arial"
        },
        loadingArcStyle: {
          r: 35,
          lineColor: "#444",
          lineWidth: 2
        }
      },
      maxCanvasWidth: 2047,
      maxCanvasHeight: 2047,
      themeCSSClass: "DVSL-round",
      assets_applyMethod: "merge",
      assets: ["base.css"],
      builtinAssets: {
        "builtin-logo": Base_images_logo
      },
      exportProxyURL: "http://developers.dvsl.co/export"
    },
    interaction: {
      resizing: {
        enabled: true,
        advanced: {
          resizerHandleVisibilityTolerance: 45,
          resizerHandleEnableTolerance: 10
        }
      }
    },
    events: {
      onError: null,
      onSettingsChange: null,
      onClick: null,
      onDoubleClick: null,
      onRightClick: null,
      onHoverChanged: null,
      onSelectionChange: null,
      onChartUpdate: null,
      onAnimationDone: null,
      chartUpdateDelay: 0
    },
    title: {
      enabled: true,
      enabledOnExport: true,
      align: "center",
      margin: 25,
      style: {
        font: "20px Arial",
        fillColor: "#000"
      },
      text: ""
    },
    credits: {
      enabled: false,
      enabledOnExport: true,
      href: "http://dvsl.co",
      image: "builtin-logo"
    }
  };

  function Base_Settings(scriptName) {
    var k, n, prefix, r, r2, v, _ref;
    this._imageCache = {};
    this.apply(Base_Settings.defaults);
    r = new RegExp("((file:\/\/\/|https?:\/\/)[^\/]+\/.*?)\/?" + scriptName + "(-dev|\.min|)\.js");
    r2 = new RegExp("((file:\/\/\/|https?:\/\/)[^\/]+\/.*\/src)\/?" + scriptName);
    _ref = document.getElementsByTagName("script");
    for (k in _ref) {
      v = _ref[k];
      if (v.src && (n = v.src.match(r))) {
        if (n[1][n[1].length - 1] === "/") {
          prefix = "";
        } else {
          prefix = "/";
        }
        this.assetsUrlBase = n[1] + prefix + "assets/";
      }
      if (v.src && (n = v.src.match(r2))) {
        if (n[1][n[1].length - 1] === "/") {
          prefix = "";
        } else {
          prefix = "/";
        }
        this.assetsUrlBase = n[1] + prefix + "assets/";
      }
    }
  }

  Base_Settings.prototype.apply = function(settings) {
    var changes, theme;
    if (settings == null) {
      return;
    }
    changes = {};
    theme = null;
    if (settings.theme != null) {
      theme = settings.theme;
      delete settings.theme;
    }
    if (theme) {
      this.applyRec(this, theme, changes, 0);
      settings.theme = theme;
    }
    this.applyRec(this, settings, changes, 0);
    return changes;
  };

  Base_Settings.prototype.applyRec = function(target, changes, changedProperties, depth) {
    var a, f, key, methodProp, o, oa, oo, origValue, skip, ta, value, vv, _i, _len;
    if (depth > 10) {
      throw "Stack depth greater than 10, seems like recursive settings";
    }
    if (target === void 0) {
      console.error(depth, target, changes);
      throw "Tried to applyRec on undefined";
    }
    for (key in changes) {
      value = changes[key];
      origValue = target[key];
      if (origValue !== void 0 && value === origValue) {
        continue;
      }
      a = Base_Helpers.isArray(value);
      o = Base_Helpers.isObject(value);
      oa = Base_Helpers.isArray(origValue);
      oo = Base_Helpers.isObject(origValue);
      f = Base_Helpers.isFunction(value);
      skip = false;
      if (oa && !a) {
        console.error("Applying settings: Setting expected to be array but got something else: " + key + " = " + value);
        skip = true;
      }
      if (value !== null && oo && !o && !f) {
        console.error("Applying settings: Setting expected to be object but got something else: " + key + " = " + value);
        skip = true;
      }
      if (skip) {
        continue;
      }
      if (o) {
        if (!(origValue != null)) {
          if (a) {
            target[key] = [];
            changedProperties[key] = [];
            oo = true;
          } else {
            target[key] = {};
            changedProperties[key] = {};
            oo = true;
          }
        }
        if (value === null || value === void 0) {
          target[key] = value;
          changedProperties[key] = value;
        }
        if (o && !oo) {
          target[key] = {};
          changedProperties[key] = {};
        }
        if (key === "container") {
          target[key] = value;
          changedProperties[key] = value;
        } else if (a) {
          methodProp = key + "_applyMethod";
          if (changes[methodProp] === "merge" || target[methodProp] === "merge") {
            ta = target[key];
            for (_i = 0, _len = value.length; _i < _len; _i++) {
              vv = value[_i];
              if (!Base_Helpers.arrayContains(ta, vv)) {
                ta.push(vv);
              }
            }
          } else {
            target[key] = value;
          }
          changedProperties[key] = value;
        } else {
          if (!changedProperties.hasOwnProperty(key)) {
            changedProperties[key] = {};
          }
          this.applyRec(target[key], value, changedProperties[key], depth + 1);
        }
      } else if (value === void 0) {
        delete target[key];
        changedProperties[key] = value;
      } else {
        target[key] = value;
        changedProperties[key] = value;
      }
    }
    return 1;
  };

  Base_Settings.prototype.applyById = function(target, changes, changedProperties) {
    var c, ch, found, o, _i, _j, _len, _len1, _results;
    _results = [];
    for (_i = 0, _len = changes.length; _i < _len; _i++) {
      c = changes[_i];
      found = false;
      if (c.id) {
        for (_j = 0, _len1 = target.length; _j < _len1; _j++) {
          o = target[_j];
          if (o.id === c.id) {
            ch = {};
            this.applyRec(o, c, ch, 0);
            changedProperties.push(ch);
            found = true;
            break;
          }
        }
      }
      if (!found) {
        target.push(c);
        _results.push(changedProperties.push(c));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Base_Settings.prototype.getAssetUrl = function(asset) {
    if (this.advanced.builtinAssets.hasOwnProperty(asset)) {
      return this.advanced.builtinAssets[asset];
    }
    if (!((this.assetsUrlBase != null) && this.assetsUrlBase.length > 0)) {
      return asset;
    }
    if (asset.indexOf("://") !== -1) {
      return asset;
    }
    if (asset[0] === "/" || asset.indexOf("./") === 0) {
      return asset;
    }
    if (this.assetsUrlBase[this.assetsUrlBase.length - 1] !== "/") {
      return this.assetsUrlBase + "/" + asset;
    } else {
      return this.assetsUrlBase + asset;
    }
  };

  Base_Settings.prototype.getAssetImage = function(asset) {
    var image, url;
    if (this._imageCache.hasOwnProperty(asset)) {
      return this._imageCache[asset];
    }
    url = this.getAssetUrl(asset);
    if (!url) {
      return null;
    }
    image = this._imageCache[asset] = new Image();
    image.src = url;
    if (image.width > 0) {
      return image;
    } else {
      return null;
    }
  };

  return Base_Settings;

})();

/*
//@ sourceMappingURL=Settings.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Icon, Netchart_Link, Netchart_Node, Netchart_Scene,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Icon = (function() {
  function Netchart_Icon() {}

  Netchart_Icon.prototype.image = null;

  Netchart_Icon.prototype.title = null;

  Netchart_Icon.prototype.onclick = null;

  return Netchart_Icon;

})();

Netchart_Node = (function() {
  Netchart_Node.prototype.id = "";

  Netchart_Node.prototype.x = 0;

  Netchart_Node.prototype.y = 0;

  Netchart_Node.prototype.isNode = true;

  Netchart_Node.prototype.isLink = false;

  Netchart_Node.prototype.removed = false;

  Netchart_Node.prototype.added = false;

  Netchart_Node.prototype.data = null;

  Netchart_Node.prototype.loading = false;

  Netchart_Node.prototype.links = null;

  Netchart_Node.prototype.dataLinks = null;

  Netchart_Node.prototype.userLock = false;

  Netchart_Node.prototype.expanded = false;

  Netchart_Node.prototype.focused = false;

  Netchart_Node.prototype.fillColor = null;

  Netchart_Node.prototype.lineColor = null;

  Netchart_Node.prototype.lineWidth = 1;

  Netchart_Node.prototype.image = null;

  Netchart_Node.prototype.imageSlicing = null;

  Netchart_Node.prototype.tintImage = false;

  Netchart_Node.prototype.radius = 10;

  Netchart_Node.prototype.hwidth = null;

  Netchart_Node.prototype.label = null;

  Netchart_Node.prototype.labelStyle = null;

  Netchart_Node.prototype.labelBackground = null;

  Netchart_Node.prototype.labelLocation = null;

  Netchart_Node.prototype.icons = null;

  Netchart_Node.prototype.hilight = null;

  Netchart_Node.prototype.locks = 0;

  Netchart_Node.prototype.currentRadius = 0;

  Netchart_Node.prototype.currentHwidth = 0;

  function Netchart_Node(id) {
    this.id = id;
    this.links = [];
  }

  return Netchart_Node;

})();

Netchart_Link = (function() {
  function Netchart_Link() {}

  Netchart_Link.prototype.from = null;

  Netchart_Link.prototype.to = null;

  Netchart_Link.prototype.removed = false;

  Netchart_Link.prototype.isNode = false;

  Netchart_Link.prototype.isLink = true;

  Netchart_Link.prototype.data = null;

  Netchart_Link.prototype.multiId = null;

  Netchart_Link.prototype.radius = 1;

  Netchart_Link.prototype.length = 1;

  Netchart_Link.prototype.strength = 1;

  Netchart_Link.prototype.label = null;

  Netchart_Link.prototype.labelStyle = null;

  Netchart_Link.prototype.labelBackground = null;

  Netchart_Link.prototype.dashed = false;

  Netchart_Link.prototype.currentRadius = 0;

  Netchart_Link.prototype.direction = null;

  Netchart_Link.prototype.fromDecoration = null;

  Netchart_Link.prototype.toDecoration = null;

  Netchart_Link.prototype.fromIcons = null;

  Netchart_Link.prototype.toIcons = null;

  Netchart_Link.prototype.highlight = null;

  Netchart_Link.prototype.toPieValue = 0;

  Netchart_Link.prototype.toPieColor = null;

  Netchart_Link.prototype.toPie0 = null;

  Netchart_Link.prototype.toPie1 = null;

  Netchart_Link.prototype.otherEnd = function(node) {
    if (node === this.from) {
      return this.to;
    }
    if (node === this.to) {
      return this.from;
    }
    return null;
  };

  Netchart_Link.prototype.commonNode = function(link) {
    if (this.from === link.from || this.from === link.to) {
      return this.from;
    }
    if (this.to === link.from || this.to === link.to) {
      return this.to;
    }
    return null;
  };

  return Netchart_Link;

})();

Netchart_Scene = (function(_super) {
  __extends(Netchart_Scene, _super);

  /*
   Scene change events:
     - graph
     - selection
     - coordinates
  */


  Netchart_Scene.prototype.settings = null;

  Netchart_Scene.prototype.nodes = [];

  Netchart_Scene.prototype.links = [];

  Netchart_Scene.prototype.idToNode = {};

  Netchart_Scene.prototype.idToLink = {};

  Netchart_Scene.prototype.selection = [];

  Netchart_Scene.prototype.userNodeIds = {};

  Netchart_Scene.prototype.positionedNodeIds = {};

  Netchart_Scene.prototype.hoverNode = null;

  Netchart_Scene.prototype.hoverLink = null;

  Netchart_Scene.prototype.newNodes = {};

  Netchart_Scene.prototype.newLinks = {};

  Netchart_Scene.prototype.modifiedNodes = {};

  Netchart_Scene.prototype.modifiedLinks = {};

  Netchart_Scene.prototype.deletedNodes = {};

  Netchart_Scene.prototype.deletedLinks = {};

  Netchart_Scene.prototype.enteringNodes = {};

  Netchart_Scene.prototype.enteringLinks = {};

  Netchart_Scene.prototype.exitingNodes = {};

  Netchart_Scene.prototype.exitingLinks = {};

  Netchart_Scene.prototype.centerX = 0;

  Netchart_Scene.prototype.centerY = 0;

  Netchart_Scene.prototype.zoom = 1;

  Netchart_Scene.prototype.layoutActive = true;

  function Netchart_Scene() {
    Netchart_Scene.__super__.constructor.call(this);
    this.nodes = [];
    this.links = [];
    this.userNodeIds = {};
    this.positionedNodeIds = {};
    this.selection = [];
    this.idToNode = {};
    this.idToLink = {};
    this.multilinks = null;
    this.clearModified();
  }

  Netchart_Scene.prototype.addNode = function(nodeId) {
    var node;
    if (this.idToNode.hasOwnProperty(nodeId)) {
      node = this.idToNode[nodeId];
      node.removed = false;
      if (!node.added) {
        node.added = true;
      }
    } else if (this.deletedNodes.hasOwnProperty(nodeId)) {
      node = this.deletedNodes[nodeId];
      node.removed = false;
      if (!node.added) {
        node.added = true;
      }
      this.idToNode[nodeId] = node;
      this.nodes.push(node);
      delete this.deletedNodes[nodeId];
    } else {
      node = new Netchart_Node(nodeId);
      node.added = true;
      this.idToNode[nodeId] = node;
      this.nodes.push(node);
      this.newNodes[nodeId] = node;
    }
    this.modifiedNodes[nodeId] = node;
    return node;
  };

  Netchart_Scene.prototype.touchNode = function(node) {
    return this.modifiedNodes[node.id] = node;
  };

  Netchart_Scene.prototype.removeNode = function(node) {
    var nodeId;
    nodeId = node.id;
    if (!this.idToNode.hasOwnProperty(nodeId)) {
      return;
    }
    Base_Helpers.removeFromArray(this.selection, node);
    if (this.newNodes.hasOwnProperty(node.id)) {
      return this.deleteNode(node);
    } else {
      if (!node.removed) {
        node.removed = true;
      }
      node.added = false;
      return this.modifiedNodes[nodeId] = node;
    }
  };

  Netchart_Scene.prototype.deleteNode = function(node) {
    Base_Helpers.removeFromArray(this.selection, node);
    Base_Helpers.removeFromArray(this.nodes, node);
    delete this.newNodes[node.id];
    delete this.modifiedNodes[node.id];
    delete this.idToNode[node.id];
    return this.deletedNodes[node.id] = node;
  };

  Netchart_Scene.prototype.addLink = function(linkId, from, to) {
    var link;
    if (!(this.idToNode.hasOwnProperty(from) && this.idToNode.hasOwnProperty(to))) {
      throw "Cannot add link - missing nodes";
    }
    if (this.idToLink.hasOwnProperty(linkId)) {
      link = this.idToLink[linkId];
      link.removed = false;
      if (!link.added) {
        link.added = true;
      }
    } else if (this.deletedLinks.hasOwnProperty(linkId)) {
      link = this.deletedLinks[linkId];
      delete this.deletedLinks[linkId];
      this.idToLink[linkId] = link;
      this.links.push(link);
      link.removed = false;
      if (!link.added) {
        link.added = true;
      }
    } else {
      link = new Netchart_Link();
      link.added = true;
      link.id = linkId;
      this.links.push(link);
      this.idToLink[linkId] = link;
      this.newLinks[linkId] = link;
    }
    link.from = null;
    link.to = null;
    link.multiId = from < to ? from + "#" + to : to + "#" + from;
    this.modifiedLinks[linkId] = link;
    return link;
  };

  Netchart_Scene.prototype.removeLink = function(link) {
    var linkId;
    linkId = link.id;
    if (!this.idToLink.hasOwnProperty(linkId)) {
      return;
    }
    if (this.newLinks.hasOwnProperty(linkId)) {
      return this.deleteLink(link);
    } else {
      link.added = false;
      if (!link.removed) {
        link.removed = true;
      }
      return this.modifiedLinks[linkId] = link;
    }
  };

  Netchart_Scene.prototype.deleteLink = function(link) {
    Base_Helpers.removeFromArray(this.links, link);
    if (this.newLinks.hasOwnProperty(link.id)) {
      delete this.newLinks[link.id];
    } else {
      this.deletedLinks[link.id] = link;
    }
    delete this.modifiedLinks[link.id];
    return delete this.idToLink[link.id];
  };

  Netchart_Scene.prototype.touchLink = function(link) {
    return this.modifiedLinks[link.id] = link;
  };

  Netchart_Scene.prototype.getModified = function() {
    return [this.newNodes, this.newLinks, this.modifiedNodes, this.modifiedLinks, this.deletedNodes, this.deletedLinks];
  };

  Netchart_Scene.prototype.hasTopologyChanges = function() {
    return Base_Helpers.hasProperties(this.newNodes) || Base_Helpers.hasProperties(this.newLinks) || Base_Helpers.hasProperties(this.deletedNodes) || Base_Helpers.hasProperties(this.deletedLinks);
  };

  Netchart_Scene.prototype.hasStyleChanges = function() {
    return this.hasTopologyChanges() || Base_Helpers.hasProperties(this.modifiedLinks) || Base_Helpers.hasProperties(this.modifiedNodes);
  };

  Netchart_Scene.prototype.clearModified = function() {
    this.newNodes = {};
    this.newLinks = {};
    this.modifiedNodes = {};
    this.modifiedLinks = {};
    this.deletedNodes = {};
    return this.deletedLinks = {};
  };

  Netchart_Scene.prototype.xyInChart = function(x, y) {
    return (x >= this.x0) && (x < this.x0 + this.width) && (y >= this.y0) && (y < this.y0 + this.height);
  };

  Netchart_Scene.prototype.toDisplay = function(x, y) {
    return [(x - this.centerX) * this.zoom + this.x0 + this.width * 0.5, (y - this.centerY) * this.zoom + this.y0 + this.height * 0.5];
  };

  Netchart_Scene.prototype.fromDisplay = function(x, y) {
    return [(x - this.x0 - this.width * 0.5) / this.zoom + this.centerX, (y - this.y0 - this.height * 0.5) / this.zoom + this.centerY];
  };

  Netchart_Scene.prototype.toDisplayTransform = function(x, y) {
    return [this.zoom, this.x0 + this.width * 0.5 - this.centerX * this.zoom, this.zoom, this.y0 + this.height * 0.5 - this.centerY * this.zoom];
  };

  Netchart_Scene.prototype.setActiveObject = function(obj) {
    if (this.hoverNode != null) {
      this.touchNode(this.hoverNode);
    }
    if (this.hoverLink != null) {
      this.touchLink(this.hoverLink);
    }
    this.hoverNode = null;
    this.hoverLink = null;
    if (obj instanceof Netchart_Node) {
      this.hoverNode = obj;
      return this.touchNode(this.hoverNode);
    } else if (obj instanceof Netchart_Link) {
      this.hoverLink = obj;
      return this.touchLink(this.hoverLink);
    } else if (obj !== null) {
      throw "scene.setActiveObject invalid active object type " + obj;
    }
  };

  Netchart_Scene.prototype.getVisibleBounds = function() {
    var x0, x1, y0, y1, _ref, _ref1;
    _ref = this.fromDisplay(this.x0, this.y0), x0 = _ref[0], y0 = _ref[1];
    _ref1 = this.fromDisplay(this.x0 + this.width, this.y0 + this.height), x1 = _ref1[0], y1 = _ref1[1];
    return [x0, y0, x1, y1];
  };

  Netchart_Scene.prototype.getGraphBounds = function() {
    var node, r, w, x, x0, x1, y, y0, y1, _i, _len, _ref;
    if (this.nodes.length === 0) {
      return [0, 0, 0, 0];
    }
    x0 = Infinity;
    x1 = -Infinity;
    y0 = Infinity;
    y1 = -Infinity;
    _ref = this.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (node.removed) {
        continue;
      }
      x = node.x;
      y = node.y;
      r = node.currentRadius;
      if (node.renderRadius) {
        r = node.renderRadius;
      }
      w = node.currentHwidth;
      if (node.renderHwidth) {
        w = node.renderHwidth;
      }
      w = w + r * 0.2;
      r = r * 1.2;
      x0 = Math.min(x0, x - w);
      x1 = Math.max(x1, x + w);
      y0 = Math.min(y0, y - r);
      y1 = Math.max(y1, y + r);
    }
    return [x0, y0, x1, y1];
  };

  Netchart_Scene.prototype.findNodeAt = function(displayX, displayY, tolerance) {
    var best, distanceSq, insideSq, min, n, r, toleranceSq, x, y, _i, _len, _ref, _ref1;
    _ref = this.fromDisplay(displayX, displayY), x = _ref[0], y = _ref[1];
    min = tolerance;
    best = null;
    _ref1 = this.nodes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      n = _ref1[_i];
      if (n.removed) {
        continue;
      }
      r = n.targetRadius;
      distanceSq = (x - n.x) * (x - n.x) + (y - n.y) * (y - n.y);
      toleranceSq = (r + min) * (r + min);
      if (distanceSq < toleranceSq) {
        insideSq = r * r;
        if (distanceSq < insideSq) {
          return n;
        } else {
          min = Math.sqrt(distanceSq) - r;
        }
      }
    }
    return best;
  };

  Netchart_Scene.prototype.findLinkOrNodeAt = function(displayX, displayY, tolerance) {
    var best, cx, cy, distanceSq, dr, insideSq, l, min, n, nx, ny, r, toleranceSq, w, x, x0, x1, y, y0, y1, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3, _ref4;
    _ref = this.fromDisplay(displayX, displayY), x = _ref[0], y = _ref[1];
    min = tolerance;
    best = null;
    _ref1 = this.nodes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      n = _ref1[_i];
      if (n.removed) {
        continue;
      }
      r = n.targetRadius;
      w = n.hwidth;
      nx = n.x;
      ny = n.y;
      if (r < w) {
        dr = w - r;
        _ref2 = Base_Geometry.closestPointToLine(nx - dr, ny, nx + dr, ny, x, y), nx = _ref2[0], ny = _ref2[1];
      }
      distanceSq = (x - nx) * (x - nx) + (y - ny) * (y - ny);
      toleranceSq = (r + min) * (r + min);
      if (distanceSq < toleranceSq) {
        insideSq = r * r;
        if (distanceSq < insideSq) {
          return n;
        } else {
          min = Math.sqrt(distanceSq) - r;
          best = n;
        }
      }
    }
    _ref3 = this.links;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      l = _ref3[_j];
      if (l.removed) {
        continue;
      }
      r = l.targetRadius;
      x0 = l.from.x;
      y0 = l.from.y;
      x1 = l.to.x;
      y1 = l.to.y;
      _ref4 = Base_Geometry.closestPointToLine(x0, y0, x1, y1, x, y), cx = _ref4[0], cy = _ref4[1];
      distanceSq = (x - cx) * (x - cx) + (y - cy) * (y - cy);
      toleranceSq = (r + min) * (r + min);
      if (distanceSq < toleranceSq) {
        min = Math.sqrt(distanceSq) - r;
        best = l;
      }
    }
    return best;
  };

  Netchart_Scene.prototype.updateMultilinks = function() {
    var l, link, multiId, multiLinks, _i, _len, _ref;
    if (!this.hasTopologyChanges()) {
      return;
    }
    multiLinks = {};
    _ref = this.links;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      link = _ref[_i];
      multiId = link.multiId;
      if (!multiLinks.hasOwnProperty(multiId)) {
        multiLinks[multiId] = link;
      } else {
        l = multiLinks[multiId];
        if (Base_Helpers.isArray(l)) {
          l.push(link);
        } else {
          multiLinks[multiId] = [multiLinks[multiId], link];
        }
      }
    }
    return this.multilinks = multiLinks;
  };

  return Netchart_Scene;

})(Base_Scene);

/*
//@ sourceMappingURL=Scene.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Layout;

Netchart_Layout = (function() {
  Netchart_Layout.prototype.animationPriority = 1000;

  function Netchart_Layout(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.time = null;
    this.idleSince = null;
    this.nodeMap = null;
    this.random = new Base_Random(1);
    this.springs = new Netchart_Layout_TimedSpringEmbedder(this.random);
  }

  Netchart_Layout.prototype.doAnimations = function(event) {
    var aliveProportion, animatingChanges, dt, dynamicLayout, freezeProportion, idleTimeout, majorChanges, newNodes, styleChanges, topologyChanges, _ref;
    this.settings = this.scene.settings.layout;
    idleTimeout = this.settings.layoutFreezeTimeout;
    if (!this.time || this.time + idleTimeout < event.time) {
      dt = 30;
    } else {
      dt = Math.min(1000, event.time - this.time);
    }
    this.time = event.time;
    animatingChanges = this.animateChanges(event.time, dt);
    topologyChanges = this.scene.hasTopologyChanges();
    styleChanges = this.scene.hasStyleChanges();
    if (animatingChanges || topologyChanges || event.changes.coordinates || event.changes.layout || this.idleSince === null || event.changes.bounds) {
      this.idleSince = this.time;
    }
    newNodes = {};
    majorChanges = false;
    if (topologyChanges) {
      this.random = new Base_Random(1);
      _ref = this.placeNewNodes(), newNodes = _ref[0], majorChanges = _ref[1];
    }
    dynamicLayout = this.settings.layoutMode === "dynamic";
    if ((dynamicLayout || animatingChanges) && this.idleSince + idleTimeout > this.time) {
      freezeProportion = (this.time - this.idleSince) / idleTimeout;
      aliveProportion = 1 - Math.pow(Math.max(0, (freezeProportion - 0.5) * 2), 2);
      this.doLayout(event.time, dt * aliveProportion, topologyChanges | event.changes.layout, styleChanges, newNodes, 500, majorChanges, dynamicLayout);
      this.placePies();
      event.animating = true;
    }
    if (animatingChanges) {
      return event.animating = true;
    }
  };

  Netchart_Layout.prototype.animateChanges = function(time, dt) {
    var animating, fadeProp, fadeTime, finishProp, l, link, linksToRemove, n, node, nodesToRemove, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1;
    animating = false;
    fadeTime = this.settings.fadeTime;
    fadeProp = Math.max(0, Math.pow(0.2, dt / fadeTime));
    finishProp = 0.01;
    nodesToRemove = [];
    linksToRemove = [];
    _ref = this.scene.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      if (node.added === true) {
        node.added = time;
      }
      if (node.added + fadeTime < time) {
        node.added = false;
      }
      if (node.removed === true) {
        node.removed = time;
      }
      if (node.removed) {
        animating = true;
        node.currentRadius = node.currentRadius * fadeProp;
        node.currentHwidth = node.currentHwidth * fadeProp;
        if (node.removed + fadeTime < time) {
          nodesToRemove.push(node);
        }
      } else if (node.hwidth !== node.currentHwidth) {
        animating = true;
        node.currentRadius = node.currentRadius * fadeProp + node.targetRadius * (1 - fadeProp);
        node.currentHwidth = node.currentHwidth * fadeProp + node.hwidth * (1 - fadeProp);
        if (Math.abs(node.currentRadius - node.targetRadius) < finishProp * node.targetRadius) {
          node.currentRadius = node.targetRadius;
          node.currentHwidth = node.hwidth;
        }
      }
    }
    _ref1 = this.scene.links;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      link = _ref1[_j];
      if (link.added === true) {
        link.added = time;
      }
      if (link.added + fadeTime < time) {
        link.added = false;
      }
      if (link.removed === true) {
        link.removed = time;
      }
      if (link.removed) {
        animating = true;
        link.currentRadius = link.currentRadius * fadeProp;
        if (link.removed + fadeTime < time) {
          linksToRemove.push(link);
        }
      } else if (link.targetRadius !== link.currentRadius) {
        animating = true;
        link.currentRadius = link.currentRadius * fadeProp + link.targetRadius * (1 - fadeProp);
        if (Math.abs(link.currentRadius - link.targetRadius) < finishProp * link.targetRadius) {
          link.currentRadius = link.targetRadius;
        }
      }
    }
    for (_k = 0, _len2 = linksToRemove.length; _k < _len2; _k++) {
      l = linksToRemove[_k];
      this.scene.deleteLink(l);
    }
    for (_l = 0, _len3 = nodesToRemove.length; _l < _len3; _l++) {
      n = nodesToRemove[_l];
      this.scene.deleteNode(n);
    }
    return animating;
  };

  Netchart_Layout.prototype.resetLayout = function() {
    var n, newNodes, _i, _len, _ref;
    this.random = new Base_Random(1);
    this.springs.random = this.random;
    newNodes = {};
    _ref = this.scene.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      newNodes[n.id] = n;
      n.x = 0;
      n.y = 0;
      n.userLock = false;
    }
    this.doLayout(new Date().getTime(), 1, true, true, newNodes, 10000, true);
    return this.idleSince = null;
  };

  Netchart_Layout.prototype.placeNewNodes = function() {
    var count, cx, cy, dx, dy, iln, len, link, majorChanges, n, neighbor, neighborCount, newNodes, nn, node, nx, ny, randomness, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3;
    newNodes = {};
    majorChanges = false;
    _ref = this.scene.nodes;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      n = _ref[_i];
      if (n.x === 0 && n.y === 0) {
        newNodes[n.id] = true;
      }
    }
    _ref1 = this.scene.nodes;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      n = _ref1[_j];
      randomness = 1;
      if (newNodes.hasOwnProperty(n.id)) {
        neighborCount = 0;
        cx = 0;
        cy = 0;
        randomness = 1;
        _ref2 = n.links;
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          link = _ref2[_k];
          nn = link.otherEnd(n);
          if (!newNodes.hasOwnProperty(nn.id)) {
            neighbor = nn;
            cx += nn.x;
            cy += nn.y;
            neighborCount += 1;
          }
        }
        if (neighborCount > 1) {
          nx = cx / neighborCount;
          ny = cy / neighborCount;
          randomness = 0.5;
        } else if (neighborCount === 1) {
          count = 0;
          dx = 0;
          dy = 0;
          _ref3 = neighbor.links;
          for (_l = 0, _len3 = _ref3.length; _l < _len3; _l++) {
            link = _ref3[_l];
            node = link.otherEnd(neighbor);
            if (node === n || newNodes.hasOwnProperty(node.id)) {
              continue;
            }
            dx += node.x - neighbor.x;
            dy += node.y - neighbor.y;
            count += 1;
          }
          if (count > 0) {
            len = Math.sqrt(dx * dx + dy * dy);
            if (len > 0) {
              iln = 1 / (len * count);
              dx *= iln;
              dy *= iln;
              nx = neighbor.x - dx * neighbor.currentRadius * 1.2;
              ny = neighbor.y - dy * neighbor.currentRadius * 1.2;
              randomness = 0.2;
            } else {
              nx = neighbor.x;
              ny = neighbor.y;
            }
          } else {
            majorChanges = true;
            nx = neighbor.x;
            ny = neighbor.y;
          }
        } else {
          majorChanges = true;
          nx = 0;
          ny = 0;
        }
        n.x = nx + (this.random.get() - 0.5) * randomness * (n.currentRadius + 1);
        n.y = ny + (this.random.get() - 0.5) * randomness * (n.currentRadius + 1);
      }
    }
    return [newNodes, majorChanges];
  };

  Netchart_Layout.prototype.placePies = function() {
    var PI2, angle, link, mul, node, offCenter, offset, pieLinks, sum, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _results;
    PI2 = Math.PI * 2;
    pieLinks = [];
    _ref = this.scene.nodes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      sum = 0;
      _ref1 = node.links;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        if (link.to === node && link.toPieValue > 0) {
          sum += link.toPieValue;
          pieLinks.push(link);
          link._angle = Math.atan2(link.to.y - link.from.y, link.to.x - link.from.x);
        }
      }
      if (sum > 0) {
        pieLinks.sort(function(a, b) {
          return a._angle - b._angle;
        });
        mul = PI2 / sum;
        angle = 0;
        offset = 0;
        for (_k = 0, _len2 = pieLinks.length; _k < _len2; _k++) {
          link = pieLinks[_k];
          link.toPie0 = angle;
          angle += link.toPieValue * mul;
          link.toPie1 = angle;
          offCenter = link._angle - (link.toPie0 + link.toPie1) / 2;
          if (offCenter < 0) {
            offCenter += Math.PI * 2;
          }
          offset += offCenter;
        }
        offset /= pieLinks.length;
        offset -= Math.PI;
        for (_l = 0, _len3 = pieLinks.length; _l < _len3; _l++) {
          link = pieLinks[_l];
          link.toPie0 += offset;
          link.toPie1 += offset;
        }
        _results.push(pieLinks = []);
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Layout.prototype.doLayout = function(time, dt, topologyChanges, styleChanges, newNodes, timeout, reset, incremental) {
    var appearingNodes, aspect, degreeModifier, fadeTime, hasOtherConnections, l, length, ml, mlid, multilinks, n, nodeSpacing, nodes, realLinks, s1, strength, visibility, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref;
    if (reset == null) {
      reset = false;
    }
    if (incremental == null) {
      incremental = true;
    }
    fadeTime = this.scene.settings.layout.fadeTime;
    aspect = null;
    if (this.scene.settings.interaction.zooming.autoZoom) {
      aspect = (this.scene.width + 1) / (this.scene.height + 1);
    }
    nodeSpacing = this.settings.nodeSpacing;
    degreeModifier = 1;
    nodes = this.scene.nodes;
    appearingNodes = false;
    for (_i = 0, _len = nodes.length; _i < _len; _i++) {
      n = nodes[_i];
      n.locked = n.userLock || n.locks > 0;
      appearingNodes || (appearingNodes = n.added || n.removed);
      if (n.added) {
        n.visibility = 1 - 0.8 * (time - n.added) / fadeTime;
      } else if (n.removed) {
        n.visibility = 0.2 + 0.8 * (time - n.removed) / fadeTime;
      } else {
        n.visibility = 1;
      }
    }
    multilinks = {};
    realLinks = [];
    _ref = this.scene.links;
    for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
      l = _ref[_j];
      mlid = l.multiId;
      strength = l.targetStrength;
      length = l.targetLength;
      visibility = 1;
      if (l.removed || l.added) {
        hasOtherConnections = l.from.links.length > 1 && l.to.links.length > 1;
        if (hasOtherConnections || l.removed) {
          s1 = 0.2;
        } else {
          s1 = strength;
        }
        if (l.removed) {
          visibility = 1 - (time - l.removed) / fadeTime;
        }
        if (l.added) {
          visibility = (time - l.added) / fadeTime;
          length = 0.2 + (length - 0.2) * visibility;
        }
        strength = strength * visibility + s1 * (1 - visibility);
      }
      if (!multilinks.hasOwnProperty(mlid)) {
        ml = {
          from: l.from,
          to: l.to,
          strength: strength,
          length: length,
          visibility: visibility
        };
        multilinks[mlid] = ml;
        realLinks.push(ml);
      } else {
        ml = multilinks[mlid];
        ml.strength = Math.max(strength, ml.strength);
        ml.length = Math.max(length, ml.length);
        ml.visibility = Math.max(visibility, ml.visibility);
      }
    }
    this.springs.updateParams(nodeSpacing, degreeModifier, aspect);
    if (reset || Base_Helpers.hasProperties(newNodes)) {
      for (_k = 0, _len2 = nodes.length; _k < _len2; _k++) {
        n = nodes[_k];
        n.locked || (n.locked = !newNodes.hasOwnProperty(n.id));
      }
      this.springs.updateGraph(nodes, realLinks, topologyChanges);
      if (reset || this.scene.settings.layout.globalLayoutOnChanges) {
        this.springs.globalLayout(nodes, timeout, reset);
      } else {
        this.springs.timedLayout(nodes, dt * 0.001);
      }
    }
    if (incremental || appearingNodes) {
      if (!incremental) {
        for (_l = 0, _len3 = nodes.length; _l < _len3; _l++) {
          n = nodes[_l];
          n.locked || (n.locked = !n.removed && !n.added);
        }
      }
      this.springs.updateGraph(nodes, realLinks, topologyChanges);
      return this.springs.timedLayout(nodes, dt * 0.001);
    }
  };

  return Netchart_Layout;

})();

/*
//@ sourceMappingURL=Layout.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Layers;

Netchart_Layers = (function() {
  Netchart_Layers.prototype.scene = null;

  Netchart_Layers.prototype.container = null;

  Netchart_Layers.prototype.background = null;

  Netchart_Layers.prototype.canvas = null;

  Netchart_Layers.prototype.outerBorder = null;

  Netchart_Layers.prototype.mouseTrackLayer = null;

  function Netchart_Layers(scene) {
    this.scene = scene;
    this.container = Base_Helpers.createDom("div", "DVSL-container");
    this.container.style.position = "relative";
    this.container.style.width = "100%";
    this.container.style.height = "100%";
    this.background = Base_Helpers.createDom("div", "DVSL-background", null, this.container);
    this.setContainerStyle(this.background);
    this.canvas = Base_Helpers.createDom("canvas", "NetChart-canvas", null, this.container);
    this.setContainerStyle(this.canvas);
    this.outerBorder = Base_Helpers.createDom("div", "DVSL-border", null, this.container);
    this.setContainerStyle(this.outerBorder);
    this.resizerBar = Base_Helpers.createDom("div", "DVSL-resizer", null, this.container);
    this.mouseTrackLayer = Base_Helpers.createDom("div", null, null, this.container);
    this.setContainerStyle(this.mouseTrackLayer);
    this.updateSettings(this.scene.settings, "init");
    this.updateSize();
  }

  Netchart_Layers.prototype.updateSize = function() {
    var setHeight, setWidth;
    setWidth = this.scene.settings.width;
    setHeight = this.scene.settings.height;
    if (this.scene.chartWidth > this.scene.settings.container.clientWidth) {
      setWidth = this.scene.chartWidth;
    }
    if (this.scene.chartHeight > this.scene.settings.container.clientHeight) {
      setHeight = this.scene.chartHeight;
    }
    if (setWidth) {
      this.container.style.width = "" + setWidth + "px";
    }
    if (setHeight) {
      this.container.style.height = "" + setHeight + "px";
    }
    this.resizerBar.style.width = "" + this.scene.width + "px";
    return this.resizerBar.style.left = "" + this.scene.x0 + "px";
  };

  Netchart_Layers.prototype.updateSettings = function(changes) {
    if (Base_Helpers.hasProp(changes, "advanced/themeCSSClass")) {
      if (this.curTheme != null) {
        Base_Helpers.removeClass(this.container, this.curTheme);
      }
      this.curTheme = this.scene.settings.advanced.themeCSSClass;
      return Base_Helpers.addClass(this.container, this.curTheme);
    }
  };

  Netchart_Layers.prototype.setContainerStyle = function(c) {
    c.style.position = "absolute";
    c.style.left = "0px";
    c.style.right = "0px";
    c.style.top = "0px";
    return c.style.bottom = "0px";
  };

  return Netchart_Layers;

})();

/*
//@ sourceMappingURL=Layers.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Styles;

Netchart_Styles = (function() {
  Netchart_Styles.prototype.animationPriority = 1003;

  function Netchart_Styles(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.time = null;
  }

  Netchart_Styles.prototype.sortRules = function(rules) {
    var name, names, _;
    names = (function() {
      var _results;
      _results = [];
      for (name in rules) {
        _ = rules[name];
        _results.push(name);
      }
      return _results;
    })();
    names.sort();
    return (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = names.length; _i < _len; _i++) {
        name = names[_i];
        _results.push(rules[name]);
      }
      return _results;
    })();
  };

  Netchart_Styles.prototype.doAnimations = function(event) {
    var fadeout, id2, id3, link, link1, node, node1, _i, _j, _len, _len1, _ref, _ref1, _ref2, _ref3;
    if (!(event.changes.settings || Base_Helpers.hasProperties(this.scene.modifiedNodes) || Base_Helpers.hasProperties(this.scene.modifiedLinks))) {
      return;
    }
    this.nodeRules = this.sortRules(this.scene.settings.style.nodeRules);
    this.linkRules = this.sortRules(this.scene.settings.style.linkRules);
    this.nodeRadiusChanged = Base_Helpers.hasProperties(this.scene.newNodes) | Base_Helpers.hasProperties(this.scene.deletedNodes);
    this.linkRadiusChanged = Base_Helpers.hasProperties(this.scene.newLinks) | Base_Helpers.hasProperties(this.scene.deletedLinks);
    fadeout = this.scene.settings.navigation.mode === "focusnodes" && this.scene.settings.navigation.focusAutoFadeout;
    if (event.changes.settings) {
      this.nodeRadiusChanged = true;
      this.linkRadiusChanged = true;
      _ref = this.scene.nodes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        node = _ref[_i];
        this.updateNode(node, fadeout);
      }
      _ref1 = this.scene.links;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        link = _ref1[_j];
        this.updateLink(link, fadeout);
      }
    } else {
      _ref2 = this.scene.modifiedNodes;
      for (id2 in _ref2) {
        node1 = _ref2[id2];
        this.updateNode(node1, fadeout);
      }
      _ref3 = this.scene.modifiedLinks;
      for (id3 in _ref3) {
        link1 = _ref3[id3];
        this.updateLink(link1, fadeout);
      }
    }
    if (this.nodeRadiusChanged || (fadeout && event.changes.navigation)) {
      this.computeRadiuses(this.scene.nodes, this.scene.settings.style.nodeAutoScaling, this.scene.settings.style.nodeRadiusExtent, fadeout);
    }
    this.computeNodeWidths(this.scene.nodes, event.context);
    if (this.linkRadiusChanged || (fadeout && event.changes.navigation)) {
      this.computeRadiuses(this.scene.links, this.scene.settings.style.linkAutoScaling, this.scene.settings.style.linkRadiusExtent, fadeout);
      this.computeStrengths(this.scene.links, this.scene.settings.style.linkStrengthAutoScaling, this.scene.settings.style.linkStrengthExtent);
      this.computeLengths(this.scene.links, this.scene.settings.style.linkLengthAutoScaling, this.scene.settings.style.linkLengthExtent);
      return this.scene.links.sort(function(a, b) {
        if (a.targetRadius === b.targetRadius) {
          return 0;
        }
        if (a.targetRadius > b.targetRadius) {
          return 1;
        } else {
          return -1;
        }
      });
    }
  };

  Netchart_Styles.prototype.updateNode = function(node, fadeout) {
    var active, l, originalRadius, removedColor, _i, _len, _ref;
    active = node === this.scene.hoverNode;
    originalRadius = node.radius;
    Base_Helpers.extend(node, this.scene.settings.style.node);
    if (!node.radius) {
      node.radius = 10;
    }
    node.label = node.id;
    node.labelStyle = this.scene.settings.style.nodeLabel;
    node.labelBackground = this.scene.settings.style.nodeLabelBalloon;
    if (node.userLock) {
      Base_Helpers.extend(node, this.scene.settings.style.nodeLocked);
    }
    if (node.expanded) {
      Base_Helpers.extend(node, this.scene.settings.style.nodeExpanded);
    }
    if (node.focused) {
      Base_Helpers.extend(node, this.scene.settings.style.nodeFocused);
    }
    if (node.data) {
      if (node.data.error != null) {
        node.label = node.data.error;
        node.fillColor = "red";
      }
      if (node.data.style) {
        Base_Helpers.extend(node, node.data.style);
      }
      this.applyStyleRules(node, this.nodeRules);
      if (!Base_Helpers.isNumber(node.radius)) {
        node.radius = 10;
      }
    }
    if (node.removed) {
      node.fillColor = this.scene.settings.style.removedColor;
    }
    if (active) {
      Base_Helpers.extend(node, this.scene.settings.style.hoverStyle);
    }
    _ref = node.links;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      l = _ref[_i];
      this.updateLink(l, fadeout);
    }
    if (originalRadius !== node.radius) {
      this.nodeRadiusChanged = true;
    }
    if (fadeout && node.relevance < 1) {
      removedColor = this.scene.settings.style.removedColor;
      if (node.fillColor) {
        node.fillColor = Base_Graphics.blendColors(removedColor, node.fillColor, node.relevance);
      }
      if (node.lineColor) {
        node.lineColor = Base_Graphics.blendColors(removedColor, node.lineColor, node.relevance);
      }
    }
    return true;
  };

  Netchart_Styles.prototype.updateLink = function(link, fadeout) {
    var active, originalRadius, removedColor;
    originalRadius = link.radius;
    Base_Helpers.extend(link, this.scene.settings.style.link);
    link.label = null;
    link.labelStyle = this.scene.settings.style.linkLabel;
    link.labelBackground = this.scene.settings.style.linkLabelBalloon;
    link.radius = 1;
    active = link === this.scene.hoverLink || link.from === this.scene.hoverNode || link.to === this.scene.hoverNode;
    if (link.data.style) {
      Base_Helpers.extend(link, link.data.style);
    }
    this.applyStyleRules(link, this.linkRules);
    if (!Base_Helpers.isNumber(link.radius)) {
      link.radius = 1;
    }
    if (active) {
      Base_Helpers.extend(link, this.scene.settings.style.hoverStyle);
      if (link.from === this.scene.hoverNode) {
        link.toPieColor = link.fillColor;
      }
    }
    if (link.removed) {
      link.fillColor = this.scene.settings.style.removedColor;
    }
    if (originalRadius !== link.radius) {
      this.linkRadiusChanged = true;
    }
    if (fadeout && link.relevance < 1) {
      removedColor = this.scene.settings.style.removedColor;
      if (link.fillColor) {
        link.fillColor = Base_Graphics.blendColors(removedColor, link.fillColor, link.relevance);
      }
      if (link.lineColor) {
        link.lineColor = Base_Graphics.blendColors(removedColor, link.lineColor, link.relevance);
      }
      return link.length = 0.2 + (link.length - 0.2) * link.relevance;
    }
  };

  Netchart_Styles.prototype.applyStyleRules = function(obj, rules) {
    var func, _i, _len, _results;
    _results = [];
    for (_i = 0, _len = rules.length; _i < _len; _i++) {
      func = rules[_i];
      _results.push(func(obj));
    }
    return _results;
  };

  Netchart_Styles.prototype.computeRadiuses = function(objects, mode, extents, fadeout) {
    var add, max, maxE, min, minE, mul, obj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _results;
    minE = extents[0], maxE = extents[1];
    if (mode === "linear" || mode === "logarithmic") {
      min = Infinity;
      max = -Infinity;
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (!obj.removed) {
          min = Math.min(min, obj.radius);
          max = Math.max(max, obj.radius);
        }
      }
      if (min >= max) {
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          obj = objects[_j];
          if (!obj.removed) {
            obj.targetRadius = minE;
          }
        }
      } else if (mode === "linear") {
        mul = (maxE - minE) / (max - min);
        add = maxE - max * mul;
        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
          obj = objects[_k];
          if (!obj.removed) {
            obj.targetRadius = obj.radius * mul + add;
          }
        }
      } else {
        min = Math.max(0.0001, min);
        max = Math.max(min + 0.0001, max);
        mul = (maxE - minE) / Math.log(max / min);
        add = maxE - mul * Math.log(max);
        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
          obj = objects[_l];
          if (!obj.removed) {
            obj.targetRadius = Math.log(Math.max(0.0001, obj.radius)) * mul + add;
          }
        }
      }
    } else {
      for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
        obj = objects[_m];
        if (!obj.removed) {
          obj.targetRadius = Math.min(Math.max(minE, obj.radius), maxE);
        }
      }
    }
    if (fadeout) {
      _results = [];
      for (_n = 0, _len5 = objects.length; _n < _len5; _n++) {
        obj = objects[_n];
        if (obj.relevance < 1) {
          _results.push(obj.targetRadius = obj.targetRadius * obj.relevance);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Netchart_Styles.prototype.computeNodeWidths = function(nodes, g) {
    var hh, n, r, w, ww, _i, _j, _len, _len1, _results, _results1;
    if (this.scene.settings.style.nodeDisplay === "image") {
      _results = [];
      for (_i = 0, _len = nodes.length; _i < _len; _i++) {
        n = nodes[_i];
        _results.push(n.hwidth = n.targetRadius);
      }
      return _results;
    } else {
      _results1 = [];
      for (_j = 0, _len1 = nodes.length; _j < _len1; _j++) {
        n = nodes[_j];
        r = n.targetRadius;
        w = 0;
        if (n.image) {
          w += r;
        }
        if (n.label) {
          if (n.labelStyle.font) {
            g.font = n.labelStyle.font;
          } else {
            g.font = null;
          }
          hh = g.measureText("M").width;
          ww = g.measureText(n.label).width;
          ww = ww * 1.6 / 2;
          w += (ww / hh + 0.6) * r;
        }
        _results1.push(n.hwidth = Math.max(w, r));
      }
      return _results1;
    }
  };

  Netchart_Styles.prototype.computeStrengths = function(objects, mode, extents) {
    var add, max, maxE, min, minE, mul, obj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _results, _results1, _results2, _results3;
    minE = extents[0], maxE = extents[1];
    if (mode === "linear" || mode === "logarithmic") {
      min = Infinity;
      max = -Infinity;
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (!obj.removed) {
          min = Math.min(min, obj.strength);
          max = Math.max(max, obj.strength);
        }
      }
      if (min >= max) {
        _results = [];
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          obj = objects[_j];
          if (!obj.removed) {
            _results.push(obj.targetStrength = minE);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else if (mode === "linear") {
        mul = (maxE - minE) / (max - min);
        add = maxE - max * mul;
        _results1 = [];
        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
          obj = objects[_k];
          if (!obj.removed) {
            _results1.push(obj.targetStrength = obj.strength * mul + add);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      } else {
        min = Math.max(0.0001, min);
        max = Math.max(min + 0.0001, max);
        mul = (maxE - minE) / Math.log(max / min);
        add = maxE - mul * Math.log(max);
        _results2 = [];
        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
          obj = objects[_l];
          if (!obj.removed) {
            _results2.push(obj.targetStrength = Math.log(Math.max(0.0001, obj.strength)) * mul + add);
          } else {
            _results2.push(void 0);
          }
        }
        return _results2;
      }
    } else {
      _results3 = [];
      for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
        obj = objects[_m];
        if (!obj.removed) {
          _results3.push(obj.targetStrength = Math.min(Math.max(minE, obj.strength), maxE));
        } else {
          _results3.push(void 0);
        }
      }
      return _results3;
    }
  };

  Netchart_Styles.prototype.computeLengths = function(objects, mode, extents) {
    var add, max, maxE, min, minE, mul, obj, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _results, _results1, _results2, _results3;
    minE = extents[0], maxE = extents[1];
    if (mode === "linear" || mode === "logarithmic") {
      min = Infinity;
      max = -Infinity;
      for (_i = 0, _len = objects.length; _i < _len; _i++) {
        obj = objects[_i];
        if (!obj.removed) {
          min = Math.min(min, obj.length);
          max = Math.max(max, obj.length);
        }
      }
      if (min >= max) {
        _results = [];
        for (_j = 0, _len1 = objects.length; _j < _len1; _j++) {
          obj = objects[_j];
          if (!obj.removed) {
            _results.push(obj.targetLength = minE);
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      } else if (mode === "linear") {
        mul = (maxE - minE) / (max - min);
        add = maxE - max * mul;
        _results1 = [];
        for (_k = 0, _len2 = objects.length; _k < _len2; _k++) {
          obj = objects[_k];
          if (!obj.removed) {
            _results1.push(obj.targetLength = obj.length * mul + add);
          } else {
            _results1.push(void 0);
          }
        }
        return _results1;
      } else {
        min = Math.max(0.0001, min);
        max = Math.max(min + 0.0001, max);
        mul = (maxE - minE) / Math.log(max / min);
        add = maxE - mul * Math.log(max);
        _results2 = [];
        for (_l = 0, _len3 = objects.length; _l < _len3; _l++) {
          obj = objects[_l];
          if (!obj.removed) {
            _results2.push(obj.targetLength = Math.log(Math.max(0.0001, obj.length)) * mul + add);
          } else {
            _results2.push(void 0);
          }
        }
        return _results2;
      }
    } else {
      _results3 = [];
      for (_m = 0, _len4 = objects.length; _m < _len4; _m++) {
        obj = objects[_m];
        if (!obj.removed) {
          _results3.push(obj.targetLength = Math.min(Math.max(minE, obj.length), maxE));
        } else {
          _results3.push(void 0);
        }
      }
      return _results3;
    }
  };

  return Netchart_Styles;

})();

/*
//@ sourceMappingURL=Styles.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_ZoomControl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Netchart_ZoomControl = (function() {
  function Netchart_ZoomControl(chart) {
    var cont, mouse, nav, zoom;
    this.chart = chart;
    this.freeze = __bind(this.freeze, this);
    this.resetLayout = __bind(this.resetLayout, this);
    this.zoomToFit = __bind(this.zoomToFit, this);
    this.zoomMove = __bind(this.zoomMove, this);
    this.zoomDown = __bind(this.zoomDown, this);
    this.scene = chart.scene;
    this.events = chart.events;
    this.scrolling = this.chart.scrolling;
    cont = Base_Helpers.createDom("div", "DVSL-NC-zoom", null, this.chart.layers.container);
    zoom = Base_Helpers.createDom("span", null, null, cont);
    this.handle = Base_Helpers.createDom("em", null, null, zoom);
    nav = Base_Helpers.createDom("nav", null, null, cont);
    this.fit = Base_Helpers.createDom("a", "DVSL-NC-zoom-fit", "Fit to screen", nav);
    this.fit.title = "Fit to screen";
    this.rearrange = Base_Helpers.createDom("a", "DVSL-NC-zoom-rearrange", "Rearrange elements", nav);
    this.rearrange.title = "Rearrange elements";
    this.lock = Base_Helpers.createDom("a", "DVSL-NC-zoom-lock-all", "Locak all", nav);
    this.lock.title = "Lock all";
    this.lock.onclick = this.freeze;
    this.rearrange.onclick = this.resetLayout;
    this.fit.onclick = this.zoomToFit;
    mouse = new Base_MouseEvents(cont, this.scene.settings.advanced.pointer);
    mouse.listen("drag", this.zoomMove);
    mouse.listen("down", this.zoomDown);
  }

  Netchart_ZoomControl.prototype.zoomDown = function(event) {
    if (event.y < 100) {
      return this.zoomMove(event);
    }
  };

  Netchart_ZoomControl.prototype.zoomMove = function(event) {
    var newZoom, pos;
    pos = event.y - 10;
    pos = Math.max(0, Math.min(80, pos));
    this.handle.style.top = "" + pos + "px";
    newZoom = this.getZoomValue(pos / 80);
    this.scrolling.zoom(newZoom / this.scene.zoom);
    this.events.notifySceneChanges({
      position: true
    });
    return event.consumed = true;
  };

  Netchart_ZoomControl.prototype.getSliderPosition = function() {
    var max, min, zoom, _ref;
    _ref = this.scene.settings.interaction.zooming.zoomExtent, min = _ref[0], max = _ref[1];
    min = Math.log(min);
    max = Math.log(max);
    zoom = Math.log(this.scene.zoom);
    return 1 - (zoom - min) / (max - min);
  };

  Netchart_ZoomControl.prototype.getZoomValue = function(pos) {
    var max, min, prop, _ref;
    _ref = this.scene.settings.interaction.zooming.zoomExtent, min = _ref[0], max = _ref[1];
    min = Math.log(min);
    max = Math.log(max);
    prop = (1 - pos) * (max - min) + min;
    return Math.exp(prop);
  };

  Netchart_ZoomControl.prototype.zoomToFit = function(event) {
    if (this.scene.settings.interaction.zooming.autoZoom) {
      this.scene.settings.interaction.zooming.autoZoom = false;
    } else {
      this.scene.settings.interaction.zooming.autoZoom = true;
      this.events.notifySceneChanges({
        position: true
      });
    }
    return event.preventDefault();
  };

  Netchart_ZoomControl.prototype.resetLayout = function(event) {
    this.chart.layout.resetLayout();
    this.scene.settings.layout.layoutMode = "dynamic";
    this.scene.settings.interaction.zooming.autoZoom = true;
    this.chart.scrolling.zoomToFit();
    this.events.notifySceneChanges({
      position: true,
      layout: true
    });
    return event.preventDefault();
  };

  Netchart_ZoomControl.prototype.freeze = function(event) {
    if (this.scene.settings.layout.layoutMode === "dynamic") {
      this.scene.settings.layout.layoutMode = "static";
    } else {
      this.scene.settings.layout.layoutMode = "dynamic";
    }
    this.events.notifySceneChanges({
      layout: true
    });
    return event.preventDefault();
  };

  Netchart_ZoomControl.prototype.doAnimations = function(event) {
    var value;
    value = this.getSliderPosition();
    this.handle.style.top = "" + (80 * value) + "px";
    if (this.scene.settings.interaction.zooming.autoZoom) {
      Base_Helpers.setClass(this.fit, "DVSL-NC-zoom-fit-active");
    } else {
      Base_Helpers.setClass(this.fit, "DVSL-NC-zoom-fit");
    }
    if (this.scene.settings.layout.layoutMode === "dynamic") {
      return Base_Helpers.setClass(this.lock, "DVSL-NC-zoom-lock-all");
    } else {
      return Base_Helpers.setClass(this.lock, "DVSL-NC-zoom-lock-all-active");
    }
  };

  return Netchart_ZoomControl;

})();

/*
//@ sourceMappingURL=ZoomControl.map
*/

// Generated by CoffeeScript 1.6.3
/*
  Mouse events - have base properties from Base_MouseEvents.
  Additional properties:
  consumed = false, if true - the target tool will be set as active and recieve all future events exclusively until consumed is no longer set.
  cursor = null, cursor to use, (only when consumed = true)
  changes = {}, changes made in scene.
*/

var Base_ChartElement, Base_ChartEvents, Base_SceneEvent,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Base_SceneEvent = (function() {
  function Base_SceneEvent() {}

  Base_SceneEvent.prototype.time = 0;

  Base_SceneEvent.prototype.animating = false;

  Base_SceneEvent.prototype.changes = {};

  return Base_SceneEvent;

})();

Base_ChartElement = (function() {
  function Base_ChartElement() {}

  Base_ChartElement.prototype.animationPriority = 0;

  Base_ChartElement.prototype.remove = function() {
    return false;
  };

  Base_ChartElement.prototype.doAnimations = function(sceneEvent) {
    return false;
  };

  Base_ChartElement.prototype.paintScene = function(sceneEvent) {
    return false;
  };

  Base_ChartElement.prototype.onSceneChange = function(event) {
    return false;
  };

  Base_ChartElement.prototype.onClick = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onRClick = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onDoubleClick = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerDown = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerUp = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerDrag = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerMove = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerOut = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onPointerCancel = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onWheel = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.onKeyDown = function(keyEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewWheel = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerDown = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerUp = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerDrag = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerMove = function(mouseEvent) {
    return false;
  };

  Base_ChartElement.prototype.previewPointerOut = function(mouseEvent) {
    return false;
  };

  return Base_ChartElement;

})();

Base_ChartEvents = (function() {
  "use strict";
  Base_ChartEvents.prototype.container = null;

  Base_ChartEvents.prototype.paintRequested = false;

  Base_ChartEvents.prototype.mouseEvents = null;

  Base_ChartEvents.prototype.verbose = false;

  function Base_ChartEvents(container, canvas, chart) {
    this.container = container;
    this.canvas = canvas;
    this.chart = chart;
    this._paintScene = __bind(this._paintScene, this);
    this.kd = __bind(this.kd, this);
    this.mw = __bind(this.mw, this);
    this.mdbl = __bind(this.mdbl, this);
    this.rcl = __bind(this.rcl, this);
    this.mcl = __bind(this.mcl, this);
    this.mcc = __bind(this.mcc, this);
    this.mlve = __bind(this.mlve, this);
    this.mmve = __bind(this.mmve, this);
    this.mdrg = __bind(this.mdrg, this);
    this.mup = __bind(this.mup, this);
    this.mdwn = __bind(this.mdwn, this);
    this.scene = this.chart.scene;
    this.settings = this.chart.settings;
    this.elements = [];
    this.elementsReverse = [];
    this.pointerToElement = {};
    this.sceneChanges = {};
    this.animationOrder = [];
    this.hooks = {};
    this.mouseEvents = new Base_MouseEvents(this.container, this.settings.advanced.pointer, this.chart, this.whiteList);
    this.mouseEvents.listen(this.mouseEvents.EVENT_DOWN, this.mdwn);
    this.mouseEvents.listen(this.mouseEvents.EVENT_UP, this.mup);
    this.mouseEvents.listen(this.mouseEvents.EVENT_DRAG, this.mdrg);
    this.mouseEvents.listen(this.mouseEvents.EVENT_MOVE, this.mmve);
    this.mouseEvents.listen(this.mouseEvents.EVENT_LEAVE, this.mlve);
    this.mouseEvents.listen(this.mouseEvents.EVENT_CANCEL, this.mcc);
    this.mouseEvents.listen(this.mouseEvents.EVENT_CLICK, this.mcl);
    this.mouseEvents.listen(this.mouseEvents.EVENT_RCLICK, this.rcl);
    this.mouseEvents.listen(this.mouseEvents.EVENT_DBLCLICK, this.mdbl);
    this.mouseEvents.listen(this.mouseEvents.EVENT_WHEEL, this.mw);
    Base_Helpers.listen(this.container, "keydown", this.kd);
  }

  Base_ChartEvents.prototype.addWhiteList = function(item) {
    return this.mouseEvents.addWhiteList(item);
  };

  Base_ChartEvents.prototype.remove = function() {
    this.mouseEvents.remove();
    return Base_Helpers.unlisten(this.container, "keydown", this.kd);
  };

  Base_ChartEvents.prototype.setScaling = function(x, y) {
    this.mouseEvents.scaleX = x;
    return this.mouseEvents.scaleY = y;
  };

  Base_ChartEvents.prototype.addElement = function(element) {
    element.animationPriority = element.animationPriority || 0;
    this.elements.push(element);
    this.elementsReverse.splice(0, 0, element);
    this.animationOrder = this.elements.slice(0);
    this.animationOrder.sort(function(a, b) {
      return b.animationPriority - a.animationPriority;
    });
    return element;
  };

  Base_ChartEvents.prototype.removeElement = function(element) {
    Base_Helpers.removeFromArray(this.elements, element);
    Base_Helpers.removeFromArray(this.animationOrder, element);
    return Base_Helpers.removeFromArray(this.elementsReverse, element);
  };

  Base_ChartEvents.prototype.notifySceneChanges = function(changes) {
    if (!Base_Helpers.hasProperties(changes)) {
      return;
    }
    Base_Helpers.extendDeep(this.sceneChanges, changes);
    return this._requestPaint();
  };

  Base_ChartEvents.prototype.addHook = function(obj, hook, callback) {
    if (typeof this.hooks[hook] === "undefined") {
      this.hooks[hook] = [];
    }
    return this.hooks[hook].push({
      obj: obj,
      callback: callback
    });
  };

  Base_ChartEvents.prototype.hook = function(hook, arg, caller) {
    var v, _i, _len, _ref, _results;
    this.chart.log("firing hook", {
      hook: hook,
      arg: arg,
      caller: caller
    });
    if (this.hooks[hook]) {
      _ref = this.hooks[hook];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _results.push(v.callback.call(v.obj, hook, arg, caller));
      }
      return _results;
    }
  };

  Base_ChartEvents.prototype.mdwn = function(event) {
    var element;
    element = this._notify(event, "PointerDown");
    this.pointerToElement[event.identifier] = element;
    this.notifySceneChanges(event.changes);
    return this.container.focus();
  };

  Base_ChartEvents.prototype.mup = function(event) {
    this._notify(event, "PointerUp");
    this.pointerToElement[event.identifier] = null;
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.mdrg = function(event) {
    var element;
    element = this._notify(event, "PointerDrag");
    this.pointerToElement[event.identifier] = element;
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.mmve = function(event) {
    var element;
    element = this._notify(event, "PointerMove");
    this.pointerToElement[event.identifier] = element;
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.mlve = function(event) {
    this._notify(event, "PointerOut");
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.mcc = function(event) {
    this._notify(event, "PointerCancel");
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.mcl = function(event) {
    this._notify(event, "Click");
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.rcl = function(event) {
    this._notify(event, "RightClick");
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.mdbl = function(event) {
    this._notify(event, "DoubleClick");
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.mw = function(event) {
    this._notify(event, "Wheel");
    return this.notifySceneChanges(event.changes);
  };

  Base_ChartEvents.prototype.kd = function(event) {
    if (!event.keyCode) {
      event.keyCode = event.which;
    }
    this._notifyKeyEvent(event, "KeyDown");
    this.notifySceneChanges(event.changes);
    if (event.consumed) {
      return event.preventDefault();
    }
  };

  Base_ChartEvents.prototype._notify = function(event, name) {
    var element, firstCursor, funcName, _i, _j, _len, _len1, _ref, _ref1;
    event.changes = {};
    event.consumed = false;
    event.noDefault = false;
    event.cursor = null;
    funcName = "preview" + name;
    _ref = this.elementsReverse;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      if (element[funcName] != null) {
        element[funcName].call(element, event);
      }
    }
    funcName = "on" + name;
    element = this.pointerToElement[event.identifier];
    if (element) {
      if (element[funcName] != null) {
        element[funcName].call(element, event);
        if (event.consumed) {
          if (event.cursor) {
            this.container.style.cursor = event.cursor;
          }
          if (this.verbose) {
            console.log("" + name + ": " + event.identifier + ", c=" + event.consumed);
          }
          return element;
        }
      }
    }
    firstCursor = null;
    _ref1 = this.elementsReverse;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      element = _ref1[_j];
      if (element[funcName] != null) {
        element[funcName].call(element, event);
        if (event.consumed) {
          if (event.cursor) {
            this.container.style.cursor = event.cursor;
          }
          if (this.verbose) {
            console.log("" + name + ": " + event.identifier + ", c=" + event.consumed);
          }
          return element;
        } else if ((firstCursor == null) && (event.cursor != null)) {
          firstCursor = event.cursor;
        }
      }
    }
    this.container.style.cursor = firstCursor;
    event.consumed || (event.consumed = event.noDefault);
    if (this.verbose) {
      console.log("" + name + ": " + event.identifier + ", c=" + event.consumed);
    }
    return null;
  };

  Base_ChartEvents.prototype._notifyKeyEvent = function(event, name) {
    var element, funcName, _i, _len, _ref;
    event.changes = {};
    event.consumed = false;
    event.cursor = null;
    funcName = "on" + name;
    _ref = this.elementsReverse;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      element = _ref[_i];
      if (element[funcName] != null) {
        element[funcName].call(element, event);
        if (event.consumed) {
          break;
        }
      }
    }
    return null;
  };

  Base_ChartEvents.prototype._requestPaint = function() {
    if (!this.paintRequested) {
      requestAnimationFrame(this._paintScene);
      return this.paintRequested = true;
    }
  };

  Base_ChartEvents.prototype._paintScene = function() {
    var e, el, event, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
    if (this.chart.removed) {
      return;
    }
    this.paintRequested = false;
    event = new Base_SceneEvent();
    event.time = new Date().getTime();
    event.changes = this.sceneChanges;
    event["export"] = false;
    this.sceneChanges = {};
    _ref = this.elementsReverse;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      el = _ref[_i];
      if (el.onSceneChange != null) {
        el.onSceneChange(event);
      }
    }
    event.context = this.prepareContext(event);
    _ref1 = this.animationOrder;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      e = _ref1[_j];
      if (e.doAnimations != null) {
        e.doAnimations(event);
      }
    }
    _ref2 = this.elements;
    for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
      e = _ref2[_k];
      if (e.paintScene != null) {
        e.paintScene(event);
      }
    }
    if (event.animating) {
      return this._requestPaint();
    }
  };

  Base_ChartEvents.prototype.prepareContext = function(event) {
    var context, heightPx, scene, widthPx;
    if (event.changes.bounds) {
      scene = this.chart.scene;
      this.scaleX = Math.min(scene.canvasScaleX, scene.settings.advanced.maxCanvasWidth / scene.chartWidth);
      this.scaleY = Math.min(scene.canvasScaleY, scene.settings.advanced.maxCanvasHeight / scene.chartHeight);
      widthPx = Math.round(scene.chartWidth * this.scaleX);
      heightPx = Math.round(scene.chartHeight * this.scaleY);
      this.canvas.width = widthPx;
      this.canvas.height = heightPx;
      this.canvas.style.width = "" + scene.chartWidth + "px";
      this.canvas.style.height = "" + scene.chartHeight + "px";
    }
    context = this.canvas.getContext("2d");
    context.setTransform(1, 0, 0, 1, 0, 0);
    context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    Base_Graphics.rectStyle(context, this.settings.area.style);
    context.fillRect(0, 0, this.canvas.width, this.canvas.height);
    context.setTransform(this.scaleX, 0, 0, this.scaleY, 0, 0);
    return context;
  };

  Base_ChartEvents.prototype.exportGetDimensions = function(dimensions) {
    var bounds, chartHeight, chartWidth, height, pixelsPerMM, scale, width;
    bounds = this.scene.getChartBounds();
    chartWidth = bounds.right - bounds.left;
    chartHeight = bounds.bottom - bounds.top;
    width = parseFloat(dimensions.width);
    height = parseFloat(dimensions.height);
    if (width > 0 && height > 0) {
      scale = Math.min(width / chartWidth, height / chartHeight);
    } else if (width > 0) {
      scale = width / chartWidth;
      height = chartHeight * scale;
    } else if (height > 0) {
      scale = height / chartHeight;
      width = chartWidth * scale;
    } else {
      scale = dimensions.scaling > 0 ? parseFloat(dimensions.scaling) : 1;
      width = chartWidth * scale * this.scene.canvasScaleX;
      height = chartHeight * scale * this.scene.canvasScaleY;
    }
    if (dimensions.unit === "mm") {
      if (dimensions.dpi > 0 && dimensions.width > 0 && dimensions.height > 0) {
        pixelsPerMM = parseFloat(dimensions.dpi) / 25.4;
        scale *= pixelsPerMM;
        width *= pixelsPerMM;
        height *= pixelsPerMM;
      } else {
        throw "Invalid export configuration. If unit = mm, dpi, width and height must be supplied";
      }
    }
    return [width, height, scale];
  };

  Base_ChartEvents.prototype.exportToImage = function(type, dimensions, transparent) {
    var bounds, canvas, ch1, ch2, context, cw1, cw2, dh, e, event, h1, h2, height, mime, mime_map, scale, scaleX, scaleY, w1, w2, width, _i, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
    if (this.chart.title) {
      _ref = this.chart.title.computeSize(this.chart.layers.canvas.getContext("2d"), true), w1 = _ref[0], h1 = _ref[1];
      _ref1 = this.chart.title.computeSize(this.chart.layers.canvas.getContext("2d")), w2 = _ref1[0], h2 = _ref1[1];
    } else {
      w1 = h1 = w2 = h2 = 0;
    }
    if (this.chart.credits) {
      _ref2 = this.chart.credits.computeSize(this.chart.layers.canvas.getContext("2d"), true), cw1 = _ref2[0], ch1 = _ref2[1];
      _ref3 = this.chart.credits.computeSize(this.chart.layers.canvas.getContext("2d")), cw2 = _ref3[0], ch2 = _ref3[1];
    } else {
      cw1 = ch1 = cw2 = ch2 = 0;
    }
    mime_map = {
      "png": "image/png",
      "jpeg": "image/jpeg"
    };
    mime = mime_map[type];
    _ref4 = this.exportGetDimensions(dimensions), width = _ref4[0], height = _ref4[1], scale = _ref4[2];
    canvas = document.createElement("canvas");
    canvas.width = width;
    if (h1 > h2) {
      dh = h1;
    } else if (h1 < h2) {
      dh = -h2;
    } else {
      dh = 0;
    }
    height += dh * scale * this.scene.canvasScaleY;
    if (ch1 > ch2) {
      height += ch1 * scale * this.scene.canvasScaleY;
    } else if (ch1 < ch2) {
      height -= ch2 * scale * this.scene.canvasScaleY;
    }
    canvas.height = height;
    context = canvas.getContext("2d");
    if (!transparent) {
      context.fillStyle = "#fff";
      context.fillRect(0, 0, canvas.width, canvas.height);
    }
    bounds = this.scene.getChartBounds();
    scaleX = scale * this.scene.canvasScaleX;
    scaleY = scale * this.scene.canvasScaleY;
    context.setTransform(scaleX, 0, 0, scaleY, -bounds.left * scaleX, (-bounds.top + dh) * scaleY);
    event = new Base_SceneEvent();
    event["export"] = true;
    event.time = new Date().getTime();
    event.changes = {};
    event.context = context;
    _ref5 = this.elements;
    for (_i = 0, _len = _ref5.length; _i < _len; _i++) {
      e = _ref5[_i];
      if (e.paintScene != null) {
        e.paintScene(event);
      }
    }
    return canvas.toDataURL(mime);
  };

  return Base_ChartEvents;

})();

/*
//@ sourceMappingURL=ChartEvents.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Credits;

Base_Credits = (function() {
  "use strict";
  function Base_Credits(scene) {
    this.scene = scene;
    if (this.scene.settings.credits.enabledOnExport || this.scene.settings.credits.enabled) {
      this.scene.settings.getAssetImage(this.scene.settings.credits.image);
    }
  }

  Base_Credits.prototype.paintScene = function(event) {
    var canvas, context, enabled, h, i, margin, w;
    enabled = event["export"] ? this.scene.settings.credits.enabledOnExport : this.scene.settings.credits.enabled;
    if (!enabled) {
      return;
    }
    i = this.scene.settings.getAssetImage(this.scene.settings.credits.image);
    if (i && (i.width || event["export"])) {
      margin = 3;
      context = event.context;
      context.save();
      context.setTransform(1, 0, 0, 1, 0, 0);
      canvas = context.canvas;
      w = canvas.width;
      h = canvas.height;
      h = h - i.height - margin;
      context.drawImage(i, w - i.width - margin, h);
      return context.restore();
    }
  };

  Base_Credits.prototype.onClick = function(event) {};

  Base_Credits.prototype.computeSize = function(g, is_export) {
    var credits, i;
    if (is_export == null) {
      is_export = false;
    }
    credits = this.scene.settings.credits;
    this.lines = [];
    if (!((credits.enabled && !is_export) || (credits.enabledOnExport && is_export))) {
      return [0, 0];
    }
    i = this.scene.settings.getAssetImage(this.scene.settings.credits.image);
    return [i.width / this.scene.canvasScaleX, i.height / this.scene.canvasScaleY];
  };

  return Base_Credits;

})();

// Generated by CoffeeScript 1.6.3
var Base_Title;

Base_Title = (function() {
  "use strict";
  function Base_Title(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.lines = [];
    this.lineSpacing = 0;
  }

  Base_Title.prototype.computeSize = function(g, is_export) {
    var availableWidth, h, i, line, line1, line1Width, lineWidth, m, text, title, w, width, words, _i, _ref;
    if (is_export == null) {
      is_export = false;
    }
    title = this.scene.settings.title;
    this.lines = [];
    if (!(((title.enabled && !is_export) || (title.enabledOnExport && is_export)) && title.text)) {
      return [0, 0];
    }
    m = 2 * title.margin;
    text = title.text;
    g.save();
    Base_Graphics.textStyle(g, title.style);
    w = g.measureText(text).width;
    h = g.measureText("M").width;
    this.lineSpacing = h * 1.4;
    availableWidth = this.scene.chartWidth;
    if (w + m > availableWidth) {
      width = 0;
      words = text.split(" ");
      line = words[0];
      lineWidth = g.measureText(line).width;
      for (i = _i = 1, _ref = words.length - 1; _i <= _ref; i = _i += 1) {
        line1 = line + " " + words[i];
        line1Width = g.measureText(line1).width;
        if (line1Width <= availableWidth) {
          line = line1;
          lineWidth = line1Width;
        } else {
          this.lines.push(line);
          w = Math.max(w, lineWidth);
          line = words[i];
          lineWidth = g.measureText(line).width;
        }
      }
      this.lines.push(line);
      w = Math.max(width, lineWidth);
    } else {
      this.lines.push(text);
    }
    g.restore();
    w += m;
    h = m + (this.lines.length - 1) * this.lineSpacing + h;
    return [w, h];
  };

  Base_Title.prototype.paintScene = function(event) {
    var enabled, g, h, h0, left, line, margin, right, title, top, w, w0, x, y, _i, _len, _ref, _ref1, _ref2, _results;
    title = this.scene.settings.title;
    enabled = event["export"] ? title.enabledOnExport : title.enabled;
    if (!(enabled && title.text)) {
      return;
    }
    g = event.context;
    left = 0;
    top = 0;
    _ref = this.computeSize(g), w = _ref[0], h = _ref[1];
    if (event["export"]) {
      _ref1 = this.computeSize(g, true), w0 = _ref1[0], h0 = _ref1[1];
      if (h0 > h) {
        top = h0 * -1;
      }
    }
    right = this.scene.chartWidth;
    margin = title.margin;
    Base_Graphics.textStyle(g, title.style);
    y = top + margin;
    g.textBaseline = "top";
    if (title.align === "left") {
      g.textAlign = "start";
      x = left + margin;
    } else if (title.align === "right") {
      g.textAlign = "end";
      x = right - margin;
    } else {
      g.textAlign = "center";
      x = (left + right) / 2;
    }
    _ref2 = this.lines;
    _results = [];
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      line = _ref2[_i];
      g.fillText(line, x, y);
      _results.push(y += this.lineSpacing);
    }
    return _results;
  };

  return Base_Title;

})();

// Generated by CoffeeScript 1.6.3
var Base_TouchMarkers,
  __hasProp = {}.hasOwnProperty;

Base_TouchMarkers = (function() {
  "use strict";
  Base_TouchMarkers.prototype.animationPriority = 0;

  Base_TouchMarkers.prototype.scene = null;

  Base_TouchMarkers.prototype.touches = {};

  Base_TouchMarkers.prototype.text = null;

  Base_TouchMarkers.prototype.fps = 0;

  Base_TouchMarkers.prototype.fpsAveragingPeriod = 1000;

  Base_TouchMarkers.prototype.prevFrame = null;

  function Base_TouchMarkers(scene) {
    this.scene = scene;
    this.scene.frameCount = 0;
    this.touches = {};
  }

  Base_TouchMarkers.prototype.paintScene = function(event) {
    var count, dt, fp, g, k, p, prop, t, _i, _len, _ref, _ref1;
    this.scene.frameCount += 1;
    if (this.prevFrame) {
      dt = Math.max(event.time - this.prevFrame, 1) / 1000;
      fp = 1 / dt;
      prop = Math.min(1, dt * 3);
      this.fps = this.fps * (1 - prop) + fp * prop;
    }
    this.prevFrame = event.time;
    g = event.context;
    g.strokeStyle = "#000";
    g.fillStyle = "#000";
    g.beginPath();
    count = 0;
    _ref = this.touches;
    for (k in _ref) {
      if (!__hasProp.call(_ref, k)) continue;
      t = _ref[k];
      count += 1;
      g.moveTo(t.dx + 10, t.dy);
      g.arc(t.dx, t.dy, 10, 0, Math.PI * 2);
      g.moveTo(t.x + 30, t.y);
      g.arc(t.x, t.y, 30, 0, Math.PI * 2);
      g.moveTo(t.dx, t.dy);
      _ref1 = t.trace;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        p = _ref1[_i];
        g.lineTo(p.x, p.y);
        g.arc(p.x, p.y, 3, 0, Math.PI * 2);
      }
    }
    g.stroke();
    g.textAlign = "start";
    g.textBaseline = "middle";
    return g.fillText("FPS: " + (Math.round(this.fps)) + ", touches: " + count, this.scene.x0 + this.scene.width / 3, 20);
  };

  Base_TouchMarkers.prototype.previewPointerDown = function(event) {
    var k, t, _ref;
    _ref = this.touches;
    for (k in _ref) {
      if (!__hasProp.call(_ref, k)) continue;
      t = _ref[k];
      if (t.up) {
        delete this.touches[k];
      }
    }
    this.touches[event.identifier] = {
      dx: event.x,
      dy: event.y,
      up: false,
      trace: []
    };
    return event.changes.pointers = true;
  };

  Base_TouchMarkers.prototype.previewPointerDrag = function(event) {
    var t;
    t = this.touches[event.identifier];
    t.x = event.x;
    t.y = event.y;
    return t.trace.push({
      x: t.x,
      y: t.y
    });
  };

  Base_TouchMarkers.prototype.previewPointerUp = function(event) {
    this.touches[event.identifier].up = true;
    return this.previewPointerDrag(event);
  };

  Base_TouchMarkers.prototype.previewPointerCancel = function(event) {
    this.touches[event.identifier].up = true;
    return this.previewPointerDrag(event);
  };

  return Base_TouchMarkers;

})();

/*
//@ sourceMappingURL=TouchMarkers.map
*/

// Generated by CoffeeScript 1.6.3
var Base_InfoPopup;

Base_InfoPopup = (function() {
  "use strict";
  function Base_InfoPopup(chart) {
    this.chart = chart;
    this.container = chart.layers.container;
    this.scene = chart.scene;
    this.events = chart.events;
    this.popup = Base_Helpers.createDom("div", "DVSL-info-center", null, this.container);
    Base_Helpers.createDom("em", null, null, this.popup);
    this.events.addWhiteList(this.popup);
    this.popup.style.position = "absolute";
    this.popup.style.display = "none";
    this.contents = null;
    this.visible = false;
    this.x0 = null;
    this.x1 = null;
    this.y = null;
    this.chart.events.addWhiteList(this.popup);
  }

  Base_InfoPopup.prototype.hide = function() {
    if (!this.visible) {
      return false;
    }
    this.visible = false;
    this.popup.style.display = "none";
    return true;
  };

  Base_InfoPopup.prototype.show = function(x0, x1, y, contents) {
    this.visible = true;
    if (contents) {
      this.popup.style.display = "block";
      this.popup.innerHTML = contents;
      return this.updateXY(x0, x1, y);
    } else {
      return this.popup.style.display = "none";
    }
  };

  Base_InfoPopup.prototype.updateContents = function(contents) {
    if (!!this.visible) {
      return;
    }
    if (contents === null) {
      return this.hide();
    } else {
      return this.show(this.x0, this.x1, this.y, contents);
    }
  };

  Base_InfoPopup.prototype.updateXY = function(x0, x1, y) {
    var arrowWidth, cl, h, margin, w, x;
    if (!this.visible) {
      return;
    }
    this.x0 = x0;
    this.x1 = x1;
    this.y = y;
    margin = 12;
    arrowWidth = 10;
    w = this.popup.offsetWidth;
    h = this.popup.offsetHeight;
    if (this.scene.x0 <= x0 - w - arrowWidth) {
      x = x0 - w - arrowWidth;
      cl = "DVSL-info-left";
    } else if (this.scene.x0 + this.scene.width >= x1 + w + arrowWidth) {
      x = x1 + arrowWidth;
      cl = "DVSL-info-right";
    } else {
      x = (x0 + x1 - w) / 2;
      cl = "DVSL-info-center";
    }
    y = Math.min(Math.max(this.scene.y0 + margin, y - h / 2), this.scene.y0 + this.scene.height - h);
    this.popupX = x;
    this.popupY = y;
    this.popup.style.left = x + "px";
    this.popup.style.top = y + "px";
    return Base_Helpers.setClass(this.popup, cl);
  };

  return Base_InfoPopup;

})();

/*
//@ sourceMappingURL=InfoPopup.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Settings,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Settings = (function(_super) {
  __extends(Netchart_Settings, _super);

  Netchart_Settings.FlatTheme = {
    advanced: {
      themeCSSClass: "DVSL-flat",
      assets: ["netchart.css"]
    }
  };

  Netchart_Settings.defaults = {
    theme: Netchart_Settings.FlatTheme,
    data: {
      format: "JSON",
      preloaded: null,
      dataFunction: null,
      url: null,
      requestTimeout: 40000,
      cacheSize: 10000,
      random: null,
      randomGridLinkProbability: 0.6,
      randomNodes: 0,
      randomLinks: 0,
      requestMaxUnits: 2,
      numberOfParralelRequests: 3,
      preloadNodeLinks: false
    },
    filters: {
      nodeFilter: null,
      linkFilter: null,
      nodeLinksProcessor: null,
      multilinkProcessor: null
    },
    style: {
      nodeLabelMinSize: 40,
      nodeDetailMinZoom: 0.2,
      linkLabelMinZoom: 3,
      iconsMinZoom: 0.7,
      iconSize: 16,
      iconNodeDistance: 0,
      iconNodeAngle: -Math.PI / 4,
      nodeDisplay: "image",
      nodeRadiusExtent: [10, 50],
      linkRadiusExtent: [0.2, 10],
      linkStrengthExtent: [0.1, 1],
      linkLengthExtent: [0.1, 50],
      nodeAutoScaling: null,
      linkAutoScaling: null,
      linkStrengthAutoScaling: null,
      linkLengthAutoScaling: null,
      nodeRules: {},
      linkRules: {},
      selection: {
        fillColor: "lightblue",
        sizeConstant: 5,
        sizeProportional: 0.2
      },
      node: {
        fillColor: "#4f4",
        lineColor: null,
        lineWidth: null,
        radius: 10,
        shadowColor: null
      },
      nodeLocked: {},
      nodeLabel: {
        fillColor: "black"
      },
      nodeExpanded: {},
      nodeFocused: {
        fillColor: "orange"
      },
      link: {
        fillColor: "#6D6",
        shadowColor: null,
        fromDecoration: null,
        toDecoration: null,
        fromIcons: null,
        toIcons: null,
        label: null,
        radius: 1,
        length: 1,
        strength: 1,
        dashed: false,
        toPieValue: 0,
        toPieColor: null
      },
      linkLabel: {
        fillColor: "black"
      },
      linkLabelBalloon: {
        fillColor: "#FFF",
        lineColor: "gray"
      },
      nodeLabelBalloon: {
        fillColor: "rgba(255,255,255,0.7)"
      },
      hiddenLinks: {
        fillColor: "#BBB",
        lineColor: "#BBB",
        lineWidth: 1,
        size: 3
      },
      hoverStyle: {
        shadowOffsetX: 0,
        shadowOffsetY: 0,
        shadowBlur: 12,
        shadowColor: "blue"
      },
      removedColor: "#EEE"
    },
    layout: {
      nodeSpacing: 16,
      multilinkSpacing: 10,
      layoutMode: "dynamic",
      layoutFreezeTimeout: 1500,
      fadeTime: 600,
      globalLayoutOnChanges: true
    },
    events: {},
    info: {
      enabled: false,
      nodeContentsFunction: null,
      linkContentsFunction: null
    },
    interaction: {
      zooming: {
        doubleClickZoom: 1.5,
        zoomExtent: [0.1, 8],
        autoZoom: true,
        sensitivity: 1,
        wheel: true,
        fingers: true,
        autoZoomDuration: 500
      },
      selection: {
        enabled: true,
        nodesSelectable: true,
        linksSelectable: true,
        lockNodesOnMove: true,
        tolerance: 10
      }
    },
    navigation: {
      mode: "showall",
      initialNodes: null,
      focusNodeExpansionRadius: 2,
      focusHistoryRelevanceCooldown: 0.6,
      focusAutoFadeout: true,
      numberOfFocusNodes: 3,
      expandDelay: 400,
      expandOnClick: true,
      autoZoomOnFocus: false,
      nodeAutoExpandFilter: null
    },
    nodeMenu: {
      enabled: true,
      buttons: ["hide", "expand", "focus", "lock"],
      showData: false,
      contentsFunction: null
    },
    linkMenu: {
      enabled: true,
      showData: false,
      contentsFunction: null
    },
    advanced: {
      perNodeLoadingIndicator: true,
      style: {
        loadingArcStyle: {
          r: 35,
          lineColor: "red",
          lineWidth: 5,
          location: "corner"
        }
      }
    },
    localization: {
      loadingLabel: "Loading...",
      closeButton: "Close",
      menu: {
        dynaminc: "Dynamic",
        fixed: "Fixed",
        focus: "Focus",
        unfocus: "Unfocus",
        collapse: "Collapse",
        expand: "Expand",
        hide: "Hide"
      }
    }
  };

  function Netchart_Settings(settings) {
    Netchart_Settings.__super__.constructor.call(this, "netchart");
    this.apply(Netchart_Settings.defaults);
    this.apply(settings);
  }

  Netchart_Settings.prototype.apply = function(settings) {
    var changes, p, r, _ref, _ref1;
    changes = Netchart_Settings.__super__.apply.call(this, settings);
    if (settings.style) {
      if (settings.style.nodeRules) {
        _ref = settings.style.nodeRules;
        for (p in _ref) {
          r = _ref[p];
          this.style.nodeRules[p] = r;
        }
      }
      if (settings.style.linkRules) {
        _ref1 = settings.style.linkRules;
        for (p in _ref1) {
          r = _ref1[p];
          this.style.linkRules[p] = r;
        }
      }
    }
    return changes;
  };

  return Netchart_Settings;

})(Base_Settings);

/*
//@ sourceMappingURL=Settings.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Impl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty;

Base_Impl = (function() {
  "use strict";
  Base_Impl.prototype.container = null;

  Base_Impl.prototype.settings = null;

  Base_Impl.prototype.scene = null;

  Base_Impl.prototype.layers = null;

  Base_Impl.prototype.removed = false;

  Base_Impl.prototype.EVENT_NAMES = null;

  Base_Impl.prototype.curState = null;

  Base_Impl.prototype.goingBack = false;

  Base_Impl.prototype.chartUpdateOrigin = null;

  Base_Impl.prototype.currentNavigationState = null;

  Base_Impl.prototype.previousSizeW = 0;

  Base_Impl.prototype.previousSizeH = 0;

  Base_Impl.prototype.onAssetsLoaded = function() {
    return Base_Helpers.error("Need to override onAssetsLoaded");
  };

  Base_Impl.prototype.onRemove = function() {
    return Base_Helpers.error("Need to override onRemove");
  };

  Base_Impl.prototype.onSizeChanged = function(width, height) {
    return Base_Helpers.error("Need to override onSizeChanged");
  };

  Base_Impl.prototype.onSettingsChanged = function(changes) {
    return Base_Helpers.error("Need to override onSettingsChanged");
  };

  function Base_Impl(settings) {
    this.loadAssets = __bind(this.loadAssets, this);
    this.defaultError = __bind(this.defaultError, this);
    this.chartUpdateNotify = __bind(this.chartUpdateNotify, this);
    this._windowResize = __bind(this._windowResize, this);
    var key, name, value, _ref;
    if (!this.EVENT_NAMES) {
      this.EVENT_NAMES = {};
      _ref = settings.events;
      for (name in _ref) {
        value = _ref[name];
        this.EVENT_NAMES[name] = name;
        if (name.indexOf("on") === 0) {
          key = name[2].toLowerCase() + name.slice(3);
          this.EVENT_NAMES[key] = name;
        }
      }
    }
    if (!settings.container) {
      throw "Chart container not set";
    }
    if (!(settings.container.nodeType > 0)) {
      throw "Chart container not a dom object";
    }
  }

  Base_Impl.prototype.initialize = function(api) {
    var browser, sx, sy, _ref;
    this.api = api;
    /*
      @settings, @scene, @layers must be prepared
    */

    this.eventListeners = {};
    this.assetsLoaded = true;
    this.loadedAssets = {};
    this.imgAssets = {};
    if (this.settings.advanced.assets != null) {
      this.loadAssets(this.settings.advanced.assets);
    }
    browser = Base_Helpers.detectBrowser();
    _ref = Base_Helpers.canvasScaling(), sx = _ref[0], sy = _ref[1];
    if ((this.settings.advanced.highDpi.hasOwnProperty(browser) && this.settings.advanced.highDpi[browser]) || this.settings.advanced.highDpi["default"]) {
      this.scene.canvasScaleX = sx;
      this.scene.canvasScaleY = sy;
    } else {
      this.scene.canvasScaleX = 1;
      this.scene.canvasScaleY = 1;
    }
    this.container = this.settings.container;
    if (this.container._DVSL_ChartInstance !== void 0 && this.container._DVSL_ChartInstance !== null) {
      this.container._DVSL_ChartInstance.remove();
    }
    this.container._DVSL_ChartInstance = this;
    this.container.appendChild(this.layers.container);
    this.events = new Base_ChartEvents(this.layers.mouseTrackLayer, this.layers.canvas, this);
    if (this.settings.advanced.trackTouches) {
      this.events.addElement(new Base_TouchMarkers(this.scene));
    }
    Base_Helpers.listen(window, "resize", this._windowResize);
    return this.api._impl = this;
  };

  Base_Impl.prototype.updateSettings = function(newSettings, origin) {
    var changes, old;
    if (origin == null) {
      origin = null;
    }
    this.log("Update Settings, " + (JSON.stringify(newSettings)));
    old = Base_Helpers.clone(this.settings.events);
    changes = this.settings.apply(newSettings);
    if (this.removed) {
      return;
    }
    if (changes.events) {
      this.updateEvents(old, this.settings.events);
    }
    if (changes.advanced && changes.advanced.assets) {
      this.loadAssets(this.settings.advanced.assets);
    }
    if (changes.width || changes.height || changes.maxWidth || changes.minWidth || changes.minHeight || changes.maxHeight) {
      this.updateSize(true);
    }
    this.onSettingsChanged(changes);
    this.events.notifySceneChanges({
      settings: true
    });
    if (origin) {
      return this.notifySettingsChanged(changes, origin);
    }
  };

  Base_Impl.prototype.remove = function() {
    this.removed = true;
    this.events.remove();
    this.container.removeChild(this.layers.container);
    this.onRemove();
    this.layers = null;
    this.scene = null;
    this.events = null;
    this.container._DVSL_ChartInstance = void 0;
    return Base_Helpers.unlisten(window, "resize", this._windowResize);
  };

  Base_Impl.prototype._windowResize = function() {
    return this.updateSize(false);
  };

  Base_Impl.prototype.updateSize = function(force) {
    var clientHeight, clientWidth, minHeight, minWidth;
    if (force == null) {
      force = false;
    }
    if (this.removed) {
      return;
    }
    clientWidth = this.settings.width;
    clientHeight = this.settings.height;
    minWidth = 0;
    minHeight = 0;
    if (this.layers.container.style.display !== "") {
      minWidth = this.settings.minWidth;
      minHeight = this.settings.minHeight;
    }
    if (!clientWidth) {
      clientWidth = parseInt(Math.max(minWidth, Math.min(this.settings.maxWidth, this.scene.settings.container.clientWidth)));
    }
    if (!clientHeight) {
      clientHeight = parseInt(Math.max(minHeight, Math.min(this.settings.maxHeight, this.scene.settings.container.clientHeight)));
    }
    if (clientWidth !== this.previousSizeW || clientHeight !== this.previousSizeH || force) {
      this.log("Update size, " + clientHeight + ", " + clientWidth);
      this.previousSizeH = clientHeight;
      this.previousSizeW = clientWidth;
      this.scene.chartHeight = clientHeight;
      this.scene.chartWidth = clientWidth;
      return this.onSizeChanged(clientWidth, clientHeight);
    }
  };

  /* events*/


  Base_Impl.prototype.on = function(event, handler) {
    if (!this.eventListeners[event]) {
      this.eventListeners[event] = [];
    }
    return this.eventListeners[event].push(handler);
  };

  Base_Impl.prototype.off = function(event, handler) {
    if (this.eventListeners[event] != null) {
      return Base_Helpers.removeFromArray(this.eventListeners[event], handler);
    }
  };

  Base_Impl.prototype.updateEvents = function(oldSettings, newSettings) {
    var event, prop, _ref, _results;
    _ref = this.EVENT_NAMES;
    _results = [];
    for (event in _ref) {
      prop = _ref[event];
      if (oldSettings[prop] != null) {
        this.off(event, oldSettings[prop]);
      }
      if (newSettings[prop] != null) {
        _results.push(this.on(event, newSettings[prop]));
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Base_Impl.prototype.notifyHoverChanged = function(e) {
    e.origin = "user";
    return this.dispatchEventParams("hoverChange", this.extendEventParams(e), null);
  };

  Base_Impl.prototype.notifyDoubleClick = function(e) {
    e.origin = "user";
    return this.dispatchEvent("doubleClick", this.extendEventParams(e), this.defaultDoubleClick);
  };

  Base_Impl.prototype.notifyRightClick = function(e) {
    e.origin = "user";
    return this.dispatchEvent("rightClick", this.extendEventParams(e), this.defaultRightClick);
  };

  Base_Impl.prototype.notifyClick = function(e) {
    e.origin = "user";
    return this.dispatchEvent("click", this.extendEventParams(e), this.defaultClick);
  };

  Base_Impl.prototype.notifyAnimationDone = function() {
    return this.dispatchEventParams("animationDone", this.extendEventParams({}), null);
  };

  Base_Impl.prototype.notifySelectionChanged = function(origin) {
    return this.dispatchEventParams("selectionChange", this.extendEventParams({
      origin: origin
    }), null);
  };

  Base_Impl.prototype.notifySettingsChanged = function(changes, origin) {
    return this.dispatchEventParams("settingsChange", this.extendEventParams({
      changes: changes,
      origin: origin
    }), null);
  };

  Base_Impl.prototype.notifyChartUpdate = function(origin) {
    var time, timeout;
    timeout = this.scene.settings.events.chartUpdateDelay;
    time = new Date().getTime();
    if (origin) {
      this.chartUpdateWasBack = this.goingBack;
      this.chartUpdateOrigin = origin;
      this.chartUpdateTime = time;
    }
    timeout = this.chartUpdateTime + timeout - time;
    if (timeout > 0) {
      return this.chartUpdateTimeout = setTimeout(this.chartUpdateNotify, timeout);
    } else {
      return this.chartUpdateNotify();
    }
  };

  Base_Impl.prototype.cancelChartUpdateNotify = function() {
    this.chartUpdateOrigin = null;
    if (this.chartUpdateTimeout) {
      clearTimeout(this.chartUpdateTimeout);
      return this.chartUpdateTimeout = null;
    }
  };

  Base_Impl.prototype.chartUpdateNotify = function() {
    var origin, state;
    if (!this.chartUpdateOrigin) {
      return;
    }
    state = this.saveNavigation();
    if (state && (!this.curState || JSON.stringify(state) !== JSON.stringify(this.curState))) {
      if (!this.chartUpdateWasBack && this.curState) {
        this.scene.pushBack(this.curState);
      }
      this.curState = state;
      origin = this.chartUpdateOrigin;
      this.chartUpdateOrigin = null;
      return this.doChartUpdateNotify(origin);
    }
  };

  Base_Impl.prototype.back = function(animate, origin) {
    var state;
    if (animate == null) {
      animate = true;
    }
    if (origin == null) {
      origin = "api";
    }
    if (this.scene.backStack.length === 0) {
      return false;
    }
    state = this.scene.backStack.pop();
    this.goingBack = true;
    this.restoreNavigation(state, animate, origin);
    return this.goingBack = false;
  };

  Base_Impl.prototype.saveNavigation = function() {
    return Base_Helpers.error("Need to override saveNavigation");
  };

  Base_Impl.prototype.restoreNavigation = function(state, animate, origin) {
    return Base_Helpers.error("Need to override restoreNavigation");
  };

  Base_Impl.prototype.doChartUpdateNotify = function(origin) {
    return this.dispatchEventParams("chartUpdate", this.extendEventParams({
      origin: origin
    }), null);
  };

  Base_Impl.prototype.dispatchEventParams = function(name, params, defaultFunc) {
    var event, key, value;
    if (!(defaultFunc || ((this.eventListeners[name] != null) && this.eventListeners[name].length > 0))) {
      return {};
    }
    event = Base_Helpers.createEvent(name);
    event.chart = this.api;
    for (key in params) {
      if (!__hasProp.call(params, key)) continue;
      value = params[key];
      if (event[key] === void 0) {
        event[key] = value;
      }
    }
    return this.dispatchEvent(name, event, defaultFunc);
  };

  Base_Impl.prototype.dispatchEvent = function(name, event, defaultFunc) {
    var l, _i, _len, _ref;
    if (!(defaultFunc || ((this.eventListeners[name] != null) && this.eventListeners[name].length > 0))) {
      return event;
    }
    if (this.eventListeners[name] != null) {
      _ref = this.eventListeners[name];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        l = _ref[_i];
        this.log("Call user event handler, " + name, event);
        l.call(this.api, event);
      }
    }
    if (!event.defaultPrevented && (defaultFunc != null)) {
      this.log("Call default event handler, " + name);
      defaultFunc.call(this.api, event);
    }
    return event;
  };

  Base_Impl.prototype.error = function(msg, arg) {
    return this.dispatchEventParams("error", {
      "message": msg,
      "arg": arg
    }, this.defaultError);
  };

  Base_Impl.prototype.log = function(msg, arg) {
    if (this.settings.advanced.logging) {
      return Base_Helpers.log(msg, arg);
    }
  };

  Base_Impl.prototype.defaultError = function(event) {
    if (this.settings.events.onError) {
      this.settings.events.onError(event);
    }
    return Base_Helpers.error(event.message, event.arg ? event.arg : null);
  };

  Base_Impl.prototype.loadAssets = function() {
    var asset, assetToLoad, loaded, _i, _len, _ref,
      _this = this;
    assetToLoad = null;
    _ref = this.settings.advanced.assets;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      asset = _ref[_i];
      if (!this.loadedAssets.hasOwnProperty(asset)) {
        assetToLoad = asset;
        break;
      }
    }
    if (assetToLoad) {
      if (this.assetsLoaded) {
        this.log("Loading assets");
      }
      this.assetsLoaded = false;
      loaded = function(asset) {
        if (_this.removed) {
          return;
        }
        if (!_this.credits) {
          _this.credits = _this.events.addElement(new Base_Credits(_this.scene));
        }
        _this.loadedAssets[asset] = true;
        return _this.loadAssets();
      };
      return this.loadAsset(assetToLoad, loaded);
    } else {
      if (!this.assetsLoaded) {
        this.log("Chart assets loaded");
        this.onAssetsLoaded();
      }
      return this.assetsLoaded = true;
    }
  };

  Base_Impl.prototype.loadAsset = function(asset, callback) {
    var elem, ext, url,
      _this = this;
    url = asset.src;
    url = this.settings.getAssetUrl(asset);
    ext = Base_Helpers.getExtension(asset);
    if (ext === "css") {
      elem = document.createElement("link");
      elem.setAttribute("rel", "stylesheet");
      elem.setAttribute("href", url);
      elem.setAttribute("type", "text/css");
      elem.addEventListener("load", function() {
        return callback(asset);
      });
      elem.addEventListener("error", function() {
        _this.error("Assets: Failed to load asset", asset);
        return callback(asset);
      });
      document.getElementsByTagName("head")[0].appendChild(elem);
      return setTimeout(function() {
        var img;
        if (!_this.loadedAssets.hasOwnProperty(asset) && !_this.imgAssets.hasOwnProperty(asset)) {
          _this.imgAssets[asset] = true;
          img = document.createElement('img');
          img.onerror = function() {
            return callback(asset);
          };
          return img.src = url;
        }
      }, 200);
    } else if (ext === "js") {
      elem = document.createElement("script");
      elem.setAttribute("src", url);
      elem.setAttribute("type", "text/javascript");
      elem.addEventListener("load", function() {
        return callback(asset);
      });
      elem.addEventListener("error", function() {
        _this.error("Assets: Failed to load asset", asset);
        return callback(asset);
      });
      return document.getElementsByTagName("head")[0].appendChild(elem);
    } else {
      this.error("Assets: Do not know how to load", asset);
      return callback(asset);
    }
  };

  return Base_Impl;

})();

/*
//@ sourceMappingURL=Impl.map
*/

// Generated by CoffeeScript 1.6.3
var Base_Resizer;

Base_Resizer = (function() {
  Base_Resizer.prototype.chart = null;

  Base_Resizer.prototype.oh = 0;

  Base_Resizer.prototype.sy = 0;

  Base_Resizer.prototype.barVisible = false;

  Base_Resizer.prototype.resizing = false;

  Base_Resizer.prototype.enabled = false;

  function Base_Resizer(chart) {
    this.chart = chart;
    this.scene = this.chart.scene;
    this.layers = this.chart.layers;
  }

  Base_Resizer.prototype.onSceneChange = function(ev) {
    if (Base_Helpers.hasProp(ev, "changes/settings")) {
      return this.enabled = this.scene.settings.interaction.resizing.enabled;
    }
  };

  Base_Resizer.prototype.onPointerOut = function(ev) {
    if (!this.enabled) {
      return;
    }
    return this.hideUI();
  };

  Base_Resizer.prototype.onPointerMove = function(ev) {
    var dy;
    if (!this.enabled) {
      return;
    }
    dy = this.scene.chartHeight - ev.y;
    if (dy < this.scene.settings.interaction.resizing.advanced.resizerHandleVisibilityTolerance) {
      if (!this.barVisible) {
        this.showUI();
      }
      if (dy < this.scene.settings.interaction.resizing.advanced.resizerHandleEnableTolerance) {
        ev.consumed = true;
        return ev.cursor = "ns-resize";
      }
    } else {
      if (this.barVisible) {
        return this.hideUI();
      }
    }
  };

  Base_Resizer.prototype.onPointerDown = function(ev) {
    var dy;
    if (!this.enabled) {
      return;
    }
    this.sy = ev.y;
    dy = this.scene.chartHeight - ev.y;
    this.resizing = dy < this.scene.settings.interaction.resizing.advanced.resizerHandleEnableTolerance && ev.y <= this.scene.chartHeight;
    if (this.resizing) {
      this.oh = this.scene.chartHeight;
      this.showUI();
      ev.cursor = "ns-resize";
      return ev.consumed = true;
    }
  };

  Base_Resizer.prototype.onDoubleClick = function(ev) {
    var dy, h, s;
    if (!this.enabled) {
      return;
    }
    this.sy = ev.y;
    dy = this.scene.chartHeight - ev.y;
    if (dy < this.scene.settings.interaction.resizing.advanced.resizerHandleEnableTolerance && ev.y <= this.scene.chartHeight) {
      ev.consumed = true;
      if (this.wasMaximized) {
        h = this.originalHeight;
        this.wasMaximized = false;
      } else {
        this.originalHeight = this.oh;
        this.wasMaximized = true;
        s = Base_Helpers.getScroll();
        h = this.oh + s[1] + window.innerHeight - ev.pageY - dy - 10;
      }
      this.scene.settings.height = Math.min(this.scene.settings.maxHeight, Math.max(this.scene.settings.minHeight, h));
      return this.chart.updateSize();
    }
  };

  Base_Resizer.prototype.onPointerDrag = function(ev) {
    if (!this.enabled) {
      return;
    }
    if (this.resizing) {
      ev.consumed = true;
      this.wasMaximized = false;
      this.scene.settings.height = Math.min(this.scene.settings.maxHeight, Math.max(this.scene.settings.minHeight, this.oh + (ev.y - this.sy)));
      return this.chart.updateSize();
    }
  };

  Base_Resizer.prototype.showUI = function() {
    if (this.barVisible) {
      return;
    }
    this.barVisible = true;
    return Base_Helpers.fadeIn(this.layers.resizerBar);
  };

  Base_Resizer.prototype.hideUI = function() {
    if (!this.barVisible) {
      return;
    }
    this.barVisible = false;
    this.resizing = false;
    return Base_Helpers.fadeOut(this.layers.resizerBar);
  };

  return Base_Resizer;

})();

// Generated by CoffeeScript 1.6.3
var Base_MessagesOverlay;

Base_MessagesOverlay = (function() {
  "use strict";
  Base_MessagesOverlay.prototype.animationPriority = 0;

  Base_MessagesOverlay.prototype.scene = null;

  Base_MessagesOverlay.prototype.loadingTime = null;

  function Base_MessagesOverlay(chart) {
    this.chart = chart;
    this.scene = chart.scene;
  }

  Base_MessagesOverlay.prototype.doAnimations = function(event) {
    if (this.scene.loading) {
      return event.animating = true;
    }
  };

  Base_MessagesOverlay.prototype.paintScene = function(event) {
    var a, arcStyle, g, grad, height, loading, msg, r, scene, w, width, x, y, yy;
    scene = this.scene;
    msg = this.scene.getMessage();
    loading = this.scene.loading;
    if (!loading) {
      this.loadingTime = null;
    }
    if (!((msg != null) || loading)) {
      return;
    }
    if (this.loadingTime == null) {
      this.loadingTime = event.time;
    }
    arcStyle = this.scene.settings.advanced.style.loadingArcStyle;
    g = event.context;
    if (arcStyle.location === "corner") {
      x = scene.x0 + scene.width;
      y = scene.y0;
    } else {
      x = scene.x0 + scene.width / 2;
      y = scene.y0 + scene.height / 2;
    }
    if (msg != null) {
      Base_Graphics.textStyle(g, this.scene.settings.advanced.style.messageTextStyle);
      g.textBaseline = "middle";
      g.textAlign = "center";
      height = g.measureText("M").width * 1.5;
      width = g.measureText(msg).width;
      if (arcStyle.location === "corner") {
        x -= width;
        y += height * 1.5;
      }
      if (this.scene.loading) {
        y -= height;
        yy = y + arcStyle.r + height;
      } else {
        yy = y;
      }
      g.fillText(msg, x, yy);
    }
    if (this.scene.loading) {
      r = arcStyle.r;
      w = arcStyle.lineWidth;
      if (!msg && arcStyle.location === "corner") {
        x -= (r + w) * 1.2;
        y += (r + w) * 1.2;
      }
      g.save();
      g.lineCap = 'round';
      g.lineWidth = w;
      a = (event.time - this.loadingTime) / 700 * Math.PI;
      grad = g.createLinearGradient(x + r * Math.cos(a + Math.PI), y + r * Math.sin(a + Math.PI), x + r * Math.cos(a), y + r * Math.sin(a));
      grad.addColorStop(0, arcStyle.lineColor);
      grad.addColorStop(1, "transparent");
      g.strokeStyle = grad;
      g.beginPath();
      g.arc(x, y, r, a, a + Math.PI);
      g.stroke();
      return g.restore();
    }
  };

  return Base_MessagesOverlay;

})();

/*
//@ sourceMappingURL=MessagesOverlay.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Renderer;

Netchart_Renderer = (function() {
  "use strict";
  Netchart_Renderer.prototype.scene = null;

  Netchart_Renderer.prototype.events = null;

  Netchart_Renderer.prototype.animationPriority = 999;

  function Netchart_Renderer(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.events = chart.events;
    this.imageCache = {};
    this.multilinks = {};
  }

  Netchart_Renderer.prototype.onSceneChange = function(event) {
    var changes;
    return changes = event.changes;
  };

  Netchart_Renderer.prototype.doAnimations = function(event) {};

  Netchart_Renderer.prototype.getImage = function(url) {
    var image;
    image = this.imageCache[url];
    if (!image) {
      image = new Image();
      image.src = this.scene.settings.getAssetUrl(url);
      this.imageCache[url] = image;
    }
    if (image.width > 0) {
      return image;
    } else {
      return null;
    }
  };

  Netchart_Renderer.prototype.getNodeImage = function(style) {
    var im, imageId, untintedId, untintedImage;
    if (!style.image) {
      return null;
    }
    imageId = style.image;
    untintedId = null;
    if (style.tintImage && style.fillColor) {
      untintedId = imageId;
      imageId += "##" + style.fillColor;
    }
    if (this.imageCache[imageId] == null) {
      if (untintedId) {
        untintedImage = this.getImage(untintedId);
        if (untintedImage != null) {
          this.imageCache[imageId] = Base_Graphics.applyColorToImage(untintedImage, style.fillColor, false);
        }
      } else {
        this.getImage(imageId);
      }
    }
    im = this.imageCache[imageId];
    if ((im != null) && im.width) {
      return im;
    } else {
      return null;
    }
  };

  Netchart_Renderer.prototype.paintScene = function(event) {
    var g, hoverLinkPos, hoverNodePos;
    hoverNodePos = this.makeHoveredLast(this.scene.nodes, this.scene.hoverNode);
    hoverLinkPos = this.makeHoveredLast(this.scene.links, this.scene.hoverLink);
    this.scene.updateMultilinks();
    this.scene.clearModified();
    this.computeNodeRenderRadii();
    g = event.context;
    this.paintSelection(g);
    this.paintLinks(g);
    event.animating |= this.paintNodes(g, event.time);
    this.restoreHovered(this.scene.nodes, hoverNodePos);
    return this.restoreHovered(this.scene.links, hoverLinkPos);
  };

  Netchart_Renderer.prototype.getGeometry = function() {
    var txa, txm, tya, tym, x0s, x0w, x1s, x1w, y0s, y0w, y1s, y1w, zoom, _ref;
    _ref = this.scene.toDisplayTransform(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3];
    x0s = this.scene.x0;
    x1s = this.scene.x0 + this.scene.width;
    y0s = this.scene.y0;
    y1s = this.scene.y0 + this.scene.height;
    x0w = (x0s - txa) / txm;
    x1w = (x1s - txa) / txm;
    y0w = (y0s - tya) / tym;
    y1w = (y1s - tya) / tym;
    zoom = this.scene.zoom;
    return [txm, txa, tym, tya, zoom, x0s, x1s, y0s, y1s, x0w, y0w, x1w, y1w];
  };

  Netchart_Renderer.prototype.makeHoveredLast = function(list, hobj) {
    var i, len, n1, obj, _i, _len;
    len = list.length;
    if (len < 2 || !hobj || hobj === list[len - 1]) {
      return len - 1;
    }
    for (i = _i = 0, _len = list.length; _i < _len; i = ++_i) {
      obj = list[i];
      if (obj === hobj) {
        n1 = list[len - 1];
        list[len - 1] = hobj;
        list[i] = n1;
        return i;
      }
    }
    return len - 1;
  };

  Netchart_Renderer.prototype.restoreHovered = function(list, pos) {
    var len, n1;
    len = list.length;
    if (pos !== len - 1) {
      n1 = list[pos];
      list[pos] = list[len - 1];
      return list[len - 1] = n1;
    }
  };

  Netchart_Renderer.prototype.computeNodeRenderRadii = function() {
    var node, r, w, zoom, _i, _len, _ref, _results;
    zoom = this.scene.zoom;
    _ref = this.scene.nodes;
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      node = _ref[_i];
      r = node.currentRadius * zoom;
      w = node.currentHwidth * zoom;
      if (node.lineWidth) {
        r += node.lineWidth / 2;
        w += node.lineWidth / 2;
      }
      node.renderRadius = r;
      _results.push(node.renderHwidth = w);
    }
    return _results;
  };

  Netchart_Renderer.prototype.paintLinks = function(g) {
    var active, count, dashLen, ddx, ddy, decorationSize, dx, dy, i, iconRadius, invlen, l0, l1, len, link, linkLabelMinZoom, linkSpacing, lx, ly, ml, multiId, multiLinks, nodeDetailMinZoom, offset, paintDetails, paintIcons, pieInner, pieOuter, pieSizeConst, pieSizeProp, pieSpacing, r, r0, r1, str, t0, t1, txa, txm, tya, tym, w0, w1, width, x0, x0a, x0b, x0s, x0w, x1, x1s, x1w, y0, y0a, y0b, y0s, y0w, y1, y1s, y1w, ysign, zoom, _i, _j, _len, _ref, _ref1, _ref2, _results;
    _ref = this.getGeometry(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
    g.textAlign = "center";
    g.textBaseline = "middle";
    multiLinks = this.scene.multilinks;
    linkLabelMinZoom = this.scene.settings.style.linkLabelMinZoom;
    nodeDetailMinZoom = this.scene.settings.style.nodeDetailMinZoom;
    linkSpacing = this.scene.settings.layout.multilinkSpacing * zoom;
    paintIcons = zoom > this.scene.settings.style.iconsMinZoom;
    iconRadius = this.scene.settings.style.iconSize / 2;
    pieSpacing = 2;
    pieSizeConst = 5;
    pieSizeProp = 0.1;
    _ref1 = this.scene.links;
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      link = _ref1[_i];
      x0 = link.from.x;
      y0 = link.from.y;
      x1 = link.to.x;
      y1 = link.to.y;
      if (Math.max(x0, x1) < x0w || Math.min(x0, x1) > x1w || Math.max(y0, y1) < y0w || Math.min(y0, y1) > y1w) {
        continue;
      }
      x0 = x0 * txm + txa;
      y0 = y0 * tym + tya;
      x1 = x1 * txm + txa;
      y1 = y1 * tym + tya;
      r = Math.max(0.25, link.currentRadius * zoom * 0.5);
      r0 = link.from.renderRadius;
      r1 = link.to.renderRadius;
      w0 = link.from.renderHwidth;
      w1 = link.to.renderHwidth;
      dx = x1 - x0;
      dy = y1 - y0;
      len = Math.sqrt(dx * dx + dy * dy);
      active = link === this.scene.hoverLink || link.from === this.scene.hoverNode || link.to === this.scene.hoverNode;
      paintDetails = active || zoom > nodeDetailMinZoom;
      if (link.toPieValue > 0 && paintDetails) {
        pieInner = r1 + pieSpacing;
        pieOuter = pieInner + pieSizeConst + pieSizeProp * r1;
        this.paintLinkPie(g, x1, y1, pieInner, pieOuter, link.toPie0, link.toPie1, link.toPieColor);
        r1 = pieOuter;
      }
      if (len < r0 + r1) {
        continue;
      }
      invlen = 1 / len;
      ddx = dx * invlen;
      ddy = dy * invlen;
      if (r0 >= w0) {
        t0 = r0;
      } else if (ddy === 0) {
        t0 = w0;
      } else {
        ysign = Base_Helpers.sign(ddy);
        t0 = r0 / ddy * ysign;
        if (Math.abs(ddx * t0) > w0 - r0) {
          t0 = Base_Geometry.rayIntersectsCircleOuter(-(w0 - r0), 0, Math.abs(ddx), ddy, r0);
        }
      }
      if (r1 === w1) {
        t1 = r1;
      } else if (ddy === 0) {
        t1 = w1;
      } else {
        ysign = Base_Helpers.sign(ddy);
        t1 = r1 / ddy * ysign;
        if (Math.abs(ddx * t1) > w1 - r1) {
          t1 = Base_Geometry.rayIntersectsCircleOuter(-(w1 - r1), 0, Math.abs(ddx), ddy, r1);
        }
      }
      if (len <= t0 + t1) {
        continue;
      }
      if (paintDetails) {
        decorationSize = Math.min(len / 3, Math.max(2, r * 2));
        if (link.fromDecoration) {
          t0 += decorationSize;
        }
        if (link.toDecoration) {
          t1 += decorationSize;
        }
      }
      x0 += ddx * t0;
      y0 += ddy * t0;
      x1 -= ddx * t1;
      y1 -= ddy * t1;
      dx = x1 - x0;
      dy = y1 - y0;
      len = len - r0 - r1;
      invlen = 1 / len;
      multiId = link.multiId;
      ml = multiLinks[multiId];
      if (Base_Helpers.isArray(ml)) {
        count = ml.length;
        width = Math.min(linkSpacing, r0, r1);
        offset = width * (ml.indexOf(link) - (count - 1) / 2) / (count - 1);
        if (link.from.id > link.to.id) {
          x0 += ddy * offset;
          x1 += ddy * offset;
          y0 -= ddx * offset;
          y1 -= ddx * offset;
        } else {
          x0 -= ddy * offset;
          x1 -= ddy * offset;
          y0 += ddx * offset;
          y1 += ddx * offset;
        }
      }
      g.beginPath();
      if (paintDetails) {
        if (link.fromDecoration) {
          this.paintLinkDecoration(g, x0, y0, ddx, ddy, decorationSize, link.fromDecoration, link.fillColor);
        }
        if (link.toDecoration) {
          this.paintLinkDecoration(g, x1, y1, -ddx, -ddy, decorationSize, link.toDecoration, link.fillColor);
        }
      }
      if (link.dashed) {
        x0a = x0 + ddy * r;
        y0a = y0 - ddx * r;
        x0b = x0 - ddy * r;
        y0b = y0 + ddx * r;
        dashLen = Math.max(5, r * 3);
        for (i = _j = 0, _ref2 = len / dashLen; _j <= _ref2; i = _j += 2) {
          l0 = i * dashLen;
          l1 = Math.min((i + 1) * dashLen, len);
          g.moveTo(x0a + l0 * ddx, y0a + l0 * ddy);
          g.lineTo(x0b + l0 * ddx, y0b + l0 * ddy);
          g.lineTo(x0b + l1 * ddx, y0b + l1 * ddy);
          g.lineTo(x0a + l1 * ddx, y0a + l1 * ddy);
          g.closePath();
        }
      } else {
        g.moveTo(x0 + ddy * r, y0 - ddx * r);
        g.lineTo(x0 - ddy * r, y0 + ddx * r);
        g.lineTo(x1 - ddy * r, y1 + ddx * r);
        g.lineTo(x1 + ddy * r, y1 - ddx * r);
        g.closePath();
      }
      Base_Graphics.fill(g, link);
      if (paintIcons) {
        g.lineWidth = 1;
        g.strokeStyle = link.fillColor;
        if (link.fromIcons && link.fromIcons.length) {
          this.paintLinkIcons(g, x0, y0, ddx, ddy, len, iconRadius, link.fromIcons);
        }
        if (link.toIcons && link.toIcons.length) {
          this.paintLinkIcons(g, x1, y1, -ddx, -ddy, len, iconRadius, link.toIcons);
        }
      }
      if ((zoom > linkLabelMinZoom || active) && (link.label != null) && !link.removed) {
        str = "" + link.label;
        if (str.length > 0) {
          lx = x0 + dx * 0.5;
          ly = y0 + dy * 0.5;
          _results.push(this.paintLabel(g, lx, ly, link));
        } else {
          _results.push(void 0);
        }
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Renderer.prototype.paintNodes = function(g, time) {
    var PI2, a, animating, displayAsText, grad, hiddenLinksStyle, hlinks, iconAngle, iconDistance, iconRadius, im, left, lineHeight, node, nodeDetailMinZoom, nodeLabelMinSize, paintIcons, r, rr, s, scale, style, txa, txm, tya, tym, w, width, x, x0s, x0w, x1s, x1w, xx, y, y0s, y0w, y1s, y1w, zoom, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2, _ref3;
    PI2 = Math.PI * 2;
    animating = false;
    _ref = this.getGeometry(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
    nodeDetailMinZoom = this.scene.settings.style.nodeDetailMinZoom;
    nodeLabelMinSize = this.scene.settings.style.nodeLabelMinSize / 2;
    iconAngle = this.scene.settings.style.iconNodeAngle;
    paintIcons = zoom > this.scene.settings.style.iconsMinZoom;
    iconDistance = this.scene.settings.style.iconNodeDistance;
    hiddenLinksStyle = this.scene.settings.style.hiddenLinks;
    iconRadius = this.scene.settings.style.iconSize / 2;
    displayAsText = this.scene.settings.style.nodeDisplay === "text";
    g.textAlign = "center";
    g.textBaseline = "middle";
    Base_Graphics.textStyle(g, this.scene.settings.style.nodeLabel);
    lineHeight = g.measureText("M").width;
    _ref1 = this.scene.nodes;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      node = _ref1[_i];
      if (!node.data) {
        continue;
      }
      x = node.x;
      y = node.y;
      rr = node.renderRadius;
      r = node.currentRadius;
      w = node.currentHwidth;
      if (x + rr < x0w || x - rr > x1w || y + rr < y0w || y - rr > y1w) {
        continue;
      }
      x = x * txm + txa;
      y = y * tym + tya;
      r = r * zoom;
      w = w * zoom;
      if (node.highlight) {
        this.paintHilight(g, x, y, rr, w, zoom, node.highlight);
      }
      if (!node.removed && zoom >= nodeDetailMinZoom) {
        hlinks = node.dataLinks.length - node.links.length;
        if (hlinks > 0) {
          this.paintHiddenLinks(g, node, x, y, r, hlinks, hiddenLinksStyle, hiddenLinksStyle.size * zoom);
        }
      }
      g.beginPath();
      if (r !== w) {
        xx = x + w - r;
        g.moveTo(xx, y - r);
        g.arc(xx, y, r, -Math.PI / 2, Math.PI / 2, false);
        xx = x - w + r;
        g.lineTo(xx, y + r);
        g.arc(xx, y, r, Math.PI * 0.5, Math.PI * 1.5, false);
        g.closePath();
      } else {
        g.moveTo(x + r, y);
        g.arc(x, y, r, 0, PI2);
      }
      Base_Graphics.paint(g, node);
      if (zoom >= nodeDetailMinZoom || node.active) {
        left = x - w;
        im = this.getNodeImage(node);
        if (im != null) {
          if (node.imageSlicing) {
            s = node.imageSlicing;
            g.drawImage(im, s[0], s[1], s[2], s[3], left, y - r, r * 2, r * 2);
          } else {
            g.drawImage(im, 0, 0, im.width, im.height, left, y - r, r * 2, r * 2);
          }
          left += r * 2;
        }
        if (!node.removed) {
          if (paintIcons && node.icons && node.icons.length) {
            this.paintNodeIcons(g, x - w + r, y, r + iconDistance, iconAngle, iconRadius, node.icons);
          }
        }
        if ((node.label != null) && displayAsText && r > 2) {
          g.save();
          scale = 1.6 * r / lineHeight;
          Base_Graphics.textStyle(g, node.labelStyle);
          g.transform(scale, 0, 0, scale, (left + x + w) / 2, y);
          g.fillText(node.label, 0, 0);
          g.restore();
        }
      }
    }
    if (!displayAsText) {
      _ref2 = this.scene.nodes;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        node = _ref2[_j];
        if (!((node.label != null) && !node.removed && node.renderRadius > nodeLabelMinSize)) {
          continue;
        }
        x = node.x * txm + txa;
        y = node.y * tym + tya;
        if (node.labelLocation === "inside") {
          y += node.currentRadius * zoom / 2;
        } else if (node.labelLocation === "center") {
          1;
        } else {
          rr = node.renderRadius;
          y += rr + lineHeight;
        }
        this.paintLabel(g, x, y, node);
      }
    }
    if (this.scene.settings.advanced.perNodeLoadingIndicator) {
      style = this.scene.settings.advanced.style.loadingArcStyle;
      width = style.lineWidth;
      g.save();
      g.lineCap = 'round';
      g.lineWidth = width;
      a = time / 1400;
      a = (a - Math.floor(a)) * (Math.PI * 2);
      _ref3 = this.scene.nodes;
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        node = _ref3[_k];
        if (node.loading) {
          animating = true;
          x = node.x * txm + txa;
          y = node.y * tym + tya;
          r = node.currentRadius * zoom;
          if (x - r < x0s || x + r > x1s || y - r < y0s || y + r > y1s) {
            continue;
          }
          grad = g.createLinearGradient(x + r * Math.cos(a + Math.PI), y + r * Math.sin(a + Math.PI), x + r * Math.cos(a), y + r * Math.sin(a));
          grad.addColorStop(0, style.lineColor);
          grad.addColorStop(1, "transparent");
          g.strokeStyle = grad;
          g.beginPath();
          g.arc(x, y, r, a, a + Math.PI);
          g.stroke();
        }
      }
      g.restore();
    }
    return animating;
  };

  Netchart_Renderer.prototype.paintSelection = function(g) {
    var PI2, cons, ddx, ddy, dx, dy, invLen, n1, n2, obj, prop, r, selStyle, txa, txm, tya, tym, w, x, x0, x0s, x0w, x1, x1s, x1w, xx, y, y0, y0s, y0w, y1, y1s, y1w, zoom, _i, _len, _ref, _ref1;
    if (!(this.scene.selection.length > 0)) {
      return;
    }
    _ref = this.getGeometry(), txm = _ref[0], txa = _ref[1], tym = _ref[2], tya = _ref[3], zoom = _ref[4], x0s = _ref[5], x1s = _ref[6], y0s = _ref[7], y1s = _ref[8], x0w = _ref[9], y0w = _ref[10], x1w = _ref[11], y1w = _ref[12];
    PI2 = Math.PI * 2;
    selStyle = this.scene.settings.style.selection;
    prop = selStyle.sizeProportional;
    cons = selStyle.sizeConstant;
    g.beginPath();
    _ref1 = this.scene.selection;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      obj = _ref1[_i];
      r = (obj.currentRadius * (1 + prop) + cons) * zoom;
      if (obj.isNode) {
        w = (obj.currentHwidth - obj.currentRadius) * zoom + r;
        x = obj.x * txm + txa;
        y = obj.y * tym + tya;
        xx = x + w - r;
        g.moveTo(xx, y - r);
        g.arc(xx, y, r, -Math.PI / 2, Math.PI / 2, false);
        xx = x - w + r;
        g.lineTo(xx, y + r);
        g.arc(xx, y, r, Math.PI * 0.5, Math.PI * 1.5, false);
        g.closePath();
      } else if (obj.isLink) {
        n1 = obj.from;
        n2 = obj.to;
        x0 = n1.x * txm + txa;
        y0 = n1.y * tym + tya;
        x1 = n2.x * txm + txa;
        y1 = n2.y * tym + tya;
        dx = x0 - x1;
        dy = y0 - y1;
        invLen = r / Math.sqrt(dx * dx + dy * dy);
        ddx = dx * invLen;
        ddy = dy * invLen;
        g.moveTo(x0 + ddy, y0 - ddx);
        g.lineTo(x0 - ddy, y0 + ddx);
        g.lineTo(x1 - ddy, y1 + ddx);
        g.lineTo(x1 + ddy, y1 - ddx);
        g.closePath();
      }
    }
    return Base_Graphics.paint(g, selStyle);
  };

  Netchart_Renderer.prototype.paintLabel = function(g, x, y, object) {
    var balloonStyle, labelCache, labelStyle, lh, lw, text;
    labelCache = object.currentLabel;
    text = object.label;
    labelStyle = object.labelStyle;
    balloonStyle = object.labelBackground;
    Base_Graphics.textStyle(g, labelStyle);
    if (!labelCache || labelCache[0] !== labelStyle.font) {
      lw = g.measureText(text).width;
      lh = g.measureText("M").width;
      object.currentLabel = [labelStyle.font, lw, lh];
    } else {
      lw = labelCache[1];
      lh = labelCache[2];
    }
    if (balloonStyle != null) {
      g.beginPath();
      Base_Graphics.strokeBalloon2(g, x, y, lw, lh);
      Base_Graphics.paint(g, balloonStyle);
      Base_Graphics.textStyle(g, labelStyle);
    }
    return g.fillText(text, x, y);
  };

  Netchart_Renderer.prototype.paintLinkDecoration = function(g, x, y, dx, dy, size, decoration, color) {
    g.fillStyle = color;
    if (decoration === "circle") {
      g.moveTo(x + size, y);
      return g.arc(x, y, size, 0, Math.PI * 2);
    } else if (decoration === "arrow") {
      g.moveTo(x - dx * size, y - dy * size);
      g.lineTo(x + dx * size - dy * size, y + dy * size + dx * size);
      return g.lineTo(x + dx * size + dy * size, y + dy * size - dx * size);
    }
  };

  Netchart_Renderer.prototype.paintLinkPie = function(g, x, y, innerRadius, outerRadius, a0, a1, color) {
    var r, w;
    r = (innerRadius + outerRadius) / 2;
    w = outerRadius - innerRadius;
    g.beginPath();
    g.arc(x, y, r, a0, a1);
    return Base_Graphics.paint(g, {
      lineColor: color,
      lineWidth: w
    });
  };

  Netchart_Renderer.prototype.paintHilight = function(g, x, y, r, w, zoom, style) {
    var PI2, xx;
    PI2 = Math.PI * 2;
    r = r * (1 + style.sizeProportional) + style.sizeConstant * zoom;
    w = w * (1 + style.sizeProportional) + style.sizeConstant * zoom;
    g.beginPath();
    xx = x + w - r;
    g.moveTo(xx, y - r);
    g.arc(xx, y, r, -Math.PI / 2, Math.PI / 2, false);
    xx = x - w + r;
    g.lineTo(xx, y + r);
    g.arc(xx, y, r, Math.PI * 0.5, Math.PI * 1.5, false);
    g.closePath();
    g.arc(x, y, r, 0, PI2);
    return Base_Graphics.paint(g, style);
  };

  Netchart_Renderer.prototype.paintLinkIcons = function(g, x, y, dx, dy, linkLength, iconRadius, icons) {
    var PI2, icon, offset, _i, _len;
    PI2 = Math.PI * 2;
    offset = Math.max(iconRadius, Math.min(linkLength / 2 - (icons.length * 2 + 1) * iconRadius, iconRadius * 3));
    x += dx * offset;
    y += dy * offset;
    dx *= iconRadius * 2;
    dy *= iconRadius * 2;
    for (_i = 0, _len = icons.length; _i < _len; _i++) {
      icon = icons[_i];
      this.paintIcon(g, x, y, iconRadius, icon);
      g.beginPath();
      g.arc(x, y, iconRadius, 0, PI2);
      g.stroke();
      x += dx;
      y += dy;
    }
  };

  Netchart_Renderer.prototype.paintNodeIcons = function(g, x, y, arcRadius, iconAngle, iconRadius, icons) {
    var angle, angleSum, ax, ay, dx, dx1, dy, icon, _i, _len, _results;
    angle = 2 * iconRadius / arcRadius;
    dx = arcRadius * Math.cos(iconAngle);
    dy = arcRadius * Math.sin(iconAngle);
    ax = Math.cos(-angle);
    ay = Math.sin(-angle);
    angleSum = 0;
    _results = [];
    for (_i = 0, _len = icons.length; _i < _len; _i++) {
      icon = icons[_i];
      this.paintIcon(g, x + dx, y + dy, iconRadius, icon);
      dx1 = dx * ax - dy * ay;
      dy = dx * ay + dy * ax;
      dx = dx1;
      angleSum += angle;
      if (angleSum > 3) {
        break;
      } else {
        _results.push(void 0);
      }
    }
    return _results;
  };

  Netchart_Renderer.prototype.paintIcon = function(g, x, y, radius, icon) {
    var image, slicing;
    image = this.getImage(icon.image);
    if (image) {
      slicing = icon.imageSlicing;
      if (slicing) {
        g.drawImage(image, slicing[0], slicing[1], slicing[2], slicing[3], x - radius, y - radius, slicing[2], slicing[3]);
      } else {
        g.drawImage(image, x - radius, y - radius);
      }
      icon.x = x;
      icon.y = y;
    }
  };

  Netchart_Renderer.prototype.paintHiddenLinks = function(g, node, x, y, r, count, style, size) {
    var PI2, da, grad, i, invlen, link, sidePr, sinkPr, tipPr, xc, xc1, xt, xx, yc, yt, yy, _i, _j, _len, _ref;
    PI2 = Math.PI * 2;
    tipPr = (r + size) / r;
    sidePr = size * 0.73 / r;
    sinkPr = (r - size * 0.1) / r;
    if (node.links.length > 0) {
      xx = 0;
      yy = 0;
      _ref = node.links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        link = _ref[_i];
        xx += link.otherEnd(node).x;
        yy += link.otherEnd(node).y;
      }
      xx = node.x - xx / node.links.length;
      yy = node.y - yy / node.links.length;
      invlen = r / Math.sqrt(xx * xx + yy * yy);
      xc = xx * invlen;
      yc = yy * invlen;
    } else {
      xc = r;
      yc = 0;
    }
    da = PI2 / count / 3;
    xt = Math.cos(-da * (count - 1) / 2);
    yt = Math.sin(-da * (count - 1) / 2);
    xc1 = xc * xt - yc * yt;
    yc = xc * yt + yc * xt;
    xc = xc1;
    xt = Math.cos(da);
    yt = Math.sin(da);
    g.beginPath();
    for (i = _j = 1; _j <= count; i = _j += 1) {
      g.moveTo(x + xc, y + yc);
      g.lineTo(x + xc * tipPr, y + yc * tipPr);
      xc1 = xc * xt - yc * yt;
      yc = xc * yt + yc * xt;
      xc = xc1;
    }
    grad = g.createRadialGradient(x, y, Math.max(0, r - size), x, y, r * tipPr);
    grad.addColorStop(0, style.lineColor);
    grad.addColorStop(1, "transparent");
    g.strokeStyle = grad;
    g.lineWidth = style.lineWidth;
    return g.stroke();
  };

  return Netchart_Renderer;

})();

/*
//@ sourceMappingURL=Renderer.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Menu;

Netchart_Menu = (function() {
  "use strict";
  Netchart_Menu.prototype.animationPriority = 10;

  Netchart_Menu.prototype.node = null;

  Netchart_Menu.prototype.link = null;

  Netchart_Menu.prototype.contents = null;

  Netchart_Menu.prototype.x = 0;

  Netchart_Menu.prototype.y = 0;

  function Netchart_Menu(chart) {
    var closeButton;
    this.chart = chart;
    this.container = chart.layers.container;
    this.scene = chart.scene;
    this.events = chart.events;
    this.buttons = [];
    this.popup = Base_Helpers.createDom("div", "DVSL-NC-bar-info", null, this.container);
    closeButton = Base_Helpers.createDom("a", "DVSL-NC-close", "X", this.popup);
    this.popupValue = Base_Helpers.createDom("div", null, null, this.popup);
    this.detailsDiv = Base_Helpers.createDom("div", "DVSL-NC-bar-details", null, this.popup);
    this.popupActions = Base_Helpers.createDom("nav", null, null, this.popup);
    this.buildDetailsPanel(this.detailsDiv);
    this.buildCloseButton(closeButton);
    this.popup.style.position = "absolute";
    this.popup.style.display = "none";
  }

  Netchart_Menu.prototype.doAnimations = function(event) {
    if (this.node == null) {
      return;
    }
    if (((this.node != null) && this.node.removed) || ((this.link != null) && this.link.removed)) {
      return this.hideMenu();
    } else if ((this.node != null) && this.scene.modifiedNodes.hasOwnProperty(this.node.id)) {
      return this.updateMenu();
    }
  };

  Netchart_Menu.prototype.previewPointerDown = function(event) {
    return this.hideMenu();
  };

  Netchart_Menu.prototype.previewWheel = function(event) {
    return this.hideMenu();
  };

  Netchart_Menu.prototype.toggleNodeMenu = function(node) {
    if (this.node === node) {
      return this.hideMenu();
    } else {
      return this.showNodeMenu(node);
    }
  };

  Netchart_Menu.prototype.toggleLinkMenu = function(x, y, link) {
    if (this.link === link) {
      return this.hideMenu();
    } else {
      return this.showLinkMenu(x, y, link);
    }
  };

  Netchart_Menu.prototype.showNodeMenu = function(node) {
    if (!this.scene.settings.nodeMenu.enabled) {
      return;
    }
    if (this.node === node) {
      return this.updateMenu();
    } else {
      this.hideMenu();
      return this.showPopup(node, null);
    }
  };

  Netchart_Menu.prototype.showLinkMenu = function(x, y, link) {
    if (!this.scene.settings.linkMenu.enabled) {
      return;
    }
    this.x = x;
    this.y = y;
    if (this.link === link) {
      return this.updateMenu();
    } else {
      this.hideMenu();
      return this.showPopup(null, link);
    }
  };

  Netchart_Menu.prototype.showPopup = function(node, link) {
    this.node = node;
    this.link = link;
    if (this.node) {
      this.node.locks += 1;
    }
    this.buildButtons();
    this.contents = null;
    this.updateMenu();
    this.popup.style.display = "block";
    this.updateXY();
  };

  Netchart_Menu.prototype.hideMenu = function() {
    if (!this.node && !this.link) {
      return false;
    }
    if (this.node) {
      this.node.locks -= 1;
    }
    this.node = null;
    this.link = null;
    this.popup.style.display = "none";
    return false;
  };

  Netchart_Menu.prototype.updateMenu = function() {
    var callback, contents, curLink, curNode, obj, settings, text;
    if (this.node != null) {
      settings = this.scene.settings.nodeMenu;
      obj = this.node;
    } else {
      settings = this.scene.settings.linkMenu;
      obj = this.link;
    }
    if (settings.contentsFunction) {
      curNode = this.node;
      curLink = this.link;
      callback = function(data) {
        if (this.node === curNode && this.link === curLink) {
          this.contents = data;
          return this.popupValue.innerHTML = data;
        }
      };
      text = settings.contentsFunction.call(this.chart.api, obj.data, obj, callback);
      if (Base_Helpers.isString(text)) {
        contents = text;
      } else if (this.contents === null) {
        contents = "<small>" + this.scene.settings.localization.loadingLabel + "</small>";
      } else {
        contents = this.contents;
      }
    } else {
      contents = obj.label;
    }
    if (contents !== this.contents) {
      this.contents = contents;
      this.popupValue.innerHTML = contents;
    }
    this.updateButtons();
    if (settings.showData) {
      this.details.innerHTML = JSON.stringify(obj.data, null, "  ");
      return this.detailsDiv.style.display = "block";
    } else {
      return this.detailsDiv.style.display = "none";
    }
  };

  Netchart_Menu.prototype.updateXY = function() {
    var h, margin, nx, nx0, nx1, ny, ny0, ny1, w, x0, x1, _ref;
    margin = 12;
    if (this.node != null) {
      _ref = this.scene.toDisplay(this.node.x, this.node.y), nx = _ref[0], ny = _ref[1];
      ny0 = ny - this.node.renderRadius - margin;
      ny1 = ny + this.node.renderRadius + margin;
      nx0 = nx - this.node.renderRadius - margin;
      nx1 = nx + this.node.renderRadius + margin;
    } else {
      ny0 = ny1 = ny = this.y;
      nx0 = this.x - margin;
      nx1 = this.x + margin;
    }
    x0 = this.scene.x0;
    x1 = this.scene.x0 + this.scene.width;
    w = this.popup.offsetWidth;
    h = this.popup.offsetHeight;
    ny = Math.max(Math.min(ny, this.scene.y0 + this.scene.height - h), this.scene.y0);
    if (nx1 + w <= x1) {
      nx = nx1;
    } else if (nx0 - w >= x0) {
      nx = nx0 - w;
    } else {
      nx = Math.max(nx0 - w / 2, x0);
      ny = ny1;
    }
    this.popup.style.left = nx + "px";
    return this.popup.style.top = ny + "px";
  };

  Netchart_Menu.prototype.buildButtons = function() {
    var action, button, div, _i, _len, _ref, _results;
    this.popupActions.innerHTML = "";
    this.buttons = [];
    if (this.node != null) {
      _ref = this.scene.settings.nodeMenu.buttons;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        button = _ref[_i];
        if (button === "expand") {
          div = Base_Helpers.createDom("a", "DVSL-NC-button-expand", null, this.popupActions);
          action = this.updateExpandButton;
        } else if (button === "focus") {
          div = Base_Helpers.createDom("a", "DVSL-NC-button-focus", null, this.popupActions);
          action = this.updateFocusButton;
        } else if (button === "lock") {
          div = Base_Helpers.createDom("a", "DVSL-NC-button-lock", null, this.popupActions);
          action = this.updateLockButton;
        } else if (button === "hide") {
          div = Base_Helpers.createDom("a", "DVSL-NC-button-hide", null, this.popupActions);
          action = this.updateHideButton;
        }
        div.href = "#";
        _results.push(this.buttons.push({
          e: div,
          a: action
        }));
      }
      return _results;
    }
  };

  Netchart_Menu.prototype.updateButtons = function() {
    var b, _i, _len, _ref;
    _ref = this.buttons;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      b = _ref[_i];
      b.a.call(this, b.e);
    }
  };

  Netchart_Menu.prototype.updateExpandButton = function(div) {
    var name,
      _this = this;
    if (!this.node.expanded || this.node.dataLinks.length > this.node.links.length) {
      name = this.scene.settings.localization.menu.expand;
      div.className = "DVSL-NC-button-expand";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = function(e) {
        _this.chart.expandNode(_this.node.id, 1);
        return e.preventDefault();
      };
    } else {
      name = this.scene.settings.localization.menu.collapse;
      div.className = "DVSL-NC-button-collapse";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = function(e) {
        _this.chart.collapseNode(_this.node.id);
        return e.preventDefault();
      };
    }
  };

  Netchart_Menu.prototype.updateFocusButton = function(div) {
    var name,
      _this = this;
    if (this.node.focused) {
      name = this.scene.settings.localization.menu.unfocus;
      div.className = "DVSL-NC-button-unfocus";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = function(e) {
        _this.chart.removeFocusNode(_this.node.id);
        return e.preventDefault();
      };
    } else {
      name = this.scene.settings.localization.menu.focus;
      div.className = "DVSL-NC-button-focus";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = function(e) {
        _this.chart.addFocusNode(_this.node.id);
        return e.preventDefault();
      };
    }
  };

  Netchart_Menu.prototype.updateLockButton = function(div) {
    var name,
      _this = this;
    if (this.node.userLock) {
      name = this.scene.settings.localization.menu.fixed;
      div.className = "DVSL-NC-button-lock";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = function(e) {
        _this.chart.unlockNode(_this.node.id);
        return e.preventDefault();
      };
    } else {
      name = this.scene.settings.localization.menu.dynaminc;
      div.className = "DVSL-NC-button-unlock";
      div.title = name;
      div.innerHTML = name;
      return div.onclick = function(e) {
        _this.chart.lockNode(_this.node.id);
        return e.preventDefault();
      };
    }
  };

  Netchart_Menu.prototype.updateHideButton = function(div) {
    var name,
      _this = this;
    name = this.scene.settings.localization.menu.hide;
    div.className = "DVSL-NC-button-hide";
    div.title = name;
    div.innerHTML = name;
    return div.onclick = function(e) {
      _this.chart.hideNode(_this.node.id);
      return e.preventDefault();
    };
  };

  Netchart_Menu.prototype.buildCloseButton = function(a) {
    var _this = this;
    a.title = this.scene.settings.localization.closeButton;
    a.href = "#";
    return a.onclick = function(e) {
      _this.hideMenu();
      return e.preventDefault();
    };
  };

  Netchart_Menu.prototype.buildDetailsPanel = function(div) {
    var a, d;
    a = Base_Helpers.createDom("small", null, "Technical data", div);
    this.details = d = Base_Helpers.createDom("pre", null, "", div);
    d.style.display = "none";
    return a.onclick = function() {
      if (d.style.display === "none") {
        return d.style.display = "block";
      } else {
        return d.style.display = "none";
      }
    };
  };

  return Netchart_Menu;

})();

/*
//@ sourceMappingURL=Menu.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_InfoPopup;

Netchart_InfoPopup = (function() {
  function Netchart_InfoPopup(chart) {
    this.chart = chart;
    this.scene = chart.scene;
    this.options = this.scene.settings;
    this.item = null;
    this.x = null;
    this.y = null;
    this.popup = new Base_InfoPopup(chart);
  }

  Netchart_InfoPopup.prototype.previewPointerMove = function(event) {
    return this.onMove(event.x, event.y);
  };

  Netchart_InfoPopup.prototype.doAnimations = function(event) {
    if (this.x !== null && this.y !== null) {
      return this.onMove(this.x, this.y);
    }
  };

  Netchart_InfoPopup.prototype.previewPointerDown = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Netchart_InfoPopup.prototype.previewPointerDrag = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Netchart_InfoPopup.prototype.onPointerOut = function(event) {
    this.x = this.y = null;
    return this.setCurrentObject(0, 0, null);
  };

  Netchart_InfoPopup.prototype.onMove = function(x, y) {
    var item;
    this.x = x;
    this.y = y;
    if (!this.options.info.enabled) {
      return;
    }
    item = this.scene.hoverNode ? this.scene.hoverNode : this.scene.hoverLink;
    return this.setCurrentObject(x, y, item);
  };

  Netchart_InfoPopup.prototype.setCurrentObject = function(x, y, item) {
    var contents;
    if (!item) {
      this.item = null;
      return this.popup.hide();
    } else {
      if (item !== this.item) {
        contents = this.buildContents(item);
        this.popup.show(x, x, y, contents);
      } else {
        this.popup.updateXY(x, x, y);
      }
      return this.item = item;
    }
  };

  Netchart_InfoPopup.prototype.buildContents = function(item) {
    var callback, func,
      _this = this;
    func = null;
    if (item instanceof Netchart_Node) {
      func = this.options.info.nodeContentsFunction;
    } else if (item instanceof Netchart_Link) {
      func = this.options.info.linkContentsFunction;
    }
    if (func) {
      callback = function(contents) {
        if (item === _this.item) {
          return _this.popup.updateContents(contents);
        }
      };
      return func.call(this.scene.api, item.data, item, callback);
    } else {
      return item.label;
    }
  };

  return Netchart_InfoPopup;

})();

/*
//@ sourceMappingURL=InfoPopup.map
*/

// Generated by CoffeeScript 1.6.3
var Netchart_Impl,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Netchart_Impl = (function(_super) {
  __extends(Netchart_Impl, _super);

  "use strict";

  Netchart_Impl.prototype.api = null;

  Netchart_Impl.prototype.renderer = null;

  Netchart_Impl.prototype.scrolling = null;

  Netchart_Impl.prototype.selection = null;

  function Netchart_Impl(settings, api) {
    this.defaultDoubleClick = __bind(this.defaultDoubleClick, this);
    this.defaultRightClick = __bind(this.defaultRightClick, this);
    this.defaultClick = __bind(this.defaultClick, this);
    this.onSizeChanged = __bind(this.onSizeChanged, this);
    this.settings = new Netchart_Settings(settings);
    Netchart_Impl.__super__.constructor.call(this, this.settings);
    this.scene = new Netchart_Scene();
    this.scene.settings = this.settings;
    this.graph = new Netchart_Graph(this);
    this.navigator = new Netchart_Navigator(this);
    this.scrolling = new Netchart_Scrolling(this);
    this.layout = new Netchart_Layout(this);
    this.layers = new Netchart_Layers(this, this.scene);
    this.scrolling.resetZoom = true;
    this.initialize(api);
    this.renderer = new Netchart_Renderer(this);
    this.info = new Netchart_InfoPopup(this);
    this.menu = new Netchart_Menu(this);
    this.events.addElement(this.graph);
    this.events.addElement(this.navigator);
    this.events.addElement(this.layout);
    this.events.addElement(this.scrolling);
    this.events.addElement(new Netchart_Selection(this));
    this.events.addElement(new Netchart_Styles(this));
    this.events.addElement(this.renderer);
    this.events.addElement(new Netchart_ZoomControl(this));
    this.events.addElement(new Base_Resizer(this));
    this.events.addElement(new Base_MessagesOverlay(this));
    this.events.addElement(this.menu);
    this.events.addElement(this.info);
    this.scene.data = new Netchart_Data(this);
    this.scene.loading = false;
    this.navigator.showInitialNodes();
    this.updateSize();
    this.events.notifySceneChanges({
      settings: true,
      data: true,
      bounds: true
    });
    this.updateEvents({}, this.settings.events);
  }

  Netchart_Impl.prototype.onAssetsLoaded = function() {
    return this.updateSize();
  };

  Netchart_Impl.prototype.onRemove = function() {
    this.layers = null;
    this.renderer = null;
    this.scene.data.remove();
    this.scene.data = null;
    return this.scene = null;
  };

  Netchart_Impl.prototype.onSettingsChanged = function(changes) {
    var ch, reinitChart;
    this.layers.updateSettings(changes);
    ch = {};
    reinitChart = changes.navigation && (changes.navigation.mode || changes.navigation.initialNodes);
    if ((changes.data != null) && (changes.data.dataFunction || changes.data.format || (changes.data.units != null) || changes.data.preloaded || changes.data.url)) {
      if (this.scene.data) {
        this.scene.data.remove();
      }
      this.scene.data = new Netchart_Data(this);
      ch.data = true;
      reinitChart = true;
    }
    if (reinitChart) {
      this.navigator.showInitialNodes();
      this.scrolling.resetZoom = true;
    }
    if (changes.filters) {
      this.navigator.updateGraph();
      this.graph.updateFilter();
    }
    return this.events.notifySceneChanges(ch);
  };

  Netchart_Impl.prototype.save = function() {
    var nav, xy;
    xy = this.graph.save();
    nav = this.navigator.save();
    return JSON.stringify({
      xy: xy,
      nav: nav
    });
  };

  Netchart_Impl.prototype.restore = function(stateStr, animate) {
    var nav, state, xy;
    if (!stateStr) {
      return;
    }
    state = JSON.parse(stateStr);
    xy = state.xy;
    nav = state.nav;
    if (!xy || !nav) {
      this.error("Cannt restore state: missing data in state");
      return;
    }
    this.navigator.restore(nav);
    this.graph.restore(xy);
    return this.scrolling.resetZoom = true;
  };

  Netchart_Impl.prototype.onSizeChanged = function(clientWidth, clientHeight) {
    this.scene.y0 = 0;
    this.scene.x0 = 0;
    this.scene.height = clientHeight;
    this.scene.width = clientWidth;
    this.layers.updateSize();
    if (this.events != null) {
      return this.events.notifySceneChanges({
        bounds: true
      });
    }
  };

  Netchart_Impl.prototype.reloadData = function() {
    this.scene.data = new Netchart_Data(this);
    return this.events.notifySceneChanges({
      data: true
    });
  };

  Netchart_Impl.prototype.lockNode = function(id, x, y) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.graph.lockNode(id, x, y);
  };

  Netchart_Impl.prototype.unlockNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.graph.unlockNode(id);
  };

  Netchart_Impl.prototype.addFocusNode = function(id, levels) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    if (this.settings.navigation.autoZoomOnFocus) {
      this.scene.settings.interaction.zooming.autoZoom = true;
    }
    return this.navigator.addFocusNode(id, levels);
  };

  Netchart_Impl.prototype.clearFocus = function() {
    return this.navigator.clear();
  };

  Netchart_Impl.prototype.removeFocusNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.unexpandNode(id);
  };

  Netchart_Impl.prototype.expandNode = function(id, levels) {
    if (levels == null) {
      levels = 1;
    }
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.expandNode(id, levels + 1);
  };

  Netchart_Impl.prototype.collapseNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.collapseNode(id);
  };

  Netchart_Impl.prototype.uncollapseNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.uncollapseNode(id);
  };

  Netchart_Impl.prototype.hideNode = function(id) {
    if (Base_Helpers.isObject(id)) {
      id = id.id;
    }
    return this.navigator.hideNode(id);
  };

  Netchart_Impl.prototype.setSelection = function(selection, alreadyChanged) {
    var hasChanges, n, realSelection, _i, _len;
    realSelection = [];
    for (_i = 0, _len = selection.length; _i < _len; _i++) {
      n = selection[_i];
      if (n instanceof Netchart_Node || n instanceof Netchart_Link) {
        realSelection.push(n);
      } else {
        this.error("SetSelection: Non chart object in selection: " + n);
      }
    }
    hasChanges = alreadyChanged | this.scene.selection.length !== realSelection.length;
    if (realSelection.length === 1 && !hasChanges) {
      hasChanges = this.scene.selection[0] !== realSelection[0];
    }
    if (hasChanges) {
      this.scene.selection = realSelection;
      this.events.notifySceneChanges({
        selection: true
      });
      return this.notifySelectionChanged("api");
    }
  };

  Netchart_Impl.prototype.zoomIn = function(nodes, animate) {
    return this.error("ZoomIn: not implmeneted");
  };

  Netchart_Impl.prototype.closePopup = function() {
    return this.menu.hideMenu();
  };

  /* events*/


  Netchart_Impl.prototype.extendEventParams = function(p) {
    p.nodes = this.scene.nodes;
    p.links = this.scene.links;
    p.hoverLink = this.scene.hoverLink;
    p.hoverNode = this.scene.hoverNode;
    p.selection = this.scene.selection;
    return p;
  };

  Netchart_Impl.prototype.defaultClick = function(event) {
    var node;
    if (event.clickNode != null) {
      node = event.clickNode;
      if (!node.expanded) {
        if (this.scene.settings.navigation.expandOnClick) {
          this.expandNode(node.id);
          return event.preventDefault();
        }
      }
    }
  };

  Netchart_Impl.prototype.defaultRightClick = function(event) {
    if (event.clickNode != null) {
      this.scene.data.getNodeLinks(event.clickNode.id);
      this.menu.toggleNodeMenu(event.clickNode);
      event.preventDefault();
    }
    if (event.clickLink != null) {
      this.menu.toggleLinkMenu(event.x, event.y, event.clickLink);
      return event.preventDefault();
    }
  };

  Netchart_Impl.prototype.defaultDoubleClick = function(event) {
    var node;
    node = event.clickNode;
    if (node) {
      this.addFocusNode(node.id);
      return event.preventDefault();
    }
  };

  return Netchart_Impl;

})(Base_Impl);

/*
//@ sourceMappingURL=Impl.map
*/

// Generated by CoffeeScript 1.6.3
var NetChart,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

NetChart = (function(_super) {
  __extends(NetChart, _super);

  "use strict";

  NetChart._impl = null;

  NetChart._scene = null;

  NetChart.settings = null;

  function NetChart(settings) {
    /*
    Executed when **new NetChart(settings)** is called. Will create new chart, filling the whole container, load data and display.
    */

    this.themes = NetChart.themes;
    this._impl = new Netchart_Impl(settings, this);
    this.settings = this._impl.settings;
    this._scene = this._impl.scene;
    return this;
  }

  NetChart.prototype.updateFilters = function() {
    /*
      Forces filter reevaluation. Call when filter behavior has changed.
    */

    this._impl.updateSettings({
      filters: {}
    }, "api");
    return this;
  };

  NetChart.prototype.showNode = function(id) {
    return this._impl.expandNode(id, 1);
  };

  NetChart.prototype.hideNode = function(id) {
    return this._impl.hideNode(id);
  };

  NetChart.prototype.expandNode = function(id) {
    return this._impl.expandNode(id);
  };

  NetChart.prototype.addFocusNode = function(id, range) {
    return this._impl.addFocusNode(id, range);
  };

  NetChart.prototype.removeFocusNode = function(id) {
    return this._impl.removeFocusNode(id);
  };

  NetChart.prototype.clearFocus = function() {
    return this._impl.clearFocus();
  };

  NetChart.prototype.collapseNode = function(id) {
    return this._impl.collapseNode(id);
  };

  NetChart.prototype.lockNode = function(id, x, y) {
    return this._impl.lockNode(id, x, y);
  };

  NetChart.prototype.unlockNode = function(id) {
    return this._impl.unlockNode(id);
  };

  NetChart.prototype.selection = function(selected) {
    /*
      Set/get selection in javascript timestamp (milliseconds).
      Use null, null to remove selection.
      returns [from, to] in list form.
    */

    if (selected != null) {
      this._impl.setSelection(selected);
    }
    return this._scene.selection;
  };

  NetChart.prototype.back = function() {
    return this._impl.back();
  };

  NetChart.prototype.zoomIn = function(objects, animate) {
    if (animate == null) {
      animate = true;
    }
    /*
      Zooms in to list of objects
    */

    return this._impl.zoomIn(objects, animate);
  };

  NetChart.prototype.closePopup = function() {
    return this._impl.closePopup();
  };

  return NetChart;

})(Base_Api);

/*
//@ sourceMappingURL=NetChart.map
*/


    this.NetChart = NetChart;

}).call(this);
